{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! Link We are in Beta! This documentation is brand new and currently in BETA! You can open an issue with your questions or comments. Sections Link Main: Contains the Smart Citizen Kit and Smart Citizen Stations documentation to help you use them. Components: Contains all the documentation on the different hardware sensor modules with detailed insights on the sensors behaviour and calibration. Legacy Hardware: Are you a pioneer of participatory sensing looking for the original SCK 1.0 and SCK 1.1 documentation? Check the Legacy Hardware section! Sensor Analysis Framework: Contains all the documentation on the data post-processing framework to obtain insights from the data calibrated by the sensors. Sensor Platform: Contains all the documentation on the sensors web platform where data is collected, stored and visualised. Guides Link The documentation contains multiple guides as step-by-step tutorials to perform essential tasks as installing a sensor type or uploading the software on the sensors. Example guides Installing the Smart Citizen Kit Installing the Smart Citizen Station Installing the an Smart Citizen Kit 1.0 / 1.1 Onboarding new Sensors Uploading SD Card Data Update the Firmware Edit the Firmware Use Machine Learning to Create Models for Sensors Calibration Post process the stations data Open Source Link We're against black boxes! The entire project is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Home"},{"location":"#welcome","text":"We are in Beta! This documentation is brand new and currently in BETA! You can open an issue with your questions or comments.","title":"Welcome!"},{"location":"#sections","text":"Main: Contains the Smart Citizen Kit and Smart Citizen Stations documentation to help you use them. Components: Contains all the documentation on the different hardware sensor modules with detailed insights on the sensors behaviour and calibration. Legacy Hardware: Are you a pioneer of participatory sensing looking for the original SCK 1.0 and SCK 1.1 documentation? Check the Legacy Hardware section! Sensor Analysis Framework: Contains all the documentation on the data post-processing framework to obtain insights from the data calibrated by the sensors. Sensor Platform: Contains all the documentation on the sensors web platform where data is collected, stored and visualised.","title":"Sections"},{"location":"#guides","text":"The documentation contains multiple guides as step-by-step tutorials to perform essential tasks as installing a sensor type or uploading the software on the sensors. Example guides Installing the Smart Citizen Kit Installing the Smart Citizen Station Installing the an Smart Citizen Kit 1.0 / 1.1 Onboarding new Sensors Uploading SD Card Data Update the Firmware Edit the Firmware Use Machine Learning to Create Models for Sensors Calibration Post process the stations data","title":"Guides"},{"location":"#open-source","text":"We're against black boxes! The entire project is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Open Source"},{"location":"Smart Citizen Kit/","text":"Smart Citizen Kit Link A note about versions The following section contains information about the SCK 2.0 and the SCK 2.1. The SCK 2.0 was the development version for the now commercially available SCK 2.1 sponsored thanks to the iSCAPE project under European Community\u2019s H2020 Programme under Grant Agreement No. 689954 Quick links Installation: start.smartcitizen.me Platform: smartcitizen.me Discuss: forum.smartcitizen.me Support: support@smartcitizen.me What is it? Link The Smart Citizen Kit is the core of what we call the Smart Citizen System: a complete set of modular hardware components aiming to provide tools for environmental monitoring , ranging from citizen science and educational activities to more advanced scientific research . The system is designed in a extendable way, with a central data logger (the Data Board ) with network connectivity to which the different components are branched. The system is based on the principle of reproducibility, also integrating non-hardware components such as a dedicated storage platform (/Sensor Platform) and a sensor analysis framework (/Sensor Analysis Framework). On top of that, the system is meant to serve as a base solution for more complex settings , not only related with air quality monitoring. For that purpose, in addition to the Urban Board , the system also provides off-the-shelf support for a wide variety of third party sensors, using the expansion bus as a common port. One example is what we call the Smart Citizen Station : a full solution for low cost air pollution monitoring. The sensors Have a look a the supported sensors in the Firmware ! Measurements Link All the Smart Citizen Kit new sensors generation measure at least air temperature, relative humidity, noise level, ambient light, barometric pressure and particulate matter (PM). SCK 2.1 Link The SCK 2.1 components are listed below: Smart Citizen Kit 2.1 with Particle Sensor and battery (brackets or rain-proof enclosure currently not included) MicroSD card and microSD adapter to SD. USB cable and a USB charger. Measurement Units Sensors Air temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise level dBA Invensense ICS-434342 Ambient light Lux Rohm BH1721FVC Barometric pressure Pa NXP MPL3115A26 Equivalent Carbon Dioxide ppm AMS CCS811 Volatile Organic Compounds ppb AMS CCS811 Particulate Matter PM 1 / 2.5 / 10 \u00b5g/m3 Planttower PMS 5003 SCK 2.0 Link The non-commercially available SCK 2.0 components are listed below: Smart Citizen Kit 2.0 with Particle Sensor and battery with two mounting brackets. MicroSD card and microSD adapter to SD. USB cable and a USB charger. The measurements of the SCK2.0 are listed below: Measurement Units Sensors Air temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise level dBA Invensense ICS-434342 Ambient light Lux Rohm BH1721FVC Barometric pressure Pa NXP MPL3115A26 Particulate Matter PM 1 / 2.5 / 10 \u00b5g/m3 Planttower PMS 5003 Important! SCK 2.0 was the development version for the now commercially available SCK 2.1 The board also includes a SGX MICS-4514 and a MAXIM MAX3010 but those are not supported by the standard firmware configuration. Fore more information visit the Urban Sensor Board on the Components section. Installation instructions Link The sensor comes mounted and almost ready to be used: The first step is to connect the battery. The kit will light in red (configuration mode) and we will be able to configure it by following the instructions at start.smartcitizen.me . After the configuration process, data will be available on the SmartCitizen platform. You can explore the data there or download it using the CSV Download option (guide here ) Power management Link Battery duration Link The SCK comes with a 2000mAh LiPo battery. The battery is meant to be a complete power option for short-term measurements and a backup solution when the kit it is used for long periods. For long exposures, we recommend to permanently connect the USB to kit. The battery duration is dependent on which sensors are enabled or disabled: All sensors publishing over Wi-Fi: 12 hrs. All sensors publishing on SD card: 13 hrs. Without air quality sensors over Wi-Fi: 10 days Without air quality sensors on SD card: 25 days You will note that the kit turns itself off while operating on battery. Actually, this is what we call sleep - mode , an operation mode implemented to reduce consumption while on battery operation. Battery charging Link The SCK has a micro USB port and can be charged like any Smartphone or Tablet using a dedicated adapter or a computer USB port. We recommend using a tablet power adaptor, instead of a computer USB port, for quicker charging. Autonomy can be extended by using a Power Bank, or a 5V PV Panel. User feedback Link The LED serves as an indication of the battery status. If the LED is flashing orange it indicates that the battery must be charged. The battery takes about 4 hours to fully charge. When the battery is fully charged, the LED will change from orange to green . Remember that in addition to these colors you will have the state color of the kit: configuration, network and sd. More details Find more details under the data board section User interfaces Link The data board features a set of user interfaces which provide feedback to the user, as well as two buttons with different functionalities. The main RGB LED provides general feedback of the data board status. Additionally, two buttons are provided for user action. A hardware reset button, which forces a power cut to the board, and a power button, used to change the device's mode, turn on and off the device, and to perform a factory reset. You can see both buttons below: The button Link The main button interaction is detailed below: Function Button action ON Push the button OFF Push the button for 5 seconds CHANGE MODE Push the button multiple times to choose: Setup Wi-Fi Pink FACTORY RESET Push the button 15 seconds for a full reset An example is shown below: Troubleshooting Have a look at the troubleshoothing section to check how you can use the buttons in case of problems with your SCK! Operation modes Link Setup mode Link In this mode, the Kit is ready to be configured in network mode or SD card in start.smartcitizen.me . LED color Kit status Ready to be setup Ready to be setup but battery is low, charge the Kit Ready to be setup, battery charging Ready to be setup, battery charged Wi-Fi mode Link This is the standard mode for a network that requires a Wi-Fi connection. In this way, the device will publish the data every minute on the smartcitizen.me platform. If there is an inserted micro SD card, the data will be stored in duplicate. LED color Kit status Collecting data online Error while collecting data Collecting data online but battery is low, charge the Kit Collecting data online, battery charging Collecting data online, battery charged Warning The kit supports Wi-Fi WEP, WPA/WPA2 and open networks that are common networks in domestic environments and small businesses. But, it does not support WPA/WPA2 Enterprise networks such as EDUROAM or networks with captive portals such as those found in Airports and Hotels SD card mode (offline) Link If we do not have an internet connection we can use the SD mode. In this case the device will record the data on the micro SD card. Later we can read the card using a card reader. The data can be visually spaced in a spreadsheet but also published on the smartcitizen.me platform using the UPLOAD CSV option. LED color Kit status Collecting data offline Error while collecting data Collecting data offline but battery is low, charge the Kit Collecting data offline, battery charging Collecting data offline, battery charged Especial status Link LED color Kit status Busy, please wait! Software update going on! Enclosures Link If we want to leave the kit on the outside for a few days you will need to provide it with extra protection. Below you can see the well-known 3D printed enclosure (for versions without PM sensor): A note about the enclosures Previous versions of the Smart Citizen Kit, without the PMS5003 sensor, included a 3D printed enclosure that holds the Data Board and Urban Sensor Board, as well as the lithium batteries. The enclosure for the Smart Citizen Kit V2.1 is being developed at the moment. A significant redesign is taking place in order to improve its waterproofness and thermal properties. A temporary solution is shown below (build your own enclosure). A prototype of the new enclosure: Want to contribute? Visit the Smart Citizen Enclosures repository to download, modify, or add your own! Build your own Link Warning Keep in mind that casing is designed for short outdoor deployments. If you want a case for long exhibitions abroad, we will soon have a much more rugged enclosure ready! Also, feel free to explore all our enclosures repository for this and other versions of our hardware. Step by step First, you will need the two 3D printed clips. You can download the STL file and print them easily on any RepRap or similar FDM printer. If you don't know how to find a 3D printer, you can look for your nearest Fab Lab or use 3D Hubs . 1.Use scissors to cut an empty plastic bottle at about 12 cm from the top 2.Use the rubber band to fix it using the bottle cap 3.Place the Kit inside and use the rubber band to hold it 4.You have now a simple enclosure to use your Kit outdoors for short measurement periods! You can now install the sensor outdoors! Software Updates Link Sofware updates are release frequently in the Firmware repository . These updates will need to be applied periodically to the two main components of the SCK: the SAMD21 (main processor) and the ESP8266 (Wi-Fi module). Check the instructions under the Update the Firmware section for more information. .led { width: 20px; height: 20px; border-radius:10px; display: inline-block; margin-top: 7px; } .small { width: 14px; height: 14px; border-radius:7px; } .orange { background: orange; } .green { background: lime; } .red { background: red; } .blue { background: blue; } .pink { background: magenta; } .blink { animation:1s blinker linear infinite; } .net { animation:2s net ease infinite; } .net-error { animation:0.4s net linear infinite; } .net-lowbat { animation:1s net-lowbat ease infinite; } .net-chargebat { animation:2s net-chargebat ease infinite; } .net-fullbat { animation:2s net-fullbat ease infinite; } .sd { animation:2s sd ease infinite; } .sd-error { animation:0.4s sd linear infinite; } .sd-lowbat { animation:1s sd-lowbat ease infinite; } .sd-chargebat { animation:2s sd-chargebat ease infinite; } .sd-fullbat { animation:2s sd-fullbat ease infinite; } .setup { animation:2s setup ease infinite; } .setup-error { animation:0.4s setup linear infinite; } .setup-lowbat { animation:1s setup-lowbat ease infinite; } .setup-chargebat { animation:2s setup-chargebat ease infinite; } .setup-fullbat { animation:2s setup-fullbat ease infinite; } .busy { animation:2s busy ease infinite; } .firmware { animation:2s firmware ease infinite; } @keyframes blinker { 0% { opacity: 1.0; } 50% { opacity: 0.0; } 100% { opacity: 1.0; } } @keyframes setup { 0% { background: white;} 50% { background: red;} 100% { background: white;} } @keyframes setup-lowbat { 0% { background: orange; } 15% { background: red; } 85% { background: red; } 100% { background: orange; } } @keyframes setup-chargebat { 0% { background: orange; } 50% { background: red; } 100% { background: orange; } } @keyframes setup-fullbat { 0% { background: lime; } 50% { background: red; } 100% { background: lime; } } @keyframes firmware { 0% { background: white;} 50% { background: lime;} 100% { background: white;} } @keyframes net { 0% { background: white; } 50% { background: blue; } 100% { background: white; } } @keyframes net-lowbat { 0% { background: orange; } 15% { background: blue; } 85% { background: blue; } 100% { background: orange; } } @keyframes net-chargebat { 0% { background: orange; } 50% { background: blue; } 100% { background: orange; } } @keyframes net-fullbat { 0% { background: lime; } 50% { background: blue; } 100% { background: lime; } } @keyframes sd { 0% { background: white; } 50% { background: magenta; } 100% { background: white; } } @keyframes sd-lowbat { 0% { background: orange; } 15% { background: magenta; } 85% { background: magenta; } 100% { background: orange; } } @keyframes sd-chargebat { 0% { background: orange; } 50% { background: magenta; } 100% { background: orange; } } @keyframes sd-fullbat { 0% { background: lime; } 50% { background: magenta; } 100% { background: lime; } } @keyframes busy { 0% { background: white; } 50% { background: black; } 100% { background: white; } }","title":"Smart Citizen Kit"},{"location":"Smart Citizen Kit/#smart-citizen-kit","text":"A note about versions The following section contains information about the SCK 2.0 and the SCK 2.1. The SCK 2.0 was the development version for the now commercially available SCK 2.1 sponsored thanks to the iSCAPE project under European Community\u2019s H2020 Programme under Grant Agreement No. 689954 Quick links Installation: start.smartcitizen.me Platform: smartcitizen.me Discuss: forum.smartcitizen.me Support: support@smartcitizen.me","title":"Smart Citizen Kit"},{"location":"Smart Citizen Kit/#what-is-it","text":"The Smart Citizen Kit is the core of what we call the Smart Citizen System: a complete set of modular hardware components aiming to provide tools for environmental monitoring , ranging from citizen science and educational activities to more advanced scientific research . The system is designed in a extendable way, with a central data logger (the Data Board ) with network connectivity to which the different components are branched. The system is based on the principle of reproducibility, also integrating non-hardware components such as a dedicated storage platform (/Sensor Platform) and a sensor analysis framework (/Sensor Analysis Framework). On top of that, the system is meant to serve as a base solution for more complex settings , not only related with air quality monitoring. For that purpose, in addition to the Urban Board , the system also provides off-the-shelf support for a wide variety of third party sensors, using the expansion bus as a common port. One example is what we call the Smart Citizen Station : a full solution for low cost air pollution monitoring. The sensors Have a look a the supported sensors in the Firmware !","title":"What is it?"},{"location":"Smart Citizen Kit/#measurements","text":"All the Smart Citizen Kit new sensors generation measure at least air temperature, relative humidity, noise level, ambient light, barometric pressure and particulate matter (PM).","title":"Measurements"},{"location":"Smart Citizen Kit/#sck-21","text":"The SCK 2.1 components are listed below: Smart Citizen Kit 2.1 with Particle Sensor and battery (brackets or rain-proof enclosure currently not included) MicroSD card and microSD adapter to SD. USB cable and a USB charger. Measurement Units Sensors Air temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise level dBA Invensense ICS-434342 Ambient light Lux Rohm BH1721FVC Barometric pressure Pa NXP MPL3115A26 Equivalent Carbon Dioxide ppm AMS CCS811 Volatile Organic Compounds ppb AMS CCS811 Particulate Matter PM 1 / 2.5 / 10 \u00b5g/m3 Planttower PMS 5003","title":"SCK 2.1"},{"location":"Smart Citizen Kit/#sck-20","text":"The non-commercially available SCK 2.0 components are listed below: Smart Citizen Kit 2.0 with Particle Sensor and battery with two mounting brackets. MicroSD card and microSD adapter to SD. USB cable and a USB charger. The measurements of the SCK2.0 are listed below: Measurement Units Sensors Air temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise level dBA Invensense ICS-434342 Ambient light Lux Rohm BH1721FVC Barometric pressure Pa NXP MPL3115A26 Particulate Matter PM 1 / 2.5 / 10 \u00b5g/m3 Planttower PMS 5003 Important! SCK 2.0 was the development version for the now commercially available SCK 2.1 The board also includes a SGX MICS-4514 and a MAXIM MAX3010 but those are not supported by the standard firmware configuration. Fore more information visit the Urban Sensor Board on the Components section.","title":"SCK 2.0"},{"location":"Smart Citizen Kit/#installation-instructions","text":"The sensor comes mounted and almost ready to be used: The first step is to connect the battery. The kit will light in red (configuration mode) and we will be able to configure it by following the instructions at start.smartcitizen.me . After the configuration process, data will be available on the SmartCitizen platform. You can explore the data there or download it using the CSV Download option (guide here )","title":"Installation instructions"},{"location":"Smart Citizen Kit/#power-management","text":"","title":"Power management"},{"location":"Smart Citizen Kit/#battery-duration","text":"The SCK comes with a 2000mAh LiPo battery. The battery is meant to be a complete power option for short-term measurements and a backup solution when the kit it is used for long periods. For long exposures, we recommend to permanently connect the USB to kit. The battery duration is dependent on which sensors are enabled or disabled: All sensors publishing over Wi-Fi: 12 hrs. All sensors publishing on SD card: 13 hrs. Without air quality sensors over Wi-Fi: 10 days Without air quality sensors on SD card: 25 days You will note that the kit turns itself off while operating on battery. Actually, this is what we call sleep - mode , an operation mode implemented to reduce consumption while on battery operation.","title":"Battery duration"},{"location":"Smart Citizen Kit/#battery-charging","text":"The SCK has a micro USB port and can be charged like any Smartphone or Tablet using a dedicated adapter or a computer USB port. We recommend using a tablet power adaptor, instead of a computer USB port, for quicker charging. Autonomy can be extended by using a Power Bank, or a 5V PV Panel.","title":"Battery charging"},{"location":"Smart Citizen Kit/#user-feedback","text":"The LED serves as an indication of the battery status. If the LED is flashing orange it indicates that the battery must be charged. The battery takes about 4 hours to fully charge. When the battery is fully charged, the LED will change from orange to green . Remember that in addition to these colors you will have the state color of the kit: configuration, network and sd. More details Find more details under the data board section","title":"User feedback"},{"location":"Smart Citizen Kit/#user-interfaces","text":"The data board features a set of user interfaces which provide feedback to the user, as well as two buttons with different functionalities. The main RGB LED provides general feedback of the data board status. Additionally, two buttons are provided for user action. A hardware reset button, which forces a power cut to the board, and a power button, used to change the device's mode, turn on and off the device, and to perform a factory reset. You can see both buttons below:","title":"User interfaces"},{"location":"Smart Citizen Kit/#the-button","text":"The main button interaction is detailed below: Function Button action ON Push the button OFF Push the button for 5 seconds CHANGE MODE Push the button multiple times to choose: Setup Wi-Fi Pink FACTORY RESET Push the button 15 seconds for a full reset An example is shown below: Troubleshooting Have a look at the troubleshoothing section to check how you can use the buttons in case of problems with your SCK!","title":"The button"},{"location":"Smart Citizen Kit/#operation-modes","text":"","title":"Operation modes"},{"location":"Smart Citizen Kit/#setup-mode","text":"In this mode, the Kit is ready to be configured in network mode or SD card in start.smartcitizen.me . LED color Kit status Ready to be setup Ready to be setup but battery is low, charge the Kit Ready to be setup, battery charging Ready to be setup, battery charged","title":"  Setup mode"},{"location":"Smart Citizen Kit/#wi-fi-mode","text":"This is the standard mode for a network that requires a Wi-Fi connection. In this way, the device will publish the data every minute on the smartcitizen.me platform. If there is an inserted micro SD card, the data will be stored in duplicate. LED color Kit status Collecting data online Error while collecting data Collecting data online but battery is low, charge the Kit Collecting data online, battery charging Collecting data online, battery charged Warning The kit supports Wi-Fi WEP, WPA/WPA2 and open networks that are common networks in domestic environments and small businesses. But, it does not support WPA/WPA2 Enterprise networks such as EDUROAM or networks with captive portals such as those found in Airports and Hotels","title":"  Wi-Fi mode"},{"location":"Smart Citizen Kit/#sd-card-mode-offline","text":"If we do not have an internet connection we can use the SD mode. In this case the device will record the data on the micro SD card. Later we can read the card using a card reader. The data can be visually spaced in a spreadsheet but also published on the smartcitizen.me platform using the UPLOAD CSV option. LED color Kit status Collecting data offline Error while collecting data Collecting data offline but battery is low, charge the Kit Collecting data offline, battery charging Collecting data offline, battery charged","title":"  SD card mode (offline)"},{"location":"Smart Citizen Kit/#especial-status","text":"LED color Kit status Busy, please wait! Software update going on!","title":"Especial status"},{"location":"Smart Citizen Kit/#enclosures","text":"If we want to leave the kit on the outside for a few days you will need to provide it with extra protection. Below you can see the well-known 3D printed enclosure (for versions without PM sensor): A note about the enclosures Previous versions of the Smart Citizen Kit, without the PMS5003 sensor, included a 3D printed enclosure that holds the Data Board and Urban Sensor Board, as well as the lithium batteries. The enclosure for the Smart Citizen Kit V2.1 is being developed at the moment. A significant redesign is taking place in order to improve its waterproofness and thermal properties. A temporary solution is shown below (build your own enclosure). A prototype of the new enclosure: Want to contribute? Visit the Smart Citizen Enclosures repository to download, modify, or add your own!","title":"Enclosures"},{"location":"Smart Citizen Kit/#build-your-own","text":"Warning Keep in mind that casing is designed for short outdoor deployments. If you want a case for long exhibitions abroad, we will soon have a much more rugged enclosure ready! Also, feel free to explore all our enclosures repository for this and other versions of our hardware. Step by step First, you will need the two 3D printed clips. You can download the STL file and print them easily on any RepRap or similar FDM printer. If you don't know how to find a 3D printer, you can look for your nearest Fab Lab or use 3D Hubs . 1.Use scissors to cut an empty plastic bottle at about 12 cm from the top 2.Use the rubber band to fix it using the bottle cap 3.Place the Kit inside and use the rubber band to hold it 4.You have now a simple enclosure to use your Kit outdoors for short measurement periods! You can now install the sensor outdoors!","title":"Build your own"},{"location":"Smart Citizen Kit/#software-updates","text":"Sofware updates are release frequently in the Firmware repository . These updates will need to be applied periodically to the two main components of the SCK: the SAMD21 (main processor) and the ESP8266 (Wi-Fi module). Check the instructions under the Update the Firmware section for more information. .led { width: 20px; height: 20px; border-radius:10px; display: inline-block; margin-top: 7px; } .small { width: 14px; height: 14px; border-radius:7px; } .orange { background: orange; } .green { background: lime; } .red { background: red; } .blue { background: blue; } .pink { background: magenta; } .blink { animation:1s blinker linear infinite; } .net { animation:2s net ease infinite; } .net-error { animation:0.4s net linear infinite; } .net-lowbat { animation:1s net-lowbat ease infinite; } .net-chargebat { animation:2s net-chargebat ease infinite; } .net-fullbat { animation:2s net-fullbat ease infinite; } .sd { animation:2s sd ease infinite; } .sd-error { animation:0.4s sd linear infinite; } .sd-lowbat { animation:1s sd-lowbat ease infinite; } .sd-chargebat { animation:2s sd-chargebat ease infinite; } .sd-fullbat { animation:2s sd-fullbat ease infinite; } .setup { animation:2s setup ease infinite; } .setup-error { animation:0.4s setup linear infinite; } .setup-lowbat { animation:1s setup-lowbat ease infinite; } .setup-chargebat { animation:2s setup-chargebat ease infinite; } .setup-fullbat { animation:2s setup-fullbat ease infinite; } .busy { animation:2s busy ease infinite; } .firmware { animation:2s firmware ease infinite; } @keyframes blinker { 0% { opacity: 1.0; } 50% { opacity: 0.0; } 100% { opacity: 1.0; } } @keyframes setup { 0% { background: white;} 50% { background: red;} 100% { background: white;} } @keyframes setup-lowbat { 0% { background: orange; } 15% { background: red; } 85% { background: red; } 100% { background: orange; } } @keyframes setup-chargebat { 0% { background: orange; } 50% { background: red; } 100% { background: orange; } } @keyframes setup-fullbat { 0% { background: lime; } 50% { background: red; } 100% { background: lime; } } @keyframes firmware { 0% { background: white;} 50% { background: lime;} 100% { background: white;} } @keyframes net { 0% { background: white; } 50% { background: blue; } 100% { background: white; } } @keyframes net-lowbat { 0% { background: orange; } 15% { background: blue; } 85% { background: blue; } 100% { background: orange; } } @keyframes net-chargebat { 0% { background: orange; } 50% { background: blue; } 100% { background: orange; } } @keyframes net-fullbat { 0% { background: lime; } 50% { background: blue; } 100% { background: lime; } } @keyframes sd { 0% { background: white; } 50% { background: magenta; } 100% { background: white; } } @keyframes sd-lowbat { 0% { background: orange; } 15% { background: magenta; } 85% { background: magenta; } 100% { background: orange; } } @keyframes sd-chargebat { 0% { background: orange; } 50% { background: magenta; } 100% { background: orange; } } @keyframes sd-fullbat { 0% { background: lime; } 50% { background: magenta; } 100% { background: lime; } } @keyframes busy { 0% { background: white; } 50% { background: black; } 100% { background: white; } }","title":"Software Updates"},{"location":"Smart Citizen Station/","text":"Smart Citizen Station Link The Smart Citizen Station, formerly known as the High-End Sensors, is aimed at providing the Living Labs with a system for monitoring the performance of their interventions. The Station aims at providing a solution that can be used by the Living Labs not just from a scientific point of view but also as a tool to engage local communities on air pollution related issues. The station is designed with a modular principle where sensors can be added easily added expanding the capabilities of the installation or replaced when they are damaged or the sensors lifetime is over. From a costs perspective while being more expensive than the Smart Citizen Kit it is also conceived as a low-cost solution. That allows to guarantee at least four stations will be available for each Living Lab to increase the spatial resolution and reliability of the measurements. The design builds on top of the Smart Citizen Kit adding an extra set of more accurate sensors especially aimed at measuring air pollutants. The sensors include the Gas Sensor Board, featuring EC Carbon Monoxide, Nitrogen Dioxide and Ozone sensors and the PM Sensor Board, featuring a PM 2.5 / PM 10 sensor. With all the sensor together this Kit provides information on Air Temperature, Relative Humidity, Noise Level, Ambient Light, Barometric Pressure, Particles Matter (PM 2.5 / 10), Carbon Monoxide, Nitrogen Dioxide and Ozone. The sensors are later described in detail in the document at the Sensor Components section. Components Link The Living Labs Station is a modular system based on different sensor board that connected to a central datalogger. Smart Citizen Stations Components Setup The station operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Learn more Learn more about all the components and the software inside the station in the Components documentation section. Sensors Link Measurement Units Sensor Component Air Temperature \u00baC Sensirion SHT-31 Urban Sensor Board Relative Humidity % REL Sensirion SHT-31 Urban Sensor Board Noise Level dBA Invensense ICS-434342 Urban Sensor Board Ambient Light Lux Rohm BH1721FVC Urban Sensor Board Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Urban Sensor Board Carbon Monoxide \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Nitrogen Dioxide \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Carbon Monoxide ppm Alphasense CO-B4 Gas Sensor Pro Board Nitrogen Dioxide ppb Alphasense NO2-B43F Gas Sensor Pro Board Ozone ppb Alphasense OX-B431 Gas Sensor Pro Board Gases Board Temperature \u00baC Sensirion SHT-31 Gas Sensor Pro Board Gases Board Rel. Humidity % REL Sensirion SHT-31 Gas Sensor Pro Board PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 10 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board The Pack Link iSCAPE Smart Citizen Station Urban Board 2.0 Data Board 2.0 PM Board 2.0 + 2 PM sensors Gas Pro Board 2.0 with 3 EC sensors 6Ah Battery Accessories MicroSD card 512MB USB Charger MicroSD to SD card adapter USB Power Supply 2m 3 Wire 220V cable Mounting brackets and screws Mounting tools (1x Wrench + 2 Allen Keys) Instructions Link To start the installation simply visit the setup website stations.iscape.smartcitizen.me Some helpful and important notes before you start: Warning We keep track internally of all sensor deployments and it is very important not to swap the internal components between Station to avoid mismatchs on the calibration data. Done for today? Turn off Every time you want to stop the Kit from logging simply press the button for 5 seconds. The led should stop bliking and your Kit will be OFF . To turn it ON simply press the button again. Get your data from the SD card Download the data from the SD card First turn off your Kit by pressing the button for 5 seconds. Then remove the micro SD card and plug the card on your computer using a Micro SD card reader. You will find inside a YYYY - MM - DD . CSV with all the data. You can follow the Manual CSV data upload guide to manually upload the data to the platform. Data processing The collected data requires a custom and complex data processing using the iScape Sensor Analysis Framework The process will be fully documented here on the next few weeks. Outdoor Link Use the perforated steel tape and the M6 provided to mount the Station on any street light or pole. The Pack also includes the required wrench. Sensor considerations Link Electrochemical sensor The electrochemical sensors need stabilisation time under the testing conditions they will be at. It is important to set and power the sensors with sufficient time (1-2 days) on the test environment for them to adapt. The newer the sensor, the more stabilisation time it requires. For this deployment, you will be receiving brand new sensors. Humidity and temperature extremes will require of further sensor adaptation, in order to dry out or absorb the necessary humidity for their proper functioning. Danger Do not extract/attach the sensor capsule from the base board while powered, this could irreversibly damage the sensor. Particle Sensor The particle sensors measurements are delivered as averages of the two sensors with periodic validity checks. We are currently developing one-shot strategies for battery life improvement, but in the meantime, please make sure the sensor has reliable energy supply if you will use these sensors permanently. Sensor data processing Link We have developed an algorithm that ingests the platform data and processes electrochemical sensor sensor data. This algorithm is in validation stage and will be included in the online platform flow from Smart Citizen once validated. Get in contact Currently we will run the algorithm manually for each station. Please, contact us once you finish the installation. Sensor Analysis Framework Learn more about the sensors calibration on the Sensor Analysis Framework section. Power Link The kit has a battery life of 12 hours as is intended as a backup solution only. That's why a power supply needs to be installed as decribed below. When we no longer want to publish or save more data for a few days we can turn off the kit. To do this, press the button for 5 seconds. If the colors of the LED appear orange indicates that the battery must be charged. The battery takes about 4 hours to fully charge. When the battery is fully charged, change the orange to green . Remember that in addition to the colors you will have the state color of the kit: configuration, network and sd. Power supply Link The Station can be directly powered at 220V AC (Consumption MAX 33W). Batteries The Smart Citizen Station has a higher consumption, mostly due to the fans on the two PM sensors. That means the internal battery last just for 20h, and it is only aimed at providing backup power. For example, we can connect the station on the street light electric line, so the Station gets charged during the night when the lights are on. Solar Panel Unfortunately, we are having some problems with the PV Solar Panel system to power the Station independently. The system is currently under tests, and it will be available in the next few months. Step by step Remove the two covers using the allen keys as explained on the setup instructions. Remove the USB cable and bring inside the 220V power cable. Connect the cable wires with the power supply. Remove the third cover and place the power adapter as seen on the picture. Close the cover and run the Setup process again States of the Kit Link The button Link Function Button action ON Push the button OFF Push the button for 5 seconds CHANGE MODE Push the button multiple times to choose: Setup Wi-Fi Pink FACTORY RESET Push the button 15 seconds for a full reset Operation modes Link Setup mode Link In this mode, the Kit is ready to be configured in network mode or SD card in start.smartcitizen.me . LED color Kit status Ready to be setup Ready to be setup but battery is low, charge the Kit Ready to be setup, battery charging Ready to be setup, battery charged Wi-Fi mode Link This is the standard mode for a network that requires a Wi-Fi connection. In this way, the device will publish the data every minute on the smartcitizen.me platform. If there is an inserted micro SD card, the data will be stored in duplicate. LED color Kit status Collecting data online Error while collecting data Collecting data online but battery is low, charge the Kit Collecting data online, battery charging Collecting data online, battery charged Warning The kit supports Wi-Fi WEP, WPA/WPA2 and open networks that are common networks in domestic environments and small businesses. But, it does not support WPA/WPA2 Enterprise networks such as EDUROAM or networks with captive portals such as those found in Airports and Hotels SD card mode (offline) Link If we do not have an internet connection we can use the SD mode. In this case the device will record the data on the micro SD card. Later we can read the card using a card reader. The data can be visually spaced in a spreadsheet but also published on the smartcitizen.me platform using the UPLOAD CSV option. LED color Kit status Collecting data offline Error while collecting data Collecting data offline but battery is low, charge the Kit Collecting data offline, battery charging Collecting data offline, battery charged Especial status Link LED color Kit status Busy, please wait! Software update going on! Troubleshooting Link Before setup Link Before configuring the Station setup make sure the LED is red. If not, press the button multiple times until the LED turns red. The station does not respond Link If the station does not respond or does not work properly you can do two things: Reboot your Station You can fully reboot your Station by pressing the reset button located under the sensors board as seen on the picture. That will not delete any configuration, it will simply restart your device. Press the RESET button for a second. The light will go off and on and the device will start again. You can also perform a reboot by disconnecting the battery and the USB cable so that the station is restarted. In this way we will not lose any data and configuration except the time in case of being in SD mode . Factory reset your Station You can fully reset the Station to the default settings so you can register again your device. Press the main button for 15 seconds . After 5 seconds the light will go off and will go on again after 15 seconds. Then you can release the button and your device will be fully resetted as a brand new Station. The LED does not turn on and the station does not work Link First of all, push the station button. Maybe it's simply off. If this does not work, surely the station has been left without battery. You will have to charge it using the USB charger. Any other mobile charger will also work. We will know that it is charging when the LED emits orange pulses and once the battery is charged it will emit green The station does not store the data on the SD card. Link Some SD cards may have problems over time. We can try formatting it but in case it does not work any micro SD card we buy at any mobile or computer store it will work. The size is not important and any micro SD or micro SDHC 512MB card up to 32GB will work. Dimensions Link .led { width: 20px; height: 20px; border-radius:10px; display: inline-block; margin-top: 7px; } .small { width: 14px; height: 14px; border-radius:7px; } .orange { background: orange; } .green { background: lime; } .red { background: red; } .blue { background: blue; } .pink { background: magenta; } .blink { animation:1s blinker linear infinite; } .net { animation:2s net ease infinite; } .net-error { animation:0.4s net linear infinite; } .net-lowbat { animation:1s net-lowbat ease infinite; } .net-chargebat { animation:2s net-chargebat ease infinite; } .net-fullbat { animation:2s net-fullbat ease infinite; } .sd { animation:2s sd ease infinite; } .sd-error { animation:0.4s sd linear infinite; } .sd-lowbat { animation:1s sd-lowbat ease infinite; } .sd-chargebat { animation:2s sd-chargebat ease infinite; } .sd-fullbat { animation:2s sd-fullbat ease infinite; } .setup { animation:2s setup ease infinite; } .setup-error { animation:0.4s setup linear infinite; } .setup-lowbat { animation:1s setup-lowbat ease infinite; } .setup-chargebat { animation:2s setup-chargebat ease infinite; } .setup-fullbat { animation:2s setup-fullbat ease infinite; } .busy { animation:2s busy ease infinite; } .firmware { animation:2s firmware ease infinite; } @keyframes blinker { 0% { opacity: 1.0; } 50% { opacity: 0.0; } 100% { opacity: 1.0; } } @keyframes setup { 0% { background: white;} 50% { background: red;} 100% { background: white;} } @keyframes setup-lowbat { 0% { background: orange; } 15% { background: red; } 85% { background: red; } 100% { background: orange; } } @keyframes setup-chargebat { 0% { background: orange; } 50% { background: red; } 100% { background: orange; } } @keyframes setup-fullbat { 0% { background: lime; } 50% { background: red; } 100% { background: lime; } } @keyframes firmware { 0% { background: white;} 50% { background: lime;} 100% { background: white;} } @keyframes net { 0% { background: white; } 50% { background: blue; } 100% { background: white; } } @keyframes net-lowbat { 0% { background: orange; } 15% { background: blue; } 85% { background: blue; } 100% { background: orange; } } @keyframes net-chargebat { 0% { background: orange; } 50% { background: blue; } 100% { background: orange; } } @keyframes net-fullbat { 0% { background: lime; } 50% { background: blue; } 100% { background: lime; } } @keyframes sd { 0% { background: white; } 50% { background: magenta; } 100% { background: white; } } @keyframes sd-lowbat { 0% { background: orange; } 15% { background: magenta; } 85% { background: magenta; } 100% { background: orange; } } @keyframes sd-chargebat { 0% { background: orange; } 50% { background: magenta; } 100% { background: orange; } } @keyframes sd-fullbat { 0% { background: lime; } 50% { background: magenta; } 100% { background: lime; } } @keyframes busy { 0% { background: white; } 50% { background: black; } 100% { background: white; } }","title":"Smart Citizen Station"},{"location":"Smart Citizen Station/#smart-citizen-station","text":"The Smart Citizen Station, formerly known as the High-End Sensors, is aimed at providing the Living Labs with a system for monitoring the performance of their interventions. The Station aims at providing a solution that can be used by the Living Labs not just from a scientific point of view but also as a tool to engage local communities on air pollution related issues. The station is designed with a modular principle where sensors can be added easily added expanding the capabilities of the installation or replaced when they are damaged or the sensors lifetime is over. From a costs perspective while being more expensive than the Smart Citizen Kit it is also conceived as a low-cost solution. That allows to guarantee at least four stations will be available for each Living Lab to increase the spatial resolution and reliability of the measurements. The design builds on top of the Smart Citizen Kit adding an extra set of more accurate sensors especially aimed at measuring air pollutants. The sensors include the Gas Sensor Board, featuring EC Carbon Monoxide, Nitrogen Dioxide and Ozone sensors and the PM Sensor Board, featuring a PM 2.5 / PM 10 sensor. With all the sensor together this Kit provides information on Air Temperature, Relative Humidity, Noise Level, Ambient Light, Barometric Pressure, Particles Matter (PM 2.5 / 10), Carbon Monoxide, Nitrogen Dioxide and Ozone. The sensors are later described in detail in the document at the Sensor Components section.","title":"Smart Citizen Station"},{"location":"Smart Citizen Station/#components","text":"The Living Labs Station is a modular system based on different sensor board that connected to a central datalogger. Smart Citizen Stations Components Setup The station operates as a platform where new sensor modules can be shipped and deployed by the Living Labs themselves when they are finished enabling faster iterations and upgrades even after the project finishes. Learn more Learn more about all the components and the software inside the station in the Components documentation section.","title":"Components"},{"location":"Smart Citizen Station/#sensors","text":"Measurement Units Sensor Component Air Temperature \u00baC Sensirion SHT-31 Urban Sensor Board Relative Humidity % REL Sensirion SHT-31 Urban Sensor Board Noise Level dBA Invensense ICS-434342 Urban Sensor Board Ambient Light Lux Rohm BH1721FVC Urban Sensor Board Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Urban Sensor Board Carbon Monoxide \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Nitrogen Dioxide \u00b5g/m3 (Periodic Baseline Calibration Required) SGX MICS-4514 Urban Sensor Board Carbon Monoxide ppm Alphasense CO-B4 Gas Sensor Pro Board Nitrogen Dioxide ppb Alphasense NO2-B43F Gas Sensor Pro Board Ozone ppb Alphasense OX-B431 Gas Sensor Pro Board Gases Board Temperature \u00baC Sensirion SHT-31 Gas Sensor Pro Board Gases Board Rel. Humidity % REL Sensirion SHT-31 Gas Sensor Pro Board PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board PM 10 \u00b5g/m3 Plantower PMS5003 Dual System PM Sensors Board","title":"Sensors"},{"location":"Smart Citizen Station/#the-pack","text":"iSCAPE Smart Citizen Station Urban Board 2.0 Data Board 2.0 PM Board 2.0 + 2 PM sensors Gas Pro Board 2.0 with 3 EC sensors 6Ah Battery Accessories MicroSD card 512MB USB Charger MicroSD to SD card adapter USB Power Supply 2m 3 Wire 220V cable Mounting brackets and screws Mounting tools (1x Wrench + 2 Allen Keys)","title":"The Pack"},{"location":"Smart Citizen Station/#instructions","text":"To start the installation simply visit the setup website stations.iscape.smartcitizen.me Some helpful and important notes before you start: Warning We keep track internally of all sensor deployments and it is very important not to swap the internal components between Station to avoid mismatchs on the calibration data. Done for today? Turn off Every time you want to stop the Kit from logging simply press the button for 5 seconds. The led should stop bliking and your Kit will be OFF . To turn it ON simply press the button again. Get your data from the SD card Download the data from the SD card First turn off your Kit by pressing the button for 5 seconds. Then remove the micro SD card and plug the card on your computer using a Micro SD card reader. You will find inside a YYYY - MM - DD . CSV with all the data. You can follow the Manual CSV data upload guide to manually upload the data to the platform. Data processing The collected data requires a custom and complex data processing using the iScape Sensor Analysis Framework The process will be fully documented here on the next few weeks.","title":"Instructions"},{"location":"Smart Citizen Station/#outdoor","text":"Use the perforated steel tape and the M6 provided to mount the Station on any street light or pole. The Pack also includes the required wrench.","title":"Outdoor"},{"location":"Smart Citizen Station/#sensor-considerations","text":"Electrochemical sensor The electrochemical sensors need stabilisation time under the testing conditions they will be at. It is important to set and power the sensors with sufficient time (1-2 days) on the test environment for them to adapt. The newer the sensor, the more stabilisation time it requires. For this deployment, you will be receiving brand new sensors. Humidity and temperature extremes will require of further sensor adaptation, in order to dry out or absorb the necessary humidity for their proper functioning. Danger Do not extract/attach the sensor capsule from the base board while powered, this could irreversibly damage the sensor. Particle Sensor The particle sensors measurements are delivered as averages of the two sensors with periodic validity checks. We are currently developing one-shot strategies for battery life improvement, but in the meantime, please make sure the sensor has reliable energy supply if you will use these sensors permanently.","title":"Sensor considerations"},{"location":"Smart Citizen Station/#sensor-data-processing","text":"We have developed an algorithm that ingests the platform data and processes electrochemical sensor sensor data. This algorithm is in validation stage and will be included in the online platform flow from Smart Citizen once validated. Get in contact Currently we will run the algorithm manually for each station. Please, contact us once you finish the installation. Sensor Analysis Framework Learn more about the sensors calibration on the Sensor Analysis Framework section.","title":"Sensor data processing"},{"location":"Smart Citizen Station/#power","text":"The kit has a battery life of 12 hours as is intended as a backup solution only. That's why a power supply needs to be installed as decribed below. When we no longer want to publish or save more data for a few days we can turn off the kit. To do this, press the button for 5 seconds. If the colors of the LED appear orange indicates that the battery must be charged. The battery takes about 4 hours to fully charge. When the battery is fully charged, change the orange to green . Remember that in addition to the colors you will have the state color of the kit: configuration, network and sd.","title":"Power"},{"location":"Smart Citizen Station/#power-supply","text":"The Station can be directly powered at 220V AC (Consumption MAX 33W). Batteries The Smart Citizen Station has a higher consumption, mostly due to the fans on the two PM sensors. That means the internal battery last just for 20h, and it is only aimed at providing backup power. For example, we can connect the station on the street light electric line, so the Station gets charged during the night when the lights are on. Solar Panel Unfortunately, we are having some problems with the PV Solar Panel system to power the Station independently. The system is currently under tests, and it will be available in the next few months. Step by step Remove the two covers using the allen keys as explained on the setup instructions. Remove the USB cable and bring inside the 220V power cable. Connect the cable wires with the power supply. Remove the third cover and place the power adapter as seen on the picture. Close the cover and run the Setup process again","title":"Power supply"},{"location":"Smart Citizen Station/#states-of-the-kit","text":"","title":"States of the Kit"},{"location":"Smart Citizen Station/#the-button","text":"Function Button action ON Push the button OFF Push the button for 5 seconds CHANGE MODE Push the button multiple times to choose: Setup Wi-Fi Pink FACTORY RESET Push the button 15 seconds for a full reset","title":"The button"},{"location":"Smart Citizen Station/#operation-modes","text":"","title":"Operation modes"},{"location":"Smart Citizen Station/#setup-mode","text":"In this mode, the Kit is ready to be configured in network mode or SD card in start.smartcitizen.me . LED color Kit status Ready to be setup Ready to be setup but battery is low, charge the Kit Ready to be setup, battery charging Ready to be setup, battery charged","title":"  Setup mode"},{"location":"Smart Citizen Station/#wi-fi-mode","text":"This is the standard mode for a network that requires a Wi-Fi connection. In this way, the device will publish the data every minute on the smartcitizen.me platform. If there is an inserted micro SD card, the data will be stored in duplicate. LED color Kit status Collecting data online Error while collecting data Collecting data online but battery is low, charge the Kit Collecting data online, battery charging Collecting data online, battery charged Warning The kit supports Wi-Fi WEP, WPA/WPA2 and open networks that are common networks in domestic environments and small businesses. But, it does not support WPA/WPA2 Enterprise networks such as EDUROAM or networks with captive portals such as those found in Airports and Hotels","title":"  Wi-Fi mode"},{"location":"Smart Citizen Station/#sd-card-mode-offline","text":"If we do not have an internet connection we can use the SD mode. In this case the device will record the data on the micro SD card. Later we can read the card using a card reader. The data can be visually spaced in a spreadsheet but also published on the smartcitizen.me platform using the UPLOAD CSV option. LED color Kit status Collecting data offline Error while collecting data Collecting data offline but battery is low, charge the Kit Collecting data offline, battery charging Collecting data offline, battery charged","title":"  SD card mode (offline)"},{"location":"Smart Citizen Station/#especial-status","text":"LED color Kit status Busy, please wait! Software update going on!","title":"Especial status"},{"location":"Smart Citizen Station/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Smart Citizen Station/#before-setup","text":"Before configuring the Station setup make sure the LED is red. If not, press the button multiple times until the LED turns red.","title":"Before setup"},{"location":"Smart Citizen Station/#the-station-does-not-respond","text":"If the station does not respond or does not work properly you can do two things: Reboot your Station You can fully reboot your Station by pressing the reset button located under the sensors board as seen on the picture. That will not delete any configuration, it will simply restart your device. Press the RESET button for a second. The light will go off and on and the device will start again. You can also perform a reboot by disconnecting the battery and the USB cable so that the station is restarted. In this way we will not lose any data and configuration except the time in case of being in SD mode . Factory reset your Station You can fully reset the Station to the default settings so you can register again your device. Press the main button for 15 seconds . After 5 seconds the light will go off and will go on again after 15 seconds. Then you can release the button and your device will be fully resetted as a brand new Station.","title":"The station does not respond"},{"location":"Smart Citizen Station/#the-led-does-not-turn-on-and-the-station-does-not-work","text":"First of all, push the station button. Maybe it's simply off. If this does not work, surely the station has been left without battery. You will have to charge it using the USB charger. Any other mobile charger will also work. We will know that it is charging when the LED emits orange pulses and once the battery is charged it will emit green","title":"The LED does not turn on and the station does not work"},{"location":"Smart Citizen Station/#the-station-does-not-store-the-data-on-the-sd-card","text":"Some SD cards may have problems over time. We can try formatting it but in case it does not work any micro SD card we buy at any mobile or computer store it will work. The size is not important and any micro SD or micro SDHC 512MB card up to 32GB will work.","title":"The station does not store the data on the SD card."},{"location":"Smart Citizen Station/#dimensions","text":".led { width: 20px; height: 20px; border-radius:10px; display: inline-block; margin-top: 7px; } .small { width: 14px; height: 14px; border-radius:7px; } .orange { background: orange; } .green { background: lime; } .red { background: red; } .blue { background: blue; } .pink { background: magenta; } .blink { animation:1s blinker linear infinite; } .net { animation:2s net ease infinite; } .net-error { animation:0.4s net linear infinite; } .net-lowbat { animation:1s net-lowbat ease infinite; } .net-chargebat { animation:2s net-chargebat ease infinite; } .net-fullbat { animation:2s net-fullbat ease infinite; } .sd { animation:2s sd ease infinite; } .sd-error { animation:0.4s sd linear infinite; } .sd-lowbat { animation:1s sd-lowbat ease infinite; } .sd-chargebat { animation:2s sd-chargebat ease infinite; } .sd-fullbat { animation:2s sd-fullbat ease infinite; } .setup { animation:2s setup ease infinite; } .setup-error { animation:0.4s setup linear infinite; } .setup-lowbat { animation:1s setup-lowbat ease infinite; } .setup-chargebat { animation:2s setup-chargebat ease infinite; } .setup-fullbat { animation:2s setup-fullbat ease infinite; } .busy { animation:2s busy ease infinite; } .firmware { animation:2s firmware ease infinite; } @keyframes blinker { 0% { opacity: 1.0; } 50% { opacity: 0.0; } 100% { opacity: 1.0; } } @keyframes setup { 0% { background: white;} 50% { background: red;} 100% { background: white;} } @keyframes setup-lowbat { 0% { background: orange; } 15% { background: red; } 85% { background: red; } 100% { background: orange; } } @keyframes setup-chargebat { 0% { background: orange; } 50% { background: red; } 100% { background: orange; } } @keyframes setup-fullbat { 0% { background: lime; } 50% { background: red; } 100% { background: lime; } } @keyframes firmware { 0% { background: white;} 50% { background: lime;} 100% { background: white;} } @keyframes net { 0% { background: white; } 50% { background: blue; } 100% { background: white; } } @keyframes net-lowbat { 0% { background: orange; } 15% { background: blue; } 85% { background: blue; } 100% { background: orange; } } @keyframes net-chargebat { 0% { background: orange; } 50% { background: blue; } 100% { background: orange; } } @keyframes net-fullbat { 0% { background: lime; } 50% { background: blue; } 100% { background: lime; } } @keyframes sd { 0% { background: white; } 50% { background: magenta; } 100% { background: white; } } @keyframes sd-lowbat { 0% { background: orange; } 15% { background: magenta; } 85% { background: magenta; } 100% { background: orange; } } @keyframes sd-chargebat { 0% { background: orange; } 50% { background: magenta; } 100% { background: orange; } } @keyframes sd-fullbat { 0% { background: lime; } 50% { background: magenta; } 100% { background: lime; } } @keyframes busy { 0% { background: white; } 50% { background: black; } 100% { background: white; } }","title":"Dimensions"},{"location":"Troubleshooting/","text":"Troubleshooting Link The magical reset button Before trying anything else, the data board of your SCK comes with a very functional button that makes a hardware reset on the whole device. This is probably our best first try once the kit has any problem. You can see it here (bottom left): Some issues this might help solving: The kit hasn't been posting data for a while The kit doesn't respond to user interaction with the ON/OFF button The LED is fixed and does not react to anything ... Pressing the reset button will not delete any configuration, it will simply restart your device. The light will go off and on and the device will start again with a white LED. This button is also to be used when reflashing the firmware, by double clicking it. Have a look at the guide here . You can also perform a reboot by disconnecting the battery and the USB cable so that the kit is restarted. In this way we will not lose any data or configuration. However, if we are in SD card mode , the kit won't know what time it is and we will need to give to him. For doing so: Press the ON/OFF button once. The LED should be breathing RED. Connect to the network SmartCitizen [...] and set it up again to log in SD card mode . The network won't show up Link Before configuring the Kit, if the SmartCitizen [...] network doesn't show up, make sure the LED is red. If not, press the button until the LED turns red. Factory reset your kit Link You can fully reset the Kit to the default settings so you can register again your device. Press the main button for 15 seconds . After 5 seconds the light will go off and will go on again after 15 seconds. Then you can release the button and your device will be fully resetted as a brand new Kit. The LED does not turn on and the kit does not work Link First of all, push the kit button. Maybe it's simply off. If this does not work, most likely the kit has been left without battery. You will have to charge it using the USB charger. Any other mobile charger will also work. We will know that it is charging when the LED emits orange pulses and once the battery is charged it will emit green . If the kit does not respond at all, it is probably worth trying with another USB cable, in case there is some problem there. If not, drop us an email or post on the forum The kit does not store the data on the SD card Link Some SD cards may have problems over time. We can try formatting it, but in case it does not work any micro SD card we buy at any mobile or computer store it will work. The size is not important and any micro SD or micro SDHC 512MB card up to 32GB will work. Learn more Learn more about all the components and the software inside the kit in the Components documentation section. Known (fixed) issues Link In this section, we will detail some problems you might have found in the early firmware versions of SCK 2.1. Light sensor reads 0 and temperature/humidity sensor does not work Link The issue is caused due to a firmware bug (light) and a problem with some SHT31 sensors (also fixed by firmware). A full explanation is detailed in the forum and the fix was released with V0.9.4 of the SAMD firmware.","title":"Troubleshooting"},{"location":"Troubleshooting/#troubleshooting","text":"The magical reset button Before trying anything else, the data board of your SCK comes with a very functional button that makes a hardware reset on the whole device. This is probably our best first try once the kit has any problem. You can see it here (bottom left): Some issues this might help solving: The kit hasn't been posting data for a while The kit doesn't respond to user interaction with the ON/OFF button The LED is fixed and does not react to anything ... Pressing the reset button will not delete any configuration, it will simply restart your device. The light will go off and on and the device will start again with a white LED. This button is also to be used when reflashing the firmware, by double clicking it. Have a look at the guide here . You can also perform a reboot by disconnecting the battery and the USB cable so that the kit is restarted. In this way we will not lose any data or configuration. However, if we are in SD card mode , the kit won't know what time it is and we will need to give to him. For doing so: Press the ON/OFF button once. The LED should be breathing RED. Connect to the network SmartCitizen [...] and set it up again to log in SD card mode .","title":"Troubleshooting"},{"location":"Troubleshooting/#the-network-wont-show-up","text":"Before configuring the Kit, if the SmartCitizen [...] network doesn't show up, make sure the LED is red. If not, press the button until the LED turns red.","title":"The network won't show up"},{"location":"Troubleshooting/#factory-reset-your-kit","text":"You can fully reset the Kit to the default settings so you can register again your device. Press the main button for 15 seconds . After 5 seconds the light will go off and will go on again after 15 seconds. Then you can release the button and your device will be fully resetted as a brand new Kit.","title":"Factory reset your kit"},{"location":"Troubleshooting/#the-led-does-not-turn-on-and-the-kit-does-not-work","text":"First of all, push the kit button. Maybe it's simply off. If this does not work, most likely the kit has been left without battery. You will have to charge it using the USB charger. Any other mobile charger will also work. We will know that it is charging when the LED emits orange pulses and once the battery is charged it will emit green . If the kit does not respond at all, it is probably worth trying with another USB cable, in case there is some problem there. If not, drop us an email or post on the forum","title":"The LED does not turn on and the kit does not work"},{"location":"Troubleshooting/#the-kit-does-not-store-the-data-on-the-sd-card","text":"Some SD cards may have problems over time. We can try formatting it, but in case it does not work any micro SD card we buy at any mobile or computer store it will work. The size is not important and any micro SD or micro SDHC 512MB card up to 32GB will work. Learn more Learn more about all the components and the software inside the kit in the Components documentation section.","title":"The kit does not store the data on the SD card"},{"location":"Troubleshooting/#known-fixed-issues","text":"In this section, we will detail some problems you might have found in the early firmware versions of SCK 2.1.","title":"Known (fixed) issues"},{"location":"Troubleshooting/#light-sensor-reads-0-and-temperaturehumidity-sensor-does-not-work","text":"The issue is caused due to a firmware bug (light) and a problem with some SHT31 sensors (also fixed by firmware). A full explanation is detailed in the forum and the fix was released with V0.9.4 of the SAMD firmware.","title":"Light sensor reads 0 and temperature/humidity sensor does not work"},{"location":"_FAQ/","text":"Frequently asked questions Link Can the sensors be placed outdoors? Link Yes. The sensor is designed for both indoors and outdoors use. But if you\u2019re planning to use it outdoors, you will have to consider purchasing also a rainproof enclosure. Can I make my own rainproof enclosure? Link Of course! The manufacturing files for the 3D printed enclosure will be available to download in the Enclosures repository . Throughout the history of the Smart Citizen project, we\u2019ve seen many inventive solutions for placing the sensor outdoors. Can I charge the sensors with a solar panel? Link Sure! But note that the sensor requires a 5V solar panel to work properly. Keeping that in mind, you can buy one of the photovoltaic panels that we provide, or run your own tests. Can I add external sensors to the system? Link Yes. The sensor has an independently configurable auxiliary bus at 3.3V with a SEEED Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART. It can supply power up to 750mA, and it can be enabled or disabled by software. What happens if there is a loss of network connectivity? Link If the sensor is working in network mode and at any time the network is not available, it will store the data on its internal memory and publish all the collected data as soon as the network is available again. Which external sensors can be added? Link For the moment, the list of supported sensors includes some Atlas Scientific probes, some Seeed Grove sensors, and the Chirp moisture sensor, but the options are almost endless. We will add tutorials to use the additional sensors listed above in our documentation.However, in the short term we will only offer support for them via our custom hardware development services. Will I be able to access the collected data? Link Of course! The data collected by your sensor is available for anyone on the Smart Citizen Platform , and you can download it at any time as a CSV file. Besides, you can also use the API to built custom applications to interact with your device. How does the kit record the data? Link The sensor can work in network and SD card modes. In network mode, the sensor publish data to the SC platform over Wi-Fi every minute. In SD card mode, all the collected data is stored locally in CSV format, and it can be later uploaded manually to the platform using the \u201cManual Data Upload\u201d option. What networks does it support? Link The SCK supports Wi-Fi WEP, WPA/WPA2 and open networks that are common networks in domestic environments and small businesses. However, like many other embedded devices such as Apple TV\u00ae or Chromecast\u00ae, it does not support networks with captive portals such as those found in Airports and Hotels. Currently, it also does not WPA/WPA2 Enterprise networks such as EDUROAM. However, they will be supported in the future after a firmware updated. Is there a mobile phone app that lets me view the data? Link Currently there is an android app available, but we are working to make the website fully mobile device friendly, so that no mobile phone app is required. We would rather focus the time of our small team on the kits themselves instead of maintaining apps. So our final aim is to be app free, but fully mobile friendly. How accurate are the measurements? Link Weather, noise, light and PM sensor measurements have been calibrated and validated against reference sensors through both in-house and external validations and they provide accurate data. Chemical gas sensors are to be considered qualitatively rather than quantitatively while calibration algorithms are developed for data accuracy improvement. Will the global platform be maintained after the project finishes release? Link Yes, it will be maintained just as it has been for the past five years. Also, the platform is fully open source so the community can take over the maintenance if at some point the Smart Citizen core team can no longer run it. Are there any notable case studies using similar sensors? Link Yes! A particularly interesting case study is the Making Sense project at Plac\u0327a del Sol in Barcelona, where a group of 15 technology enthusiasts and environmentalists joined a community of neighbours from a middle-class district that has been suffering from noise issues due to the nightlife in the square. You can find more information about this case study at: www.making-sense.eu What happens if i want to move the device or give it to someone else? Link With just one press of a button you can fully reset your sensor and configure it again using your account or a new one. All your previous data will remain available on the platform as it was before the reset. What about using other wireless technologies? Link We are working closely with Barcelona\u2019s The Things Network community to develop a TTN enabled sensor. A LoRA prototype has been tested, but we don\u2019t have dates for the final version yet. BLE, Zigbee, or others are not currently supported, and except for G5, we are not planning to implement them unless there is a custom hardware integration demand. Can I remove my data from the platform? Link Of course. You are the owner of the data that you collect, and you can download and/or delete all your sensor data at any time.","title":" FAQ"},{"location":"_FAQ/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"_FAQ/#can-the-sensors-be-placed-outdoors","text":"Yes. The sensor is designed for both indoors and outdoors use. But if you\u2019re planning to use it outdoors, you will have to consider purchasing also a rainproof enclosure.","title":"Can the sensors be placed outdoors?"},{"location":"_FAQ/#can-i-make-my-own-rainproof-enclosure","text":"Of course! The manufacturing files for the 3D printed enclosure will be available to download in the Enclosures repository . Throughout the history of the Smart Citizen project, we\u2019ve seen many inventive solutions for placing the sensor outdoors.","title":"Can I make my own rainproof enclosure?"},{"location":"_FAQ/#can-i-charge-the-sensors-with-a-solar-panel","text":"Sure! But note that the sensor requires a 5V solar panel to work properly. Keeping that in mind, you can buy one of the photovoltaic panels that we provide, or run your own tests.","title":"Can I charge the sensors with a solar panel?"},{"location":"_FAQ/#can-i-add-external-sensors-to-the-system","text":"Yes. The sensor has an independently configurable auxiliary bus at 3.3V with a SEEED Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART. It can supply power up to 750mA, and it can be enabled or disabled by software.","title":"Can I add external sensors to the system?"},{"location":"_FAQ/#what-happens-if-there-is-a-loss-of-network-connectivity","text":"If the sensor is working in network mode and at any time the network is not available, it will store the data on its internal memory and publish all the collected data as soon as the network is available again.","title":"What happens if there is a loss of network connectivity?"},{"location":"_FAQ/#which-external-sensors-can-be-added","text":"For the moment, the list of supported sensors includes some Atlas Scientific probes, some Seeed Grove sensors, and the Chirp moisture sensor, but the options are almost endless. We will add tutorials to use the additional sensors listed above in our documentation.However, in the short term we will only offer support for them via our custom hardware development services.","title":"Which external sensors can be added?"},{"location":"_FAQ/#will-i-be-able-to-access-the-collected-data","text":"Of course! The data collected by your sensor is available for anyone on the Smart Citizen Platform , and you can download it at any time as a CSV file. Besides, you can also use the API to built custom applications to interact with your device.","title":"Will I be able to access the collected data?"},{"location":"_FAQ/#how-does-the-kit-record-the-data","text":"The sensor can work in network and SD card modes. In network mode, the sensor publish data to the SC platform over Wi-Fi every minute. In SD card mode, all the collected data is stored locally in CSV format, and it can be later uploaded manually to the platform using the \u201cManual Data Upload\u201d option.","title":"How does the kit record the data?"},{"location":"_FAQ/#what-networks-does-it-support","text":"The SCK supports Wi-Fi WEP, WPA/WPA2 and open networks that are common networks in domestic environments and small businesses. However, like many other embedded devices such as Apple TV\u00ae or Chromecast\u00ae, it does not support networks with captive portals such as those found in Airports and Hotels. Currently, it also does not WPA/WPA2 Enterprise networks such as EDUROAM. However, they will be supported in the future after a firmware updated.","title":"What networks does it support?"},{"location":"_FAQ/#is-there-a-mobile-phone-app-that-lets-me-view-the-data","text":"Currently there is an android app available, but we are working to make the website fully mobile device friendly, so that no mobile phone app is required. We would rather focus the time of our small team on the kits themselves instead of maintaining apps. So our final aim is to be app free, but fully mobile friendly.","title":"Is there a mobile phone app that lets me view the data?"},{"location":"_FAQ/#how-accurate-are-the-measurements","text":"Weather, noise, light and PM sensor measurements have been calibrated and validated against reference sensors through both in-house and external validations and they provide accurate data. Chemical gas sensors are to be considered qualitatively rather than quantitatively while calibration algorithms are developed for data accuracy improvement.","title":"How accurate are the measurements?"},{"location":"_FAQ/#will-the-global-platform-be-maintained-after-the-project-finishes-release","text":"Yes, it will be maintained just as it has been for the past five years. Also, the platform is fully open source so the community can take over the maintenance if at some point the Smart Citizen core team can no longer run it.","title":"Will the global platform be maintained after the project finishes release?"},{"location":"_FAQ/#are-there-any-notable-case-studies-using-similar-sensors","text":"Yes! A particularly interesting case study is the Making Sense project at Plac\u0327a del Sol in Barcelona, where a group of 15 technology enthusiasts and environmentalists joined a community of neighbours from a middle-class district that has been suffering from noise issues due to the nightlife in the square. You can find more information about this case study at: www.making-sense.eu","title":"Are there any notable case studies using similar sensors?"},{"location":"_FAQ/#what-happens-if-i-want-to-move-the-device-or-give-it-to-someone-else","text":"With just one press of a button you can fully reset your sensor and configure it again using your account or a new one. All your previous data will remain available on the platform as it was before the reset.","title":"What happens if i want to move the device or give it to someone else?"},{"location":"_FAQ/#what-about-using-other-wireless-technologies","text":"We are working closely with Barcelona\u2019s The Things Network community to develop a TTN enabled sensor. A LoRA prototype has been tested, but we don\u2019t have dates for the final version yet. BLE, Zigbee, or others are not currently supported, and except for G5, we are not planning to implement them unless there is a custom hardware integration demand.","title":"What about using other wireless technologies?"},{"location":"_FAQ/#can-i-remove-my-data-from-the-platform","text":"Of course. You are the owner of the data that you collect, and you can download and/or delete all your sensor data at any time.","title":"Can I remove my data from the platform?"},{"location":"Components/","text":"Components Link The project's sensor platform builds on the legacy of previous Smart Smart Citizen Kit generations to develop a new set of tools especially aimed at providing meaningful data insights on a low budget. The system is designed in a extendable way, with a central data logger with network connectivity to which the different components are branched. The system is based on the principle of reproducibility, also integrating non-hardware components such as a dedicated storage platform and a sensor analysis framework. We believe building modular and reusable hardware is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. Hardware Link The core system bases its sensing capabilities in widely reviewed low cost sensors, and aims to provide a solid framework for environmental monitoring activities. Each of the modules is shown in the Figure below: Data Board: A datalogger at the heart of the sensors architecure supporting the Smart Citizen Kit and the Smart Citizen Stations . Firmware: The software running inside the sensors. Sensor Board: Multiple sensor board have been developed. They can be combined to built the different sensor solutions as the Smart Citizen Kit and the Smart Citizen Stations . Urban Sensor Board: A selection of low-cost sensors in a board ready to measure the urban environment: temperature, humidity, noise, light, and PM2.5, among others. Together with the Data Board they create the Smart Citizen Kit . PM Sensor Board: An auxiliary board capable of driving two Particulate Matter sensor as well as other auxiliary sensors required for specific deployments as an external temperature sensor or an anemometer. It is used in the Smart Citizen Stations . Gas Pro Sensor Board: An auxiliary board driving 3 Alphasense Ltd. Electrochemical Series B Gas Sensors designed for ultra-low noise, high-performance and low power operation. It is used in the Smart Citizen Stations . Open Source Link We're against black boxes! The entire project it is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Index"},{"location":"Components/#components","text":"The project's sensor platform builds on the legacy of previous Smart Smart Citizen Kit generations to develop a new set of tools especially aimed at providing meaningful data insights on a low budget. The system is designed in a extendable way, with a central data logger with network connectivity to which the different components are branched. The system is based on the principle of reproducibility, also integrating non-hardware components such as a dedicated storage platform and a sensor analysis framework. We believe building modular and reusable hardware is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy.","title":"Components"},{"location":"Components/#hardware","text":"The core system bases its sensing capabilities in widely reviewed low cost sensors, and aims to provide a solid framework for environmental monitoring activities. Each of the modules is shown in the Figure below: Data Board: A datalogger at the heart of the sensors architecure supporting the Smart Citizen Kit and the Smart Citizen Stations . Firmware: The software running inside the sensors. Sensor Board: Multiple sensor board have been developed. They can be combined to built the different sensor solutions as the Smart Citizen Kit and the Smart Citizen Stations . Urban Sensor Board: A selection of low-cost sensors in a board ready to measure the urban environment: temperature, humidity, noise, light, and PM2.5, among others. Together with the Data Board they create the Smart Citizen Kit . PM Sensor Board: An auxiliary board capable of driving two Particulate Matter sensor as well as other auxiliary sensors required for specific deployments as an external temperature sensor or an anemometer. It is used in the Smart Citizen Stations . Gas Pro Sensor Board: An auxiliary board driving 3 Alphasense Ltd. Electrochemical Series B Gas Sensors designed for ultra-low noise, high-performance and low power operation. It is used in the Smart Citizen Stations .","title":"Hardware"},{"location":"Components/#open-source","text":"We're against black boxes! The entire project it is released under open source licenses:\u2028 Hardware components: CERN Open Hardware License v1.2 Core firmware: GNU GPL v3.0 Software platform: GNU AGLP v3.0 Info Check the Source files section for each component and explore the software source code and the hardware blueprints.","title":"Open Source"},{"location":"Components/Data Board/","text":"Data Board Link The data board is a data-logger at the core of the sensors architecture supporting the Smart Citizen Kit and the Smart Citizen Station. This module is powered by an ARM M0+ 32-bits 48Mhz SAMD21 running the Smart Citizen Firmware ), combining the low power consumption of the ARM M0 family with the power of a 32-bits processor with 32KB of RAM and 256KB of FLASH memory. This solution offers enough program storage and memory space to support multiple auxiliary sensors. This chip is used by the Arduino Zero and MKR boards, therefore benefiting from the open community built around these boards in particular and the Arduino project in general. Check the source code The data board also includes a Wi-Fi module, a micro SD card slot, an internal Flash and a battery management solution. In addition, it includes 4MB of extra Flash Memory for offline data storage, in case of network brownouts. The Wi-Fi Module is the well-known Espressif ESP8266 IEEE 802.11 b/g/n Wi-Fi with 4MB Internal Flash for web content storage: The Data Board connects to the sensor board providing power, analog and digital communications (12 bits ADC, GPIO, I2C, I2S, VCC). The data board also includes a Seeed Studio standard Grove connector where off-the-shelf modules from the same manufacturer can be connected. The connector supports an independent I2C bus by default, but by software it can be configured to support other uses (GPIO, I2C and UART). It can supply power up to 750mA, and it can be enabled or disabled by software to save power. The board includes a power unit, with a battery management system, capable of handling a variety of Lithium polymer cells. The batteries are connected to a standard JST-2 pin battery connector. The Smart Citizen Kit by default uses a 2000mAh battery, but larger capacities can be used. Under normal conditions, and depending on the sensors enabled, a 2000mAh battery can last between 24 hours (with all sensors enabled, and a 1-minute recording frequency) to more than a week. The board also features a sleep mode , through which drastically lower average consumption are achieved. The controller allows the batteries to be easily charged using the boards micro USB connector using any standard USB power adapter like the ones used on Smartphones. On remote areas, it can also be powered using a selection of PV Panels like Voltaics Systems 6W panel. Firmware Link The Smart Citizen Kit firmware is comprised of two parts: 1) the primary processing tasks are done by the SAMD21 microcontroller firmware; 2) the tasks related to network communication are run through the ESP8266. The SAMD21 is built on top of the Arduino Zero with a custom variant for the Data Board main MCU. The ESP8266 is also built using the Arduino ESP Core. Both firmwares are built and managed with Platform IO, an open-source IDE for embedded development. Platform IO features built-in dependency management and allows you to compile and upload both processors with a single command. Using the SWD ARM connector you can change the MCU bootloader and debug the firmware using Open Source tools. Info Learn more about the software running inside the Data Board on the Firmware section . Software guides Check the firmware guides and learn how to update and even modify the software: Debug the Firmware Edit the Firmware Update the Firmware Buses Link Sensor Boards connector Link The Kit features a modular architecture where sensors can be updated independently by replacing any individual Sensor Board. The Sensor Boards features GPIO, ADC, I2C, UART and I2S connections at 3.3V. Currently, we only offer the Urban Sensor Board, but more boards are on the way, and you can even design and build a custom one. Example of a Sensor Board SAMD21 Pins Arduino Zero Pin SCK Pins SCK Conector SCK Conector SCK Pins Arduino Zero Pin SAMD21 Pins GND GND GND 16 15 GND GND GND GND GND GND 14 13 GND GND GND PA11 0 I2S_FS 12 11 TX A5 PB2 PA7 9 I2S_SD 10 9 RX 25 PB3 PA10 1 I2S_SCK 8 7 VBAT VBAT VBAT PA22 20 SDA 6 5 PWM_CO 13 PA9 PA23 21 SCL 4 3 PWM_NOX 14 PA8 VCC VCC VCC 2 1 VCC VCC VCC Auxiliary connector Link The Data Board features and independent configurable auxiliary bus at 3.3V with a SEEED Studio Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART port. It can supply power up to 750mA, and it can be enabled or disabled by software. Example of devices connected via the AUX connector. Power management Link The Smart Smart Citizen Kit gives us the possibility of running directly from a USB power source with or without lithium battery, using the BQ24259 USB Charger . The charger manages external power regulation, battery fast charging (up to 2Ah) and USB OTG that allow us powering other devices from the SCK (currently not implemented). Normaly the SCK uses a 2000 mAh Lithium polymer battery but it is possible to take advantage of larger batteries. The charging current is regulated with a manual imposed limit that can be configured, and also auto adjusts to the connected USB charger capacity. It is also possible to use solar panel (5v) to charge the SCK. The power consumption of the kit depends on which sensors are enabled and how often they are read/published. Between readings the kit goes to sleep mode turning off almost all the subsystems and reducing the power consumption. In previous versions of the kit (V2.0 and before), the most power-hungry sensors were the SGX MICS gas sensors (NO 2 and CO) which need an always-on heater with a permanent consumption of around 50 mAh (35 hours per charge). In V2.0 and V2.1, the PM sensor needs a fan with a consumption of 35 mAh (50 hours per charge). To improve the power consumption, the PM Sensor works on one-shot mode which turns the sensor off for \u00beths of the time, and only taking a reading after the sensor has stabilised. The kit normal operation cycle on battery is: read sensors, post, and then go to sleep. Until the battery charge is below 3%. When that threshold is passed it will enter an emergency sleep mode and interrupt all the normal functions until the charge goes over 5%. Power consumption Link The base power consumption of the device is 16mA (no sensors or wifi connection). While posting data online, the consumption can go up to 75mA accounting for the ESP8266, with an additional 90mA if all the sensors are to be working at the same time (Urban Sensor Board + PM sensor). Source files Link Download Check the source code","title":"Index"},{"location":"Components/Data Board/#data-board","text":"The data board is a data-logger at the core of the sensors architecture supporting the Smart Citizen Kit and the Smart Citizen Station. This module is powered by an ARM M0+ 32-bits 48Mhz SAMD21 running the Smart Citizen Firmware ), combining the low power consumption of the ARM M0 family with the power of a 32-bits processor with 32KB of RAM and 256KB of FLASH memory. This solution offers enough program storage and memory space to support multiple auxiliary sensors. This chip is used by the Arduino Zero and MKR boards, therefore benefiting from the open community built around these boards in particular and the Arduino project in general. Check the source code The data board also includes a Wi-Fi module, a micro SD card slot, an internal Flash and a battery management solution. In addition, it includes 4MB of extra Flash Memory for offline data storage, in case of network brownouts. The Wi-Fi Module is the well-known Espressif ESP8266 IEEE 802.11 b/g/n Wi-Fi with 4MB Internal Flash for web content storage: The Data Board connects to the sensor board providing power, analog and digital communications (12 bits ADC, GPIO, I2C, I2S, VCC). The data board also includes a Seeed Studio standard Grove connector where off-the-shelf modules from the same manufacturer can be connected. The connector supports an independent I2C bus by default, but by software it can be configured to support other uses (GPIO, I2C and UART). It can supply power up to 750mA, and it can be enabled or disabled by software to save power. The board includes a power unit, with a battery management system, capable of handling a variety of Lithium polymer cells. The batteries are connected to a standard JST-2 pin battery connector. The Smart Citizen Kit by default uses a 2000mAh battery, but larger capacities can be used. Under normal conditions, and depending on the sensors enabled, a 2000mAh battery can last between 24 hours (with all sensors enabled, and a 1-minute recording frequency) to more than a week. The board also features a sleep mode , through which drastically lower average consumption are achieved. The controller allows the batteries to be easily charged using the boards micro USB connector using any standard USB power adapter like the ones used on Smartphones. On remote areas, it can also be powered using a selection of PV Panels like Voltaics Systems 6W panel.","title":"Data Board"},{"location":"Components/Data Board/#firmware","text":"The Smart Citizen Kit firmware is comprised of two parts: 1) the primary processing tasks are done by the SAMD21 microcontroller firmware; 2) the tasks related to network communication are run through the ESP8266. The SAMD21 is built on top of the Arduino Zero with a custom variant for the Data Board main MCU. The ESP8266 is also built using the Arduino ESP Core. Both firmwares are built and managed with Platform IO, an open-source IDE for embedded development. Platform IO features built-in dependency management and allows you to compile and upload both processors with a single command. Using the SWD ARM connector you can change the MCU bootloader and debug the firmware using Open Source tools. Info Learn more about the software running inside the Data Board on the Firmware section . Software guides Check the firmware guides and learn how to update and even modify the software: Debug the Firmware Edit the Firmware Update the Firmware","title":"Firmware"},{"location":"Components/Data Board/#buses","text":"","title":"Buses"},{"location":"Components/Data Board/#sensor-boards-connector","text":"The Kit features a modular architecture where sensors can be updated independently by replacing any individual Sensor Board. The Sensor Boards features GPIO, ADC, I2C, UART and I2S connections at 3.3V. Currently, we only offer the Urban Sensor Board, but more boards are on the way, and you can even design and build a custom one. Example of a Sensor Board SAMD21 Pins Arduino Zero Pin SCK Pins SCK Conector SCK Conector SCK Pins Arduino Zero Pin SAMD21 Pins GND GND GND 16 15 GND GND GND GND GND GND 14 13 GND GND GND PA11 0 I2S_FS 12 11 TX A5 PB2 PA7 9 I2S_SD 10 9 RX 25 PB3 PA10 1 I2S_SCK 8 7 VBAT VBAT VBAT PA22 20 SDA 6 5 PWM_CO 13 PA9 PA23 21 SCL 4 3 PWM_NOX 14 PA8 VCC VCC VCC 2 1 VCC VCC VCC","title":"Sensor Boards connector"},{"location":"Components/Data Board/#auxiliary-connector","text":"The Data Board features and independent configurable auxiliary bus at 3.3V with a SEEED Studio Grove connector. The Bus has native support for I2C, but it can also be setup on firmware as a GPIO or UART port. It can supply power up to 750mA, and it can be enabled or disabled by software. Example of devices connected via the AUX connector.","title":"Auxiliary connector"},{"location":"Components/Data Board/#power-management","text":"The Smart Smart Citizen Kit gives us the possibility of running directly from a USB power source with or without lithium battery, using the BQ24259 USB Charger . The charger manages external power regulation, battery fast charging (up to 2Ah) and USB OTG that allow us powering other devices from the SCK (currently not implemented). Normaly the SCK uses a 2000 mAh Lithium polymer battery but it is possible to take advantage of larger batteries. The charging current is regulated with a manual imposed limit that can be configured, and also auto adjusts to the connected USB charger capacity. It is also possible to use solar panel (5v) to charge the SCK. The power consumption of the kit depends on which sensors are enabled and how often they are read/published. Between readings the kit goes to sleep mode turning off almost all the subsystems and reducing the power consumption. In previous versions of the kit (V2.0 and before), the most power-hungry sensors were the SGX MICS gas sensors (NO 2 and CO) which need an always-on heater with a permanent consumption of around 50 mAh (35 hours per charge). In V2.0 and V2.1, the PM sensor needs a fan with a consumption of 35 mAh (50 hours per charge). To improve the power consumption, the PM Sensor works on one-shot mode which turns the sensor off for \u00beths of the time, and only taking a reading after the sensor has stabilised. The kit normal operation cycle on battery is: read sensors, post, and then go to sleep. Until the battery charge is below 3%. When that threshold is passed it will enter an emergency sleep mode and interrupt all the normal functions until the charge goes over 5%.","title":"Power management"},{"location":"Components/Data Board/#power-consumption","text":"The base power consumption of the device is 16mA (no sensors or wifi connection). While posting data online, the consumption can go up to 75mA accounting for the ESP8266, with an additional 90mA if all the sensors are to be working at the same time (Urban Sensor Board + PM sensor).","title":"Power consumption"},{"location":"Components/Data Board/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Components/Firmware/","text":"Firmware Link The firmware is OOP and is entirely written in C++. Both processors the core ARM MCU and the ESP8266 WIFI are developed as part of the same framework integrating seemingly by using a set of bridge libraries that provide a unifies the RPC architecture. The following software was partially developed by IAAC as part of the Making Sense project under the European Community's H2020 Programme Grant Agreement No. 688620. Firmware updates are done via the micro USB port using the Platform IO software available for Linux, Mac and Windows. Architecture Link Core Microcontroller Link Name Functions Pins Definition for the MCU pinout Sensors Definition for all the sensors supported Sensors Absracts the sensors on a common interface SckBase Manages the core operations: power, connectivity, peripherials SckAux Manages the sensors connected on the AUX connector SckUrban Manages the sensors on the Urban Sensor Board SckCharger Manages the battery charging process SckButton Manages users button interaction actions SckLed Manages light status for user feedback Commands Library to absracts the core features on to a simple shell interface ReadLight Manages configuration over light ReadSound Manages configuration over sound Dependencies Link Adafruit INA219 Library Adafruit MPL3115A2 Library Adafruit SHT31 Library Arduino Json Library Arduino Low Power@ Library ArduinoZero PMUX Report Library DS2482 Library FlashStorage Library FlashStorage MCP342X Library RadioHead Library RTCZero Library SdFat Library SmartSmart Citizen Kit Gases Pro Board Library SparkFun BQ27441 Arduino Library SparkFun MAX3010x Library SPIFlash Library U8g2 Library WiFi Module Link Name Functions SckESP Runs all the Wi-Fi networking related functions Dependencies Link Time Library ArduinoJson Library RemoteDebug Library RemoteDebug Library RadioHead Library RadioHead Library PubSubclient Library Shared Link Name Functions Config Provides a shared configuration between the two MCUs Data management Link The board is capable of storing the recorded data offline on its internal dedicated flash memory of 8MB and later publish this over Wi-Fi connectivity provided by an Espressif ESP8266. Data is published using MQTT messages to the Smart Citizen Platform. NTP is used for syncing the built-in RTC. For long term offline storage, the board provides a standard microSD socket where card in the orders of GB can be employed. That ensures extended periods of data in the order of decades can be stored. Configuration Link The board firmware is fully customizable without requiring any changes to the core software. That includes enabling or disabling sensors, the sampling frequency of the sensors or the operation mode. There different configuration options: via the Serial Shell available when the board is connected over USB, editing the config.txt file when using a microSD card. Detecting : AlphaDelta 1 A ... found , Enabling AlphaDelta 1 A Detecting : AlphaDelta 1 W ... found , already enabled !!! Detecting : AlphaDelta 2 A ... found , already enabled !!! Detecting : AlphaDelta 2 W ... found , already enabled !!! Detecting : AlphaDelta 3 A ... found , already enabled !!! Detecting : AlphaDelta 3 W ... found , already enabled !!! Detecting : AlphaDelta Temperature ... found , already enabled !!! Detecting : AlphaDelta Humidity ... found , already enabled !!! Detecting : Groove ADC ... nothing ! Detecting : INA219 Bus voltage ... nothing ! Detecting : INA219 Shunt voltage ... nothing ! Detecting : INA219 Current ... nothing ! Detecting : INA219 Load voltage ... nothing ! Detecting : DS18B20 Water temperature ... nothing ! Detecting : Atlas PH ... nothing ! Detecting : Atlas Conductivity ... nothing ! Detecting : Atlas Specific gravity ... nothing ! Detecting : Atlas Dissolved Oxygen ... nothing ! Detecting : Atlas DO Saturation ... nothing ! Detecting : Groove OLED ... nothing ! Shell Link The firmware provides a comprehensive command shell over USB to manage all the kits functionalities for advanced users. Use any Serial console as screen , platformio device monitor , or the serial monitor on the Arduino IDE Example commands: SCK > help SCK > config - wifi \"myWifiName\" \"myPassword\" - token myToken - mode network Storage Link Configuration file CONFIG.TXT Link If this file doesn't exist it is generated by the kit with the factory defaults and after that it can be modified by both the user and the kit. SckBase :: resetConfigFile (); If the modification comes from the kit (sound, platform, etc) it should be saved to the flash and then to the SD. When the file is read from the SD if it is valid and different from the flash version the flash version should be updated. There is a problem in this approach: if the user insert and old scard with an old config without erasing it he can mess an newly configured kit. To solve this there is the possibility of having a first entry in the config file that is called something like user_modified and the user should modify this so the new config is loaded. If this flag is not true the sdcard config would be overwritten with the one in the flash. Warning on Factory Reset This file will be restored to default values in a factory reset event. Readings file POST.CSV Link This file is generated and updated by the kit. When a SD is detected this file will be synced with the flash version as the correct one. For this to work we need a fast way to compare the files. We need to test if this is doable in terms of speed. Maybe only do this when it is requested via a command or user input. There should be a way to know if a post has been uploaded to the platform, so when the kit doesn't have a wifi connection it saves the readings and publish them as soon as a network connection is available. Warning on Factory Reset This file will be restored to default values in a factory reset event. Debug log file DEBUG.CSV Link The debug file is generated and updated by the kit, only if the debug mode is enabled on the configuration. When the debug mode is enabled the verbosity level of this file is defined by the outlevel ( normal, verbose or silent ). Warning on Factory Reset This file will be restored to default values in a factory reset event. Source files Link Download Check the source code","title":"Index"},{"location":"Components/Firmware/#firmware","text":"The firmware is OOP and is entirely written in C++. Both processors the core ARM MCU and the ESP8266 WIFI are developed as part of the same framework integrating seemingly by using a set of bridge libraries that provide a unifies the RPC architecture. The following software was partially developed by IAAC as part of the Making Sense project under the European Community's H2020 Programme Grant Agreement No. 688620. Firmware updates are done via the micro USB port using the Platform IO software available for Linux, Mac and Windows.","title":"Firmware"},{"location":"Components/Firmware/#architecture","text":"","title":"Architecture"},{"location":"Components/Firmware/#core-microcontroller","text":"Name Functions Pins Definition for the MCU pinout Sensors Definition for all the sensors supported Sensors Absracts the sensors on a common interface SckBase Manages the core operations: power, connectivity, peripherials SckAux Manages the sensors connected on the AUX connector SckUrban Manages the sensors on the Urban Sensor Board SckCharger Manages the battery charging process SckButton Manages users button interaction actions SckLed Manages light status for user feedback Commands Library to absracts the core features on to a simple shell interface ReadLight Manages configuration over light ReadSound Manages configuration over sound","title":"Core Microcontroller"},{"location":"Components/Firmware/#dependencies","text":"Adafruit INA219 Library Adafruit MPL3115A2 Library Adafruit SHT31 Library Arduino Json Library Arduino Low Power@ Library ArduinoZero PMUX Report Library DS2482 Library FlashStorage Library FlashStorage MCP342X Library RadioHead Library RTCZero Library SdFat Library SmartSmart Citizen Kit Gases Pro Board Library SparkFun BQ27441 Arduino Library SparkFun MAX3010x Library SPIFlash Library U8g2 Library","title":"Dependencies"},{"location":"Components/Firmware/#wifi-module","text":"Name Functions SckESP Runs all the Wi-Fi networking related functions","title":"WiFi Module"},{"location":"Components/Firmware/#dependencies_1","text":"Time Library ArduinoJson Library RemoteDebug Library RemoteDebug Library RadioHead Library RadioHead Library PubSubclient Library","title":"Dependencies"},{"location":"Components/Firmware/#shared","text":"Name Functions Config Provides a shared configuration between the two MCUs","title":"Shared"},{"location":"Components/Firmware/#data-management","text":"The board is capable of storing the recorded data offline on its internal dedicated flash memory of 8MB and later publish this over Wi-Fi connectivity provided by an Espressif ESP8266. Data is published using MQTT messages to the Smart Citizen Platform. NTP is used for syncing the built-in RTC. For long term offline storage, the board provides a standard microSD socket where card in the orders of GB can be employed. That ensures extended periods of data in the order of decades can be stored.","title":"Data management"},{"location":"Components/Firmware/#configuration","text":"The board firmware is fully customizable without requiring any changes to the core software. That includes enabling or disabling sensors, the sampling frequency of the sensors or the operation mode. There different configuration options: via the Serial Shell available when the board is connected over USB, editing the config.txt file when using a microSD card. Detecting : AlphaDelta 1 A ... found , Enabling AlphaDelta 1 A Detecting : AlphaDelta 1 W ... found , already enabled !!! Detecting : AlphaDelta 2 A ... found , already enabled !!! Detecting : AlphaDelta 2 W ... found , already enabled !!! Detecting : AlphaDelta 3 A ... found , already enabled !!! Detecting : AlphaDelta 3 W ... found , already enabled !!! Detecting : AlphaDelta Temperature ... found , already enabled !!! Detecting : AlphaDelta Humidity ... found , already enabled !!! Detecting : Groove ADC ... nothing ! Detecting : INA219 Bus voltage ... nothing ! Detecting : INA219 Shunt voltage ... nothing ! Detecting : INA219 Current ... nothing ! Detecting : INA219 Load voltage ... nothing ! Detecting : DS18B20 Water temperature ... nothing ! Detecting : Atlas PH ... nothing ! Detecting : Atlas Conductivity ... nothing ! Detecting : Atlas Specific gravity ... nothing ! Detecting : Atlas Dissolved Oxygen ... nothing ! Detecting : Atlas DO Saturation ... nothing ! Detecting : Groove OLED ... nothing !","title":"Configuration"},{"location":"Components/Firmware/#shell","text":"The firmware provides a comprehensive command shell over USB to manage all the kits functionalities for advanced users. Use any Serial console as screen , platformio device monitor , or the serial monitor on the Arduino IDE Example commands: SCK > help SCK > config - wifi \"myWifiName\" \"myPassword\" - token myToken - mode network","title":"Shell"},{"location":"Components/Firmware/#storage","text":"","title":"Storage"},{"location":"Components/Firmware/#configuration-file-configtxt","text":"If this file doesn't exist it is generated by the kit with the factory defaults and after that it can be modified by both the user and the kit. SckBase :: resetConfigFile (); If the modification comes from the kit (sound, platform, etc) it should be saved to the flash and then to the SD. When the file is read from the SD if it is valid and different from the flash version the flash version should be updated. There is a problem in this approach: if the user insert and old scard with an old config without erasing it he can mess an newly configured kit. To solve this there is the possibility of having a first entry in the config file that is called something like user_modified and the user should modify this so the new config is loaded. If this flag is not true the sdcard config would be overwritten with the one in the flash. Warning on Factory Reset This file will be restored to default values in a factory reset event.","title":"Configuration file CONFIG.TXT"},{"location":"Components/Firmware/#readings-file-postcsv","text":"This file is generated and updated by the kit. When a SD is detected this file will be synced with the flash version as the correct one. For this to work we need a fast way to compare the files. We need to test if this is doable in terms of speed. Maybe only do this when it is requested via a command or user input. There should be a way to know if a post has been uploaded to the platform, so when the kit doesn't have a wifi connection it saves the readings and publish them as soon as a network connection is available. Warning on Factory Reset This file will be restored to default values in a factory reset event.","title":"Readings file POST.CSV"},{"location":"Components/Firmware/#debug-log-file-debugcsv","text":"The debug file is generated and updated by the kit, only if the debug mode is enabled on the configuration. When the debug mode is enabled the verbosity level of this file is defined by the outlevel ( normal, verbose or silent ). Warning on Factory Reset This file will be restored to default values in a factory reset event.","title":"Debug log file DEBUG.CSV"},{"location":"Components/Firmware/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/","text":"Introduction Link Sometimes (many times actually), our code won't do what we want it to do and we need to take a look at what it's doing. By using a debugger we will be able to see what is going on inside another program while it executes or even crashes. This is fairly straight forward when you code for a modern day computer, since most IDEs have a proper interface integrated for it. However, debugging a chip like the SAMD21 can sometimes be tricky and here is where it's interesting to use a debugging kit. To keep it simple: our final target is to be able to interact with the SAMD21 (or the chip) while it's executing the program and tell it to pause the execution, give us the value of some variables and then continue. We will release a fairly extensive report with documentation on this process, but for those interested in reading an overview on how to debug, this post can be a short introduction. So, here we go! The first item we need is the Open On-Chip Debugger (OpenOCD) which provides debugging with the assistance of a debug adapter . This adapter is a small hardware module which helps provide the right kind of electrical signaling to the target being debugged. These are required since the debug host, on which OpenOCD runs (i.e. your computer, a Raspberry PI...) won\u2019t usually have native support for such signaling, or the connector needed to hook up to the target. These adapters are sometimes packaged as discrete dongles, which may generically be called hardware interface dongles (and are quite expensive). Some development boards also integrate them directly, which may let the development board connect directly to the debug host over USB (and sometimes also to power it over USB, like the Arduino Genuino Zero ). In the case of the Smart Smart Citizen Kit , we have a SWD Adapter that supports Serial Wire Debug signaling to communicate with the ARM core . In our approach, using a complete open toolchain , OpenOCD is be running on a Raspberry Pi, and communicating with the SCK's SWD through the GPIO pins of the Pi. Finally, to be able to actually see what is going on inside our firmware while it executes , we need something that is able to read and understand the machine code and hand it over to a human understandable interface. This is where GDB kicks in and helps us by: Starting our program, specifying anything that might affect its behavior. Make our program stop on specified conditions. Examine what has happened when our program has stopped. Change things in our program, so we can experiment with correcting the effects of one bug and go on to learn about another. GDB and OpenOCD will be running in a Raspberry Pi hooked up to the SWD interface of the SCK, and we will see what's going on in them from our computer's terminal via SSH. Fairly simple , right? Now, we can make some changes to our code, make GDB flash it to the SCK and keep debugging in a completely open toolchain! Debugger setup using a Raspberry Pi Link First download and copy Raspbian Lite to your SDcard, here are the installation docs . Add wifi configuration Create a file name wpa_supplicant . conf on the / boot partition of the SD card, the content of this file should looks like this: ctrl_interface = DIR =/ var / run / wpa_supplicant GROUP = netdev update_config = 1 network = { ssid = \"wifi_ssid\" psk = \"wifi_password\" } Replacing wifi_ssid and wifi_password with your actual wifi network information. The wpa_supplicant.conf file will be copied to /etc/wpa_supplicant/ directory automatically once the Raspberry Pi is booted up. Enable SSH server. SSH access is disabled as default for security reasons. To enable the SSH server when Raspberry Pi is booted up for the first time: create a file called ssh with no file extension and no contents, and copy it to the / boot partition on the SD card. Find your raspberry on the network In order to find a raspberry pi over the network we can use commands like these: Linux MY_IP_RANGE =$( ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}' ) && nmap -sn $ MY_IP_RANGE && IP =$( arp -na | grep b8 : 27 : eb | grep -Eo ' [ 0 - 9 ] {1,3}\\. [ 0 - 9 ] {1,3}\\. [ 0 - 9 ] {1,3}\\. [ 0 - 9 ] {1,3}' ) && ssh $ IP ; Mac MY_RANGE = $ ( ip addr | grep \"UP\" - A3 | grep '192' - A0 | awk '{print $2}' ) && nmap - sn $ MY_RANGE && arp - na | grep b8 : 27 : eb SSH login without password: If you have never generated a RSA key: ssh - keygen without passphrase Copy the key to the Raspberry: ssh - copy - id - i ~/ . ssh / id_rsa . pub raspi - address Once booted, it will connect to the network. The command above ( MY_IP ... ) finds it and logs into it via SSH. Once you are logged to your raspberry pi and connected to the internet, do a system upgrade : sudo apt - get install rpi - update sudo rpi - update sudo apt - get update && sudo apt - get dist - upgrade Install some dependencies : sudo apt - get install git autoconf libtool make pkg - config libusb - 1 . 0 - 0 libusb - 1 . 0 - 0 - dev telnet sshfs Openocd installation Link Clone openocd repository and compile: git clone git : // git . code . sf . net / p / openocd / code openocd - code cd openocd - code . / bootstrap . / configure --enable-sysfsgpio --enable-bcm2835gpio make sudo make install The list of interfaces that openOCD can use is under: /usr/local/share/openocd/scripts/interface . In order to use the SWD connector that the SCK features, by using Bit Banging , we connect it directly to the Raspberry Pi GPIOs: Running OpenOCD on the raspberry pi Link Once you are logged into the raspberry Pi you need a openOCD config file to start (ej. sck.cfg ) with this content: source [ find interface / raspberrypi2 - native . cfg ] transport select swd set CHIPNAME at91samd21g18 source [ find target / at91samdXX . cfg ] adapter_nsrst_delay 100 adapter_nsrst_assert_width 100 init targets reset halt You can store this file in OpenOCD scripts dir so it will auto find it sudo mv sck . cfg / usr / local / share / openocd / scripts / and then run the OpenOCD server with: sudo openocd - f sck . cfg Then you can connect to OpenOCD, if you want to connect from an external computer, replace 127 . 0 . 0 . 1 with your Raspberry Pi IP address. telnet 127 . 0 . 0 . 1 4444 Example On a arduino zero go to the directory where the *.cfg is and: openocd - f arduino_zero . cfg Open On - Chip Debugger 0 . 10 . 0 Licensed under GNU GPL v2 For bug reports , read http : // openocd . org / doc / doxygen / bugs . html Info : auto - selecting first available session transport \" swd \" . To override use ' transport select <transport> ' . none separate adapter speed : 400 kHz cortex_m reset_config sysresetreq Info : CMSIS - DAP : SWD Supported Info : CMSIS - DAP : Interface Initialised ( SWD ) Info : CMSIS - DAP : FW Version = 02 . 01 . 0157 Info : SWCLK / TCK = 1 SWDIO / TMS = 1 TDI = 1 TDO = 1 nTRST = 0 nRESET = 1 Info : CMSIS - DAP : Interface ready Info : clock speed 400 kHz Info : SWD DPIDR 0 x0bc11477 Info : at91samd21g18 . cpu : hardware has 4 breakpoints , 2 watchpoints Using OpenOCD remotely from other computer Link We need to give the OpenOCD server access to your project files that are remotely stored. To do this you can mount your working directory remotely on the Raspberry Pi via SSH: ssh pi @raspi_address pi $ mkdir working_dir pi $ sshfs user @computer_address : working_path working_dir pi $ cd working_dir pi $ sudo openocd - f sck . cfg Then you can connect to OpenOCD from your computer with: telnet raspi_address 4444 Uploading Arduino original bootloader Link Get the bootloader file here and build it. Connect to OpenOCD server and run: reset halt at91samd bootloader 0 at91samd chip - erase program samd21_sam_ba . bin verify at91samd bootloader 8192 reset run If you don't see any error youre done! Uploading SCK Firmware Link Install platformio, download and build SCK firmware Connect to OpenOCD server and run: reset halt flash write_image firmware . bin 8192 verify_image firmware . bin 8192 reset run reset run GDB Link General description Link The purpose of a debugger such as GDB is to allow you to see what is going on \u201cinside\u201d another program while it executes\u2014or what another program was doing at the moment it crashed. GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act: * Start your program, specifying anything that might affect its behavior. * Make your program stop on specified conditions. * Examine what has happened, when your program has stopped. * Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another. Debugging session with Raspberry Pi as the OpenOCD server Link Once your raspberry pi is setup with above instructions you can just do: ssh pi @RaspberryAddress sudo openocd - f sck . cfg & cd / platformio_project / path arm - none - eabi - gdb . / pioenvs / zeroUSB / firmware . elf ( gdb ) target remote RaspberryAddress : 3333 ( gdb ) monitor reset run If you are using platformio , you need to modify the compiling option to avoid optimisation with -0g message to the compiler. In case you are not using platformio , activate verbose compiling output at Arduino IDE and find your compiled .elf directory. [env:zeroUSB] platform = atmelsam board = zeroUSB framework = arduino build_flags = -Og Now we are all set and ready to go. The debugger is waiting for instructions on the execution, which we detail below. Info Quick handy instructions inside GDB environment 1. (gdb) appears in every line and you don't have to type it each time 2. In case you need to exit GDB, just type in quit , but remember always killing the process before, should you have a target running ( gdb ) kill ( gdb ) quit 3. RET repeats the previous command GDB commands Link All commands in gdb during debugging are detailed in the GDB guide, chapter GDB commands in detail (continue and stepping) An extract of some useful commands are detailed below: Continuing and stepping Link continue [ ignore - count ] Resumes program execution until next breakpoint. [ ignore - count ] argument allows to specify a further number of times to ingore a breakpoint. ( gdb ) continue Continuing . Breakpoint 1 , tick () at src / HOLA . cpp : 9 9 void tick () { step count Continues running your program until control reaches a different source line , only availabe for source lines and functions compiled with debugging information. count is optional and states the number of steps to be performed before stopping, if no breakpoint arrives earlier. next [ count ] Continue to the next source line without going into functions . It has the same functionality as step, but it stays in the same stack frame. count works as in step count . As well, it understands jumps calls as in the end of for loops and return to the beginning of the loop. Info set step - mode on / off sets the behaviour of ( gdb ) when stepping into a function with no debugging information. In the case of step - mode on , it inspects the first line of code of the function, whereas on step - mode off it skips the function completely. finish Continue running until just after function in the selected stack frame returns . until Has the same behaviour as step , but it ignores the jumps between lines due to loops (for, whiles, etc), continuing to the next source code with incremental line number. Breakpoints Link info breakpoints Retrieve information about breakpoints ( gdb ) info breakpoints Num Type Disp Enb ress What 1 breakpoint keep y 0 x00002140 in tick () at src / HOLA . cpp : 9 breakpoint already hit 15 times break Info Use the tbreak command instead of break if you want to stop the program once, and then remove the breakpoint. More breakpoint condition options can be found here you can find watchpoint Set a watchpoint watchpoint to only stop once a variable has a certain value. ( gdb ) watch timer Info Type in info watchpoints to get information about watchpoints. commands Set a list of actions related to the breakpoint: break main . cpp : 50 commands silent printf \" count is %d \\n \" , count cont end delete Delete a breakpoint ( gdb ) delete 1 ( gdb ) info breakpoints No breakpoints or watchpoints . Printing / setting variables and more Link loop Read what is around a certain function ( gdb ) l loop 25 // while ( ! Serial ) { 26 // ; // wait for serial port to connect. Needed for native USB port only 27 // } 28 } 29 30 void loop () { 31 // put your main code here , to run repeatedly : 32 Serial . println ( \" HOLA \" ) ; 33 tick () ; 34 Serial . println ( millis ()) ; print Retrieve value of a specific variable ( gdb ) print timer $ 12 = 2 set Set variable to a certain value ( gdb ) set timer = 0 Target commands (load) Link load filename offset Load it is meant to make filename (an executable) available for debugging on the remote system\u2014by downloading it. load also records the filename symbol table in GDB, like the add-symbol-file command. The file is loaded at whatever address is specified in the executable, also into flash memory. Making changes in the code Link Anytime we make a change in the code, we don't need to reload the debugging session. We can easily do so by: Compile the code: a. Define Shell build in Sublime Text and configure a build sytem with: \"shell_cmd\" : \"cd .. && pio run\" Then, everytime you hit Ctrl+B (Cmd+B) and you use your custom build system, it will automatically use this option. b. Or hit pio run in another terminal located in your project root directory In gdb, load file. This will reload the file defined at the beginning of your debugging session and upload it to the target ( gdb ) load Loading section . text , size 0 x2e50 lma 0 x2000 Loading section . ramfunc , size 0 x60 lma 0 x4e50 Loading section . data , size 0 x110 lma 0 x4eb0 Start address 0 x2910 , load size 12224 Transfer rate : 3 KB / sec , 4074 bytes / write . Keep debugging GDB Console Link TUI Link GDB has a console GUI option available with the command line option --tui In the upper frame you can see the code that's being executed. GDB init file Link From this example dashboard we can generate a custom .gdbinit file for the SCK which will be placed in the HOME directory... (ON GOING) Info Would be interesting to generate a custom option for production validation and one for internal debugging purposes For references about where to locate the .gdbinit and more custom behaviour for gdb in general see here . GDB from Sublime Text Link Setup Platformio project with sublime Text Setup sublimeGDB Reference Link General GDB references and examples Link Debugging with GDB - Book Debugging example from GDB and OpenOCD Arduino zero example Additional notes from Platformio configuration Link How to set other DEBUG FLAGS About project configuration with Platformio init Check here for building an *.ini file with custom build target for debugging and production.","title":"Advanced: Debug the firmware"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#introduction","text":"Sometimes (many times actually), our code won't do what we want it to do and we need to take a look at what it's doing. By using a debugger we will be able to see what is going on inside another program while it executes or even crashes. This is fairly straight forward when you code for a modern day computer, since most IDEs have a proper interface integrated for it. However, debugging a chip like the SAMD21 can sometimes be tricky and here is where it's interesting to use a debugging kit. To keep it simple: our final target is to be able to interact with the SAMD21 (or the chip) while it's executing the program and tell it to pause the execution, give us the value of some variables and then continue. We will release a fairly extensive report with documentation on this process, but for those interested in reading an overview on how to debug, this post can be a short introduction. So, here we go! The first item we need is the Open On-Chip Debugger (OpenOCD) which provides debugging with the assistance of a debug adapter . This adapter is a small hardware module which helps provide the right kind of electrical signaling to the target being debugged. These are required since the debug host, on which OpenOCD runs (i.e. your computer, a Raspberry PI...) won\u2019t usually have native support for such signaling, or the connector needed to hook up to the target. These adapters are sometimes packaged as discrete dongles, which may generically be called hardware interface dongles (and are quite expensive). Some development boards also integrate them directly, which may let the development board connect directly to the debug host over USB (and sometimes also to power it over USB, like the Arduino Genuino Zero ). In the case of the Smart Smart Citizen Kit , we have a SWD Adapter that supports Serial Wire Debug signaling to communicate with the ARM core . In our approach, using a complete open toolchain , OpenOCD is be running on a Raspberry Pi, and communicating with the SCK's SWD through the GPIO pins of the Pi. Finally, to be able to actually see what is going on inside our firmware while it executes , we need something that is able to read and understand the machine code and hand it over to a human understandable interface. This is where GDB kicks in and helps us by: Starting our program, specifying anything that might affect its behavior. Make our program stop on specified conditions. Examine what has happened when our program has stopped. Change things in our program, so we can experiment with correcting the effects of one bug and go on to learn about another. GDB and OpenOCD will be running in a Raspberry Pi hooked up to the SWD interface of the SCK, and we will see what's going on in them from our computer's terminal via SSH. Fairly simple , right? Now, we can make some changes to our code, make GDB flash it to the SCK and keep debugging in a completely open toolchain!","title":"Introduction"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#debugger-setup-using-a-raspberry-pi","text":"First download and copy Raspbian Lite to your SDcard, here are the installation docs . Add wifi configuration Create a file name wpa_supplicant . conf on the / boot partition of the SD card, the content of this file should looks like this: ctrl_interface = DIR =/ var / run / wpa_supplicant GROUP = netdev update_config = 1 network = { ssid = \"wifi_ssid\" psk = \"wifi_password\" } Replacing wifi_ssid and wifi_password with your actual wifi network information. The wpa_supplicant.conf file will be copied to /etc/wpa_supplicant/ directory automatically once the Raspberry Pi is booted up. Enable SSH server. SSH access is disabled as default for security reasons. To enable the SSH server when Raspberry Pi is booted up for the first time: create a file called ssh with no file extension and no contents, and copy it to the / boot partition on the SD card. Find your raspberry on the network In order to find a raspberry pi over the network we can use commands like these: Linux MY_IP_RANGE =$( ip addr | grep 'state UP' -A2 | tail -n1 | awk '{print $2}' ) && nmap -sn $ MY_IP_RANGE && IP =$( arp -na | grep b8 : 27 : eb | grep -Eo ' [ 0 - 9 ] {1,3}\\. [ 0 - 9 ] {1,3}\\. [ 0 - 9 ] {1,3}\\. [ 0 - 9 ] {1,3}' ) && ssh $ IP ; Mac MY_RANGE = $ ( ip addr | grep \"UP\" - A3 | grep '192' - A0 | awk '{print $2}' ) && nmap - sn $ MY_RANGE && arp - na | grep b8 : 27 : eb SSH login without password: If you have never generated a RSA key: ssh - keygen without passphrase Copy the key to the Raspberry: ssh - copy - id - i ~/ . ssh / id_rsa . pub raspi - address Once booted, it will connect to the network. The command above ( MY_IP ... ) finds it and logs into it via SSH. Once you are logged to your raspberry pi and connected to the internet, do a system upgrade : sudo apt - get install rpi - update sudo rpi - update sudo apt - get update && sudo apt - get dist - upgrade Install some dependencies : sudo apt - get install git autoconf libtool make pkg - config libusb - 1 . 0 - 0 libusb - 1 . 0 - 0 - dev telnet sshfs","title":"Debugger setup using a Raspberry Pi"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#openocd-installation","text":"Clone openocd repository and compile: git clone git : // git . code . sf . net / p / openocd / code openocd - code cd openocd - code . / bootstrap . / configure --enable-sysfsgpio --enable-bcm2835gpio make sudo make install The list of interfaces that openOCD can use is under: /usr/local/share/openocd/scripts/interface . In order to use the SWD connector that the SCK features, by using Bit Banging , we connect it directly to the Raspberry Pi GPIOs:","title":"Openocd installation"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#running-openocd-on-the-raspberry-pi","text":"Once you are logged into the raspberry Pi you need a openOCD config file to start (ej. sck.cfg ) with this content: source [ find interface / raspberrypi2 - native . cfg ] transport select swd set CHIPNAME at91samd21g18 source [ find target / at91samdXX . cfg ] adapter_nsrst_delay 100 adapter_nsrst_assert_width 100 init targets reset halt You can store this file in OpenOCD scripts dir so it will auto find it sudo mv sck . cfg / usr / local / share / openocd / scripts / and then run the OpenOCD server with: sudo openocd - f sck . cfg Then you can connect to OpenOCD, if you want to connect from an external computer, replace 127 . 0 . 0 . 1 with your Raspberry Pi IP address. telnet 127 . 0 . 0 . 1 4444 Example On a arduino zero go to the directory where the *.cfg is and: openocd - f arduino_zero . cfg Open On - Chip Debugger 0 . 10 . 0 Licensed under GNU GPL v2 For bug reports , read http : // openocd . org / doc / doxygen / bugs . html Info : auto - selecting first available session transport \" swd \" . To override use ' transport select <transport> ' . none separate adapter speed : 400 kHz cortex_m reset_config sysresetreq Info : CMSIS - DAP : SWD Supported Info : CMSIS - DAP : Interface Initialised ( SWD ) Info : CMSIS - DAP : FW Version = 02 . 01 . 0157 Info : SWCLK / TCK = 1 SWDIO / TMS = 1 TDI = 1 TDO = 1 nTRST = 0 nRESET = 1 Info : CMSIS - DAP : Interface ready Info : clock speed 400 kHz Info : SWD DPIDR 0 x0bc11477 Info : at91samd21g18 . cpu : hardware has 4 breakpoints , 2 watchpoints","title":"Running OpenOCD on the raspberry pi"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#using-openocd-remotely-from-other-computer","text":"We need to give the OpenOCD server access to your project files that are remotely stored. To do this you can mount your working directory remotely on the Raspberry Pi via SSH: ssh pi @raspi_address pi $ mkdir working_dir pi $ sshfs user @computer_address : working_path working_dir pi $ cd working_dir pi $ sudo openocd - f sck . cfg Then you can connect to OpenOCD from your computer with: telnet raspi_address 4444","title":"Using OpenOCD remotely from other computer"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#uploading-arduino-original-bootloader","text":"Get the bootloader file here and build it. Connect to OpenOCD server and run: reset halt at91samd bootloader 0 at91samd chip - erase program samd21_sam_ba . bin verify at91samd bootloader 8192 reset run If you don't see any error youre done!","title":"Uploading Arduino original bootloader"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#uploading-sck-firmware","text":"Install platformio, download and build SCK firmware Connect to OpenOCD server and run: reset halt flash write_image firmware . bin 8192 verify_image firmware . bin 8192 reset run reset run","title":"Uploading SCK Firmware"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#gdb","text":"","title":"GDB"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#general-description","text":"The purpose of a debugger such as GDB is to allow you to see what is going on \u201cinside\u201d another program while it executes\u2014or what another program was doing at the moment it crashed. GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act: * Start your program, specifying anything that might affect its behavior. * Make your program stop on specified conditions. * Examine what has happened, when your program has stopped. * Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.","title":"General description"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#debugging-session-with-raspberry-pi-as-the-openocd-server","text":"Once your raspberry pi is setup with above instructions you can just do: ssh pi @RaspberryAddress sudo openocd - f sck . cfg & cd / platformio_project / path arm - none - eabi - gdb . / pioenvs / zeroUSB / firmware . elf ( gdb ) target remote RaspberryAddress : 3333 ( gdb ) monitor reset run If you are using platformio , you need to modify the compiling option to avoid optimisation with -0g message to the compiler. In case you are not using platformio , activate verbose compiling output at Arduino IDE and find your compiled .elf directory. [env:zeroUSB] platform = atmelsam board = zeroUSB framework = arduino build_flags = -Og Now we are all set and ready to go. The debugger is waiting for instructions on the execution, which we detail below. Info Quick handy instructions inside GDB environment 1. (gdb) appears in every line and you don't have to type it each time 2. In case you need to exit GDB, just type in quit , but remember always killing the process before, should you have a target running ( gdb ) kill ( gdb ) quit 3. RET repeats the previous command","title":"Debugging session with Raspberry Pi as the OpenOCD server"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#gdb-commands","text":"All commands in gdb during debugging are detailed in the GDB guide, chapter GDB commands in detail (continue and stepping) An extract of some useful commands are detailed below:","title":"GDB commands"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#continuing-and-stepping","text":"continue [ ignore - count ] Resumes program execution until next breakpoint. [ ignore - count ] argument allows to specify a further number of times to ingore a breakpoint. ( gdb ) continue Continuing . Breakpoint 1 , tick () at src / HOLA . cpp : 9 9 void tick () { step count Continues running your program until control reaches a different source line , only availabe for source lines and functions compiled with debugging information. count is optional and states the number of steps to be performed before stopping, if no breakpoint arrives earlier. next [ count ] Continue to the next source line without going into functions . It has the same functionality as step, but it stays in the same stack frame. count works as in step count . As well, it understands jumps calls as in the end of for loops and return to the beginning of the loop. Info set step - mode on / off sets the behaviour of ( gdb ) when stepping into a function with no debugging information. In the case of step - mode on , it inspects the first line of code of the function, whereas on step - mode off it skips the function completely. finish Continue running until just after function in the selected stack frame returns . until Has the same behaviour as step , but it ignores the jumps between lines due to loops (for, whiles, etc), continuing to the next source code with incremental line number.","title":"Continuing and stepping"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#breakpoints","text":"info breakpoints Retrieve information about breakpoints ( gdb ) info breakpoints Num Type Disp Enb ress What 1 breakpoint keep y 0 x00002140 in tick () at src / HOLA . cpp : 9 breakpoint already hit 15 times break Info Use the tbreak command instead of break if you want to stop the program once, and then remove the breakpoint. More breakpoint condition options can be found here you can find watchpoint Set a watchpoint watchpoint to only stop once a variable has a certain value. ( gdb ) watch timer Info Type in info watchpoints to get information about watchpoints. commands Set a list of actions related to the breakpoint: break main . cpp : 50 commands silent printf \" count is %d \\n \" , count cont end delete Delete a breakpoint ( gdb ) delete 1 ( gdb ) info breakpoints No breakpoints or watchpoints .","title":"Breakpoints"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#printing-setting-variables-and-more","text":"loop Read what is around a certain function ( gdb ) l loop 25 // while ( ! Serial ) { 26 // ; // wait for serial port to connect. Needed for native USB port only 27 // } 28 } 29 30 void loop () { 31 // put your main code here , to run repeatedly : 32 Serial . println ( \" HOLA \" ) ; 33 tick () ; 34 Serial . println ( millis ()) ; print Retrieve value of a specific variable ( gdb ) print timer $ 12 = 2 set Set variable to a certain value ( gdb ) set timer = 0","title":"Printing / setting variables and more"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#target-commands-load","text":"load filename offset Load it is meant to make filename (an executable) available for debugging on the remote system\u2014by downloading it. load also records the filename symbol table in GDB, like the add-symbol-file command. The file is loaded at whatever address is specified in the executable, also into flash memory.","title":"Target commands (load)"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#making-changes-in-the-code","text":"Anytime we make a change in the code, we don't need to reload the debugging session. We can easily do so by: Compile the code: a. Define Shell build in Sublime Text and configure a build sytem with: \"shell_cmd\" : \"cd .. && pio run\" Then, everytime you hit Ctrl+B (Cmd+B) and you use your custom build system, it will automatically use this option. b. Or hit pio run in another terminal located in your project root directory In gdb, load file. This will reload the file defined at the beginning of your debugging session and upload it to the target ( gdb ) load Loading section . text , size 0 x2e50 lma 0 x2000 Loading section . ramfunc , size 0 x60 lma 0 x4e50 Loading section . data , size 0 x110 lma 0 x4eb0 Start address 0 x2910 , load size 12224 Transfer rate : 3 KB / sec , 4074 bytes / write . Keep debugging","title":"Making changes in the code"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#gdb-console","text":"","title":"GDB Console"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#tui","text":"GDB has a console GUI option available with the command line option --tui In the upper frame you can see the code that's being executed.","title":"TUI"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#gdb-init-file","text":"From this example dashboard we can generate a custom .gdbinit file for the SCK which will be placed in the HOME directory... (ON GOING) Info Would be interesting to generate a custom option for production validation and one for internal debugging purposes For references about where to locate the .gdbinit and more custom behaviour for gdb in general see here .","title":"GDB init file"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#gdb-from-sublime-text","text":"Setup Platformio project with sublime Text Setup sublimeGDB","title":"GDB from Sublime Text"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#reference","text":"","title":"Reference"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#general-gdb-references-and-examples","text":"Debugging with GDB - Book Debugging example from GDB and OpenOCD Arduino zero example","title":"General GDB references and examples"},{"location":"Components/Firmware/guides/Advanced: Debug the firmware/#additional-notes-from-platformio-configuration","text":"How to set other DEBUG FLAGS About project configuration with Platformio init Check here for building an *.ini file with custom build target for debugging and production.","title":"Additional notes from Platformio configuration"},{"location":"Components/Firmware/guides/Edit the Firmware/","text":"The data board of your SmartSmart Citizen Kit is has two two microcontrollers : The main one is an Atmel SAMD21 , this chip is in charge of all the normal tasks like reading the sensors, saving data, interacting with the user, etc. For this chip we need two software components the bootloader and the main firmware. For communications the SCK has an ESP8266 microcontroler with Wifi capabilities , this chip receives instructions from the SAMD21 via serial port and takes care of publishing the collected data through the network. This chip needs a main firmware and a filesystem that stores the web pages for the setup mode server. Development enviroment Link The SmartSmart Citizen Kit Firmware is on our repository on github so you will need git software installed . To build the SmartSmart Citizen Kit firmware you need a linux computer with platformio installed, you don't need the full IDE installation (Atom). You can follow this instructions to install only the console version. For bootloader upload you also need OpenOCD somewhere in your PATH. You can use platformIO provided binary, normally it is located in ~/ . platformio / packages / tool - openocd . Getting the firmware Link To get the firmware just run: git clone --recursive https://github.com/fablabbcn/smartcitizen-kit-20 The bootloader repository is a submodule of the main firmware so you must do a --recursive clone to get it. Info I you download manually (with the clone or download button on github) you will not get the bootloader code, but you can get it from here . SAMD21 bootloader Link If your kit doesn't have the bootloader already flashed (all the kits that we ship come with it) you will need an ATMEL-ICE programmer. This process can also be done with a Raspberry Pi computer and the proper connector and cables, we are preparing the documentation for this process. Connect the Atmel-ICE programmer to the 10 pin SWD connector and to your computer. Power the SCK via USB, you can use any USB charger or even your computer. Open a terminal, go to the folder where you cloned the firmware repository and run: cd smartcitizen-kit-20 ./build.sh boot If you have everything connected click any key to continue, you will see a lot of output when compiling, the led on the SCK should breath in green and you should see an output similar to this: You are ready for the next step, just remember to disconnect the Atmel-ICE programmer and connect the SCK to your computer with a USB cable. SAMD21 firmware Link The bootloader we just flashed allows a very simple way of uploading the SCK firmware based on the UF2 format, when you double-click the reset button of your kit it will expose a MSD interface to your computer and a new drive will popup where you can just drag the compiled firmware file (converted to UF2 format). Build script Link You can use the same script used to flash the bootloader ( build . sh ) that will do everything for you: compile the firmware, convert the binary to UF2 format and upload it to the kit: ./build.sh sam If you haven't already, double-click the reset button of your kit an click any key. If this is your first time building the software, platformio will take a while installing all the needed dependencies, be patient. If there are no errors you should see an output similar to this: The script will leave a copy of the compiled software in UF2 format called SAM_firmware.uf2 you can use this file to reflash your kit without compiling it again. Manual install Link If you want to install the firmware manually (or you had some problem with the build script) just follow this steps: cd sam pio run At the end you should see some output similar to this: then do: cd .. tools/uf2conv.py -o SAM_firmware.uf2 sam/.pioenvs/sck2/firmware.bin you should see: don't worry about the NO DEVICE WAS FLASHED message, we are doing it manually. Now double-click the reset button of your kit open your favorite file browser and drag the file you just created to the SCK-2.0 drive. The kit will reset and run the new firmware. Info Keep in mind that if your computer is not configured to automount new drives you will need to mount your sck manually ( as any other USB drive ). ESP8266 firmware Link Just like the other parts of the process this is also covered by our build . sh script. So you can just do: ./build.sh esp As before, if this is the first time you do it, it will take a while on downloading dependecies and building the firmware. In this case the upload process is different, since the ESP8266 chip is not connected to the USB interface the data must be uploadded through the SAMD21 chip. Our upload script takes care of searching for a SCK on the USB bus, sending a command to the kit so it put's himself in what we call bridge mode (white led) and uploading the firmware. This is the expected output: Info Sometimes the ESP8266 and the uploader software don't get synced and the upload fails. Normally if you try again it will work. ESP8266 filesystem Link This process is very similar to the previous one you just need to add the letters fs , and wait a little longer ;) ./build.sh espfs","title":"Edit the Firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#development-enviroment","text":"The SmartSmart Citizen Kit Firmware is on our repository on github so you will need git software installed . To build the SmartSmart Citizen Kit firmware you need a linux computer with platformio installed, you don't need the full IDE installation (Atom). You can follow this instructions to install only the console version. For bootloader upload you also need OpenOCD somewhere in your PATH. You can use platformIO provided binary, normally it is located in ~/ . platformio / packages / tool - openocd .","title":"Development enviroment"},{"location":"Components/Firmware/guides/Edit the Firmware/#getting-the-firmware","text":"To get the firmware just run: git clone --recursive https://github.com/fablabbcn/smartcitizen-kit-20 The bootloader repository is a submodule of the main firmware so you must do a --recursive clone to get it. Info I you download manually (with the clone or download button on github) you will not get the bootloader code, but you can get it from here .","title":"Getting the firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#samd21-bootloader","text":"If your kit doesn't have the bootloader already flashed (all the kits that we ship come with it) you will need an ATMEL-ICE programmer. This process can also be done with a Raspberry Pi computer and the proper connector and cables, we are preparing the documentation for this process. Connect the Atmel-ICE programmer to the 10 pin SWD connector and to your computer. Power the SCK via USB, you can use any USB charger or even your computer. Open a terminal, go to the folder where you cloned the firmware repository and run: cd smartcitizen-kit-20 ./build.sh boot If you have everything connected click any key to continue, you will see a lot of output when compiling, the led on the SCK should breath in green and you should see an output similar to this: You are ready for the next step, just remember to disconnect the Atmel-ICE programmer and connect the SCK to your computer with a USB cable.","title":"SAMD21 bootloader"},{"location":"Components/Firmware/guides/Edit the Firmware/#samd21-firmware","text":"The bootloader we just flashed allows a very simple way of uploading the SCK firmware based on the UF2 format, when you double-click the reset button of your kit it will expose a MSD interface to your computer and a new drive will popup where you can just drag the compiled firmware file (converted to UF2 format).","title":"SAMD21 firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#build-script","text":"You can use the same script used to flash the bootloader ( build . sh ) that will do everything for you: compile the firmware, convert the binary to UF2 format and upload it to the kit: ./build.sh sam If you haven't already, double-click the reset button of your kit an click any key. If this is your first time building the software, platformio will take a while installing all the needed dependencies, be patient. If there are no errors you should see an output similar to this: The script will leave a copy of the compiled software in UF2 format called SAM_firmware.uf2 you can use this file to reflash your kit without compiling it again.","title":"Build script"},{"location":"Components/Firmware/guides/Edit the Firmware/#manual-install","text":"If you want to install the firmware manually (or you had some problem with the build script) just follow this steps: cd sam pio run At the end you should see some output similar to this: then do: cd .. tools/uf2conv.py -o SAM_firmware.uf2 sam/.pioenvs/sck2/firmware.bin you should see: don't worry about the NO DEVICE WAS FLASHED message, we are doing it manually. Now double-click the reset button of your kit open your favorite file browser and drag the file you just created to the SCK-2.0 drive. The kit will reset and run the new firmware. Info Keep in mind that if your computer is not configured to automount new drives you will need to mount your sck manually ( as any other USB drive ).","title":"Manual install"},{"location":"Components/Firmware/guides/Edit the Firmware/#esp8266-firmware","text":"Just like the other parts of the process this is also covered by our build . sh script. So you can just do: ./build.sh esp As before, if this is the first time you do it, it will take a while on downloading dependecies and building the firmware. In this case the upload process is different, since the ESP8266 chip is not connected to the USB interface the data must be uploadded through the SAMD21 chip. Our upload script takes care of searching for a SCK on the USB bus, sending a command to the kit so it put's himself in what we call bridge mode (white led) and uploading the firmware. This is the expected output: Info Sometimes the ESP8266 and the uploader software don't get synced and the upload fails. Normally if you try again it will work.","title":"ESP8266 firmware"},{"location":"Components/Firmware/guides/Edit the Firmware/#esp8266-filesystem","text":"This process is very similar to the previous one you just need to add the letters fs , and wait a little longer ;) ./build.sh espfs","title":"ESP8266 filesystem"},{"location":"Components/Firmware/guides/Update the firmware/","text":"When new features are developed or bugs are fixed we will release new versions of the SCK firmware. Info If you already configured your kit on the smartcitizen platform you will need the token that the platform gave you during the onboarding process , to recover it from your kit: Click your kit button until the kit is in setup mode , the led should be red. Connecto to the kit with your mobile device as you did during the onboarding process. Write down the token of your kit. After updating the firmware follow this same steps to input the token and wifi credentials, after this your kit will be publishing on the same registered device than before. A note about versions The guide below applies to both, SCK 2.0 and SCK2.1. Updating your kit is very simple Connect your kit with a micro USB cable to your computer. Double click the reset button of your SCK, the SCK led should turn green and a new drive called SCK-20 should appear on your computer file browser. Inside the SCK-20 drive you should see some files, double click the INDEX.HTM file and our github releases page will open in your browser. Download the new firmware called SAM_firmware_XXX.uf2 and save it to your computer. Tip You can backup your current firmware version just saving the file called CURRENT.UF2 . Simply drag the firmware file you downloaded over the SCK-20 drive , your kit led will blink in green and after some seconds it will reset and start with the new version. After the update you just done, you can configure your kit as a new device following the onboarding process or use your previous token as explained before.","title":"Update the firmware"},{"location":"Components/Gas Pro Sensor Board/","text":"Gases Pro Sensor Board Link We are updating We are currently updating the documentation and many of the figures are from V2.0. We will move them shortly to a more updated version. The Gases Sensor Board is a custom, ultra-low noise, high-performance, low power, digital output driver for 3 Alphasense Ltd. Electrochemical Series B Gas Sensors specifically designed for the project from the ground up. Check the source code Sensor measurements Link Measurement Units Sensor Carbon Monoxide ppm Alphasense CO-B4 Nitrogen Dioxide ppb Alphasense NO2-B43F Ozone ppb Alphasense OX-B431 Sensors selection Link The following characteristics have been considered for the sensor choice The driver's board designed includes a temperature and humidity sensor for calibrating the temperature dependence of the sensing subsystem. Same technology as the A4 series but more robust when exposed to outdoor environments 24/7. Designed for fixed site air quality networks which demand longer term reliability. Manufacturers provide the baseline resistance calibration values per sensor allowing corrections to be easily applied. Low power consumption The Alphasense EC Sensors were selected to provide a higher linearity, repeatability and resolution than the SGX MICS MO Gas Sensors found on the Urban Sensor Board. The selection of the sensors was based on the wide variety of literature available on them. Both Penza and EuNetAir Consortium (2014) and Mead et al. (2013) test the NO2A1-A3 against reference instruments, in the laboratory as well as in the field, with well-correlated results. The former concluded that the Data Quality Objective for \"indicative measurements\" (European Parliament and Council of the European Union, 2008) is fulfilled, and the latter report sensitivity in the low ppb region with high linearity. Spinelle et al. tested the Alphasense NO2B4 and O3B4 in a field experiment, with various calibration approaches. Performance evaluation of the same sensors was performed later including a test on a wide range of performance parameters (e.g. response time, calibration function, repeatability, drift, hysteresis effect, and matrix effect) (Spinelle et al. 2017). The experiment found a strong correlation with reference instruments (R 2 > 0.9) and identified some cases with significant hysteresis effect related to humidity. In chamber conditions, the performances of the Alphasense CO-B4 was found to be excellent, with the R 2 values being greater than 0.9 (Castell et al. 2017) (Mead et al. 2013) (Sun et al. 2016). Two field studies reported moderate to excellent R 2 values (0.53--0.97) for the CO-B4 sensor (Castell et al. 2017) (Mead et al. 2013). Finally, some calibration approaches as detailed in Popoola et al. (2016) and Hagan et al. (2018) are used in the post-processing stage as a basis for pollution concentration calculations. Design Link Each of the three drivers for Alphasense Ltd. Series B Sensors is built around the same design. They include a three stage adjustable amplifier design for the working electrode and and another simetrical design for the auxiliary electrode. Both signals are then feed to a high accuracy delta-sigma A/D converter with differential inputs 18 bits of resolution. All the parameters are digitally adjustable via I2C from the Data Board . Each board also include a unique identifier chip allowing the firmware on the Data Board to identify the board and apply the corresponding calibration values and a humidity and temperature sensor. Info Visit the source files section to download the complete schematics. Setup Link The board is connected to the Data Board using the AUX connector. Before, the Alphasense sensors need to be in place and properly registered using the board id. The board will be autodetected by the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image. Validation This board is currently being evaluated under the iScape Project and the results will be public soon! Source files Link Download Check the source code ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf \u21a9 ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf \u21a9 ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf \u21a9","title":"Index"},{"location":"Components/Gas Pro Sensor Board/#gases-pro-sensor-board","text":"We are updating We are currently updating the documentation and many of the figures are from V2.0. We will move them shortly to a more updated version. The Gases Sensor Board is a custom, ultra-low noise, high-performance, low power, digital output driver for 3 Alphasense Ltd. Electrochemical Series B Gas Sensors specifically designed for the project from the ground up. Check the source code","title":"Gases Pro Sensor Board"},{"location":"Components/Gas Pro Sensor Board/#sensor-measurements","text":"Measurement Units Sensor Carbon Monoxide ppm Alphasense CO-B4 Nitrogen Dioxide ppb Alphasense NO2-B43F Ozone ppb Alphasense OX-B431","title":"Sensor measurements"},{"location":"Components/Gas Pro Sensor Board/#sensors-selection","text":"The following characteristics have been considered for the sensor choice The driver's board designed includes a temperature and humidity sensor for calibrating the temperature dependence of the sensing subsystem. Same technology as the A4 series but more robust when exposed to outdoor environments 24/7. Designed for fixed site air quality networks which demand longer term reliability. Manufacturers provide the baseline resistance calibration values per sensor allowing corrections to be easily applied. Low power consumption The Alphasense EC Sensors were selected to provide a higher linearity, repeatability and resolution than the SGX MICS MO Gas Sensors found on the Urban Sensor Board. The selection of the sensors was based on the wide variety of literature available on them. Both Penza and EuNetAir Consortium (2014) and Mead et al. (2013) test the NO2A1-A3 against reference instruments, in the laboratory as well as in the field, with well-correlated results. The former concluded that the Data Quality Objective for \"indicative measurements\" (European Parliament and Council of the European Union, 2008) is fulfilled, and the latter report sensitivity in the low ppb region with high linearity. Spinelle et al. tested the Alphasense NO2B4 and O3B4 in a field experiment, with various calibration approaches. Performance evaluation of the same sensors was performed later including a test on a wide range of performance parameters (e.g. response time, calibration function, repeatability, drift, hysteresis effect, and matrix effect) (Spinelle et al. 2017). The experiment found a strong correlation with reference instruments (R 2 > 0.9) and identified some cases with significant hysteresis effect related to humidity. In chamber conditions, the performances of the Alphasense CO-B4 was found to be excellent, with the R 2 values being greater than 0.9 (Castell et al. 2017) (Mead et al. 2013) (Sun et al. 2016). Two field studies reported moderate to excellent R 2 values (0.53--0.97) for the CO-B4 sensor (Castell et al. 2017) (Mead et al. 2013). Finally, some calibration approaches as detailed in Popoola et al. (2016) and Hagan et al. (2018) are used in the post-processing stage as a basis for pollution concentration calculations.","title":"Sensors selection"},{"location":"Components/Gas Pro Sensor Board/#design","text":"Each of the three drivers for Alphasense Ltd. Series B Sensors is built around the same design. They include a three stage adjustable amplifier design for the working electrode and and another simetrical design for the auxiliary electrode. Both signals are then feed to a high accuracy delta-sigma A/D converter with differential inputs 18 bits of resolution. All the parameters are digitally adjustable via I2C from the Data Board . Each board also include a unique identifier chip allowing the firmware on the Data Board to identify the board and apply the corresponding calibration values and a humidity and temperature sensor. Info Visit the source files section to download the complete schematics.","title":"Design"},{"location":"Components/Gas Pro Sensor Board/#setup","text":"The board is connected to the Data Board using the AUX connector. Before, the Alphasense sensors need to be in place and properly registered using the board id. The board will be autodetected by the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image. Validation This board is currently being evaluated under the iScape Project and the results will be public soon!","title":"Setup"},{"location":"Components/Gas Pro Sensor Board/#source-files","text":"Download Check the source code ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf \u21a9 ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf \u21a9 ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf \u21a9","title":"Source files"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/","text":"Inside the Electrochemical Sensors Link Sensor working principle Link The electrochemical cells used are toxic gas sensors from alphasense that operate in an amperometric mode. That is, they generate a current that is linearly proportional to the fractional volume of the toxic gas in the environment: Image Source: Alphasense Ltd. These electrochemical sensors are comprised of four electrodes: Working electrode Auxiliary electrode Counter electrode Reference electrode The working electrode is where the oxidation (CO, H2S, NO, SO2) or reduction (NO 2 , Cl2) of the toxic gas to be measured takes place. This electrode is exposed to the outside air and directly exposed to all gases in the air including the gas to be measured. This electrode may as well be poisoned if it is exposed to certain gases that either adsorb onto the catalyst (such as acetylene onto CO sensors), or react, creating by-products which inhibit the catalyst (NO 2 or aromatics onto H2S sensors). The auxiliary electrode is an electrode of the same characteristics to those of the working electrode, but it is buried inside an electrolite and, hence, it is not in contact with the target gas. Since it is isolated from external conditions that could affect the working electrode , it serves as a reference to the measurements provided by the latter. The counter electrode balances the reaction of the working electrode \u2013 if the working electrode oxidises the gas, then the counter electrode must reduce some other molecule to generate an equivalent current, in the opposite sense. For example, where carbon monoxide will be oxidised on the working electrode, oxygen will be reduced on the counter electrode. The reference electrode anchors the working electrode potential to ensure that it is always working in the right conditions. It is important that the reference electrode has a stable potential, keeping the working electrode at the right electrochemical potential to maintain a constant sensitivity, good linearity and minimum sensitivity to interfering gases. Therefore, while the sensor response is exposed to the target gas, it creates a current flowing from the working to the counter electrode or viceversa (depending on the oxidative or reductive nature of the target gas). This relationship can be characterised and follows a curve such as: Image source: Alphasense Ltd. When operating in the so called transport limited current plateau the measured current (IL) should be linearly dependent on the concentration or fractional volume of the toxic gas (CT) in the external environment: I_L = k C_T I_L = k C_T where k is a proportionality constant. This constant is provided by the manufacturer as Sensitivity and is explained below. Electronics design considerations A potentiostat circuit is built in order to ensure that the counter electrode is provided with as much current as it needs, also maintaining the working electrode at a fixed potential, irrespective of how hard it is working. Manufacturer data Link The manufacturer provides the calibration data in laboratory conditions for each of the electrochemical cells used. This data is listed below: - Sensor sensitivity : the sensor response in nA per each ppm of target pollutant in nominal conditions - Electrode zero current : the electrode reading in nA to zero air (pure air at 25degC). This is provided for both, working and auxiliary electrodes, in the case of 4-electrode sensors - Sensor response ( t_{90} t_{90} ) - Sensor range The manufacturer suggests using the following equation in order to determine the sensor's corrected reading in the presence of target gas: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) With regards to sensor ranges , the following are available from the manufacture: NO 2 : 20ppm O3 + NO 2 : 20ppm both CO : 1000ppm Finally, toxic gas sensors' sensitivity will drift downwards with time, typically 0.5% to 2% per month , depending on the sensor type, relative humidity and gas concentration/temperature conditions. Reduction vs Oxidation Electrochemical Sensor Link As mentioned above, the counter electrode is meant to balance the reaction of the working electrode. This determines the current direction within the board: whether it goes from the working electrode to the counter electrode or viceversa. Oxidation sensors, such as CO, provoke a positive current out of the working electrode and the larger the amount of CO present, the larger (positive) is this current. Reduction sensors, such as NO 2 , provoke a negative current, i.e: going into the sensor and the larger the amount of NO 2 present, the larger (negative) is this current As an example, this is reflected in the different signs of the sensor sensitivity: NO2-B43F Average Batch Sensitivity: -347nA/ppm CO-B4F Average Batch Sensitivity: 588nA/ppm Although this is in principle directly related with the sensor itself, there are further signal transformations to be taken into account. For instance, the currents seen in the electrodes, if comparing between CO and NO 2 , should be different in sign, however, for both, CO and NO 2 sensors, we see positive currents which grow positively with higher CO and NO 2 concentrations: Hence, the sensor senstivity provided by the manufacturer should be considered in absolute terms ( abs(Sensitvity) abs(Sensitvity) ) for the calculations to yield always positive results in pollutant fractional volumes. Sensor Calibration Link The model described in the following section is based on the findings of 1 . This study uses alphasense's 3-electrode sensors, and here it is further extended to the case of 4-electrode sensors, taking into account the auxiliary electrode. Baseline correction based on temperature Link The mentioned work described the correction method based on temperature using a baseline correction algorithm which is described in 2 . This is summarised below: For each day of gas working electrode readings, and for each point in the time series (i), the minimum value of the working electrode value that is contained within the interval (i- \\delta \\delta < i < i+ \\delta \\delta ) is determined, where \\delta \\delta is an interval ranging from 0 to a day length. The outcome of this procedure is an array where each column is a vector of minimum working electrode values calculated for each \\delta_i \\delta_i value (this is, from now on, baseline_{\\delta_i} baseline_{\\delta_i} ). The correlation between each baseline_{\\delta_i} baseline_{\\delta_i} and the temperature is calculated. Relative humidity is not considered in this study since it's generaly inversely correlated with the temperature. The correlation coefficients for each correlation ( R^2_{\\delta_i} R^2_{\\delta_i} ) are calculated. The maximum R^2 R^2 whith this array is obtained. For the equation at which the maximum R^2_{\\delta_i} R^2_{\\delta_i} is found, the temperature reading is used to calculate the corrected baseline. The corrected baseline is substracted from the actual working electrode reading The final pollutant concentration is calculated based on the corrected working electrode reading and the manufacturer's data. The readings are treated in a day-to-day basis in order to avoid non-stationary temperature trends over several days, but still to account for temperature variations within each day. Finally, a background pollutant concentration is assumed from 3 which is also summarised below for each pollutant. This background concentration is added to the final result. Background concentrations . Source 3 Application on 4-electrode sensors Link This algorithm can be used to correct temperature effects on the working electrode based on the temperature in 4-electrode sensors. The results are discussed below for tests validation campaigns performed within the iScape project. These tests are summarized below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Smart Citizen Stations were deployed in two different sites, with two Smart Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Smart Citizen Station was deployed with two Smart Citizen Kits. The results found with this methodology in the reduction sensors (NO 2 , O3) are significant in a daily basis. Two examples of the variation of the correlation coefficient with respect to the delta used to calculate the baseline are shown below: The algorithm is set to apply the best performing correlation function from either a linear or an exponential fit, basing this decission on the one that yields better correlation coefficient. NO 2 and O3 at high concentrations yield better results with an exponential fit, whilst lower concentrations reflect a linear trend: Furthermore, the study from which this methodology is drawn from states that oxidation sensors do not yield a proper baseline correlation methodology and so is validated. The result is indeed far better correlated with the reference measurement if using the manufacturer's methodology: This methodology reads as follows: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) In the case of NO 2 , the results provided by this baseline correction algorithm yield better results: Both, CO and NO 2 pollutants, using the best method for each calculation, are shown below: Finally, a comparison between the reference measurement results from both methods is detailed below: Manufacturer Method Baseline Method Pollutant RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 >2 / <0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-9 / 0.1 - 0.3 As seen above, the NO 2 correlation with both methods yields significant results for non-corrected signals, whilst the RMSE values are higher in the case of the manufacturer's proposal. Therefore, for this pollutant, the selected methodology will be the baseline method. On the contrary, the CO measurements are highly uncorrelated with the baseline method, whilst the original manufacturer's proposal yields decent results. Finally, the O3 correlation levels are lower than the CO and NO 2 measurements. This is possibly due to the O3 reference measurement equipment used in the Bologna campaing, since it shows an inverse relationship with NO 2 which suggests a biased pollutant calculation in the reference equipment: As well, the results from UCD that are used as a reference for NO 2 , suggest a poor zero/span calibration of the equipment as it yields negative results that could spoil the NO 2 correlation/model errors from those tests: Baseline correction based on auxiliary electrode Link As seen above, the results from applying this methodology to a low concentration, urban environment measurement with 4-electrode sensors yield significantly correlated results in the case of the reductive sensors. It was also seen that oxidation measurements are significantly correlated with the reference measurements while using the manufacturer's suggested method. However, as detailed in the following section, the use of the auxiliary electrode as the source of the correction yields better results due to: The auxiliary electrode is accounting for both, temperature and absolute humidity. The latter could be discarded if the relative humidity is not considered. Since data is treated in a day to day basis, variations of mean temperatures during different days could provoke significant correlations to be found at different timelapses. This provokes gaps in the prediction during night hours that are reduced by the use of the auxiliary electrode. Finally, it is preferrably to use data contained in a single sensor (such as the auxiliary electrode for the EC sensor) rather than including additional sensors in the algorithm. A comparison between the results using this proposed method and the reference measurement from both test campaigns is seen below: Manufacturer Method Baseline Method With Temperature Baseline Method With Auxiliary Electrode Pollutant RMSE / R2 RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 >2 / <0.1 >2 / <0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6-12/0.1-0.4 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-12 / <0.2 4-9 / 0.1 - 0.3 References Link The use of electrochemical sensors for monitoring urban air quality in low-cost, high-density networks - M.I. Mead, O.A.M. Popoola, G.B. Stewart, P. Landshoff, M. Calleja, M. Hayesb, J.J. Baldovi, M.W. McLeod, T.F. Hodgson, J. Dicks, A. Lewis J. Cohen, R. Baron, J.R. Saffell, R.L. Jones \u21a9 Development of a baseline-temperature correction methodology for electrochemical sensors and its implications for long-term stability - Olalekan A.M. Popoola*, Gregor B. Stewart, Mohammed I. Mead, Roderic L. Jones \u21a9 Modelling atmospheric composition in urban street canyons - Vivien Bright, William Bloss and Xiaoming Cai \u21a9 \u21a9","title":"Electrochemical Sensors"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#inside-the-electrochemical-sensors","text":"","title":"Inside the Electrochemical Sensors"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#sensor-working-principle","text":"The electrochemical cells used are toxic gas sensors from alphasense that operate in an amperometric mode. That is, they generate a current that is linearly proportional to the fractional volume of the toxic gas in the environment: Image Source: Alphasense Ltd. These electrochemical sensors are comprised of four electrodes: Working electrode Auxiliary electrode Counter electrode Reference electrode The working electrode is where the oxidation (CO, H2S, NO, SO2) or reduction (NO 2 , Cl2) of the toxic gas to be measured takes place. This electrode is exposed to the outside air and directly exposed to all gases in the air including the gas to be measured. This electrode may as well be poisoned if it is exposed to certain gases that either adsorb onto the catalyst (such as acetylene onto CO sensors), or react, creating by-products which inhibit the catalyst (NO 2 or aromatics onto H2S sensors). The auxiliary electrode is an electrode of the same characteristics to those of the working electrode, but it is buried inside an electrolite and, hence, it is not in contact with the target gas. Since it is isolated from external conditions that could affect the working electrode , it serves as a reference to the measurements provided by the latter. The counter electrode balances the reaction of the working electrode \u2013 if the working electrode oxidises the gas, then the counter electrode must reduce some other molecule to generate an equivalent current, in the opposite sense. For example, where carbon monoxide will be oxidised on the working electrode, oxygen will be reduced on the counter electrode. The reference electrode anchors the working electrode potential to ensure that it is always working in the right conditions. It is important that the reference electrode has a stable potential, keeping the working electrode at the right electrochemical potential to maintain a constant sensitivity, good linearity and minimum sensitivity to interfering gases. Therefore, while the sensor response is exposed to the target gas, it creates a current flowing from the working to the counter electrode or viceversa (depending on the oxidative or reductive nature of the target gas). This relationship can be characterised and follows a curve such as: Image source: Alphasense Ltd. When operating in the so called transport limited current plateau the measured current (IL) should be linearly dependent on the concentration or fractional volume of the toxic gas (CT) in the external environment: I_L = k C_T I_L = k C_T where k is a proportionality constant. This constant is provided by the manufacturer as Sensitivity and is explained below. Electronics design considerations A potentiostat circuit is built in order to ensure that the counter electrode is provided with as much current as it needs, also maintaining the working electrode at a fixed potential, irrespective of how hard it is working.","title":"Sensor working principle"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#manufacturer-data","text":"The manufacturer provides the calibration data in laboratory conditions for each of the electrochemical cells used. This data is listed below: - Sensor sensitivity : the sensor response in nA per each ppm of target pollutant in nominal conditions - Electrode zero current : the electrode reading in nA to zero air (pure air at 25degC). This is provided for both, working and auxiliary electrodes, in the case of 4-electrode sensors - Sensor response ( t_{90} t_{90} ) - Sensor range The manufacturer suggests using the following equation in order to determine the sensor's corrected reading in the presence of target gas: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) With regards to sensor ranges , the following are available from the manufacture: NO 2 : 20ppm O3 + NO 2 : 20ppm both CO : 1000ppm Finally, toxic gas sensors' sensitivity will drift downwards with time, typically 0.5% to 2% per month , depending on the sensor type, relative humidity and gas concentration/temperature conditions.","title":"Manufacturer data"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#reduction-vs-oxidation-electrochemical-sensor","text":"As mentioned above, the counter electrode is meant to balance the reaction of the working electrode. This determines the current direction within the board: whether it goes from the working electrode to the counter electrode or viceversa. Oxidation sensors, such as CO, provoke a positive current out of the working electrode and the larger the amount of CO present, the larger (positive) is this current. Reduction sensors, such as NO 2 , provoke a negative current, i.e: going into the sensor and the larger the amount of NO 2 present, the larger (negative) is this current As an example, this is reflected in the different signs of the sensor sensitivity: NO2-B43F Average Batch Sensitivity: -347nA/ppm CO-B4F Average Batch Sensitivity: 588nA/ppm Although this is in principle directly related with the sensor itself, there are further signal transformations to be taken into account. For instance, the currents seen in the electrodes, if comparing between CO and NO 2 , should be different in sign, however, for both, CO and NO 2 sensors, we see positive currents which grow positively with higher CO and NO 2 concentrations: Hence, the sensor senstivity provided by the manufacturer should be considered in absolute terms ( abs(Sensitvity) abs(Sensitvity) ) for the calculations to yield always positive results in pollutant fractional volumes.","title":"Reduction vs Oxidation Electrochemical Sensor"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#sensor-calibration","text":"The model described in the following section is based on the findings of 1 . This study uses alphasense's 3-electrode sensors, and here it is further extended to the case of 4-electrode sensors, taking into account the auxiliary electrode.","title":"Sensor Calibration"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#baseline-correction-based-on-temperature","text":"The mentioned work described the correction method based on temperature using a baseline correction algorithm which is described in 2 . This is summarised below: For each day of gas working electrode readings, and for each point in the time series (i), the minimum value of the working electrode value that is contained within the interval (i- \\delta \\delta < i < i+ \\delta \\delta ) is determined, where \\delta \\delta is an interval ranging from 0 to a day length. The outcome of this procedure is an array where each column is a vector of minimum working electrode values calculated for each \\delta_i \\delta_i value (this is, from now on, baseline_{\\delta_i} baseline_{\\delta_i} ). The correlation between each baseline_{\\delta_i} baseline_{\\delta_i} and the temperature is calculated. Relative humidity is not considered in this study since it's generaly inversely correlated with the temperature. The correlation coefficients for each correlation ( R^2_{\\delta_i} R^2_{\\delta_i} ) are calculated. The maximum R^2 R^2 whith this array is obtained. For the equation at which the maximum R^2_{\\delta_i} R^2_{\\delta_i} is found, the temperature reading is used to calculate the corrected baseline. The corrected baseline is substracted from the actual working electrode reading The final pollutant concentration is calculated based on the corrected working electrode reading and the manufacturer's data. The readings are treated in a day-to-day basis in order to avoid non-stationary temperature trends over several days, but still to account for temperature variations within each day. Finally, a background pollutant concentration is assumed from 3 which is also summarised below for each pollutant. This background concentration is added to the final result. Background concentrations . Source 3","title":"Baseline correction based on temperature"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#application-on-4-electrode-sensors","text":"This algorithm can be used to correct temperature effects on the working electrode based on the temperature in 4-electrode sensors. The results are discussed below for tests validation campaigns performed within the iScape project. These tests are summarized below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Smart Citizen Stations were deployed in two different sites, with two Smart Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Smart Citizen Station was deployed with two Smart Citizen Kits. The results found with this methodology in the reduction sensors (NO 2 , O3) are significant in a daily basis. Two examples of the variation of the correlation coefficient with respect to the delta used to calculate the baseline are shown below: The algorithm is set to apply the best performing correlation function from either a linear or an exponential fit, basing this decission on the one that yields better correlation coefficient. NO 2 and O3 at high concentrations yield better results with an exponential fit, whilst lower concentrations reflect a linear trend: Furthermore, the study from which this methodology is drawn from states that oxidation sensors do not yield a proper baseline correlation methodology and so is validated. The result is indeed far better correlated with the reference measurement if using the manufacturer's methodology: This methodology reads as follows: Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Where: I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{WE} (nA) = K (nA/mV) V_{WE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) I_{AE} (nA) = K (nA/mV) V_{AE} (mV) Where: * I_{PCBWE} I_{PCBWE} and I_{PCBAE} I_{PCBAE} are the electronic offsets for each electrode * n = {I_{0WE} \\over I_{0AE}} n = {I_{0WE} \\over I_{0AE}} , the ratio between alphasense's zero currents * k is a constant convertion factor ( ~ 6.36 in the case of the SCK Gas Pro Board electronics) In the case of NO 2 , the results provided by this baseline correction algorithm yield better results: Both, CO and NO 2 pollutants, using the best method for each calculation, are shown below: Finally, a comparison between the reference measurement results from both methods is detailed below: Manufacturer Method Baseline Method Pollutant RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 >2 / <0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-9 / 0.1 - 0.3 As seen above, the NO 2 correlation with both methods yields significant results for non-corrected signals, whilst the RMSE values are higher in the case of the manufacturer's proposal. Therefore, for this pollutant, the selected methodology will be the baseline method. On the contrary, the CO measurements are highly uncorrelated with the baseline method, whilst the original manufacturer's proposal yields decent results. Finally, the O3 correlation levels are lower than the CO and NO 2 measurements. This is possibly due to the O3 reference measurement equipment used in the Bologna campaing, since it shows an inverse relationship with NO 2 which suggests a biased pollutant calculation in the reference equipment: As well, the results from UCD that are used as a reference for NO 2 , suggest a poor zero/span calibration of the equipment as it yields negative results that could spoil the NO 2 correlation/model errors from those tests:","title":"Application on 4-electrode sensors"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#baseline-correction-based-on-auxiliary-electrode","text":"As seen above, the results from applying this methodology to a low concentration, urban environment measurement with 4-electrode sensors yield significantly correlated results in the case of the reductive sensors. It was also seen that oxidation measurements are significantly correlated with the reference measurements while using the manufacturer's suggested method. However, as detailed in the following section, the use of the auxiliary electrode as the source of the correction yields better results due to: The auxiliary electrode is accounting for both, temperature and absolute humidity. The latter could be discarded if the relative humidity is not considered. Since data is treated in a day to day basis, variations of mean temperatures during different days could provoke significant correlations to be found at different timelapses. This provokes gaps in the prediction during night hours that are reduced by the use of the auxiliary electrode. Finally, it is preferrably to use data contained in a single sensor (such as the auxiliary electrode for the EC sensor) rather than including additional sensors in the algorithm. A comparison between the results using this proposed method and the reference measurement from both test campaigns is seen below: Manufacturer Method Baseline Method With Temperature Baseline Method With Auxiliary Electrode Pollutant RMSE / R2 RMSE / R2 RMSE / R2 CO (ppm) 0.2-0.3 / 0.3-0.5 >2 / <0.1 >2 / <0.01 NO 2 (ppb) 21-24 / 0.3-0.5 6-12/0.1-0.4 6 - 12 / 0.4 - 0.6 O3 (ppb) 20-40 / 0.1-0.3 4-12 / <0.2 4-9 / 0.1 - 0.3","title":"Baseline correction based on auxiliary electrode"},{"location":"Components/Gas Pro Sensor Board/Electrochemical Sensors/#references","text":"The use of electrochemical sensors for monitoring urban air quality in low-cost, high-density networks - M.I. Mead, O.A.M. Popoola, G.B. Stewart, P. Landshoff, M. Calleja, M. Hayesb, J.J. Baldovi, M.W. McLeod, T.F. Hodgson, J. Dicks, A. Lewis J. Cohen, R. Baron, J.R. Saffell, R.L. Jones \u21a9 Development of a baseline-temperature correction methodology for electrochemical sensors and its implications for long-term stability - Olalekan A.M. Popoola*, Gregor B. Stewart, Mohammed I. Mead, Roderic L. Jones \u21a9 Modelling atmospheric composition in urban street canyons - Vivien Bright, William Bloss and Xiaoming Cai \u21a9 \u21a9","title":"References"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/","text":"Advanced development setup Link How to use it? Link Connect the board The alphaDelta board should be connected to the kit auxiliary groove connector and the tester board to the alphaDelta. In this way the kit will have acces to both boards writing values in tester board and reading them in the sensor board. The tester board should be connected between Electrodes A and W from the slot you want to test. Get the firmware You will need the latest version of SCK 2.0 Firmware. To enable tester board in firmware uncomment # define deltaTest in sckAux.h file compile and upload the firmware. Read the sensors Link read Alphadelta [wichSensor: temperature, humidity, 1A, 2A, 2A, 2W, 3A, 3W] SCK > read alphadelta 1 a AlphaDelta 1 A : 8 . 22 Control digital potentiometers Link control alphadelta 1A set pot [value: 0-100,000] SCK > control alphadelta 1 a set pot 50000 AlphaDelta 1 A : set pot 50000 Setting pot to : 50000 Ohms Actual value : 49803 Ohms Run the tests Link The tester board is enabled as a control command of Alphasense Delta sensors, so it must be called with the prefix control then the name of the sensor alpha (fuzzy match is supported) then the test keyword followed by the slot number we want to test: control alpha test 1 To complete the line we should select one of the two test modes: set followed by a nA value between -1400/+1400. This will instruct the tester board to output that current and verify the readings of the sensor. control alpha test set SCK > control alpha test 1 set 500 AlphaDelta 1 A : test 1 set 500 Setting test current to : 500 Tester Electrode W : 500 Alphadelta 1 W : 78 . 87 Tester Electrode A : 500 Alphadelta 1 A : 78 . 70 Testing finished ! or full that will ouput a csv formated table with the values for both electrodes of the selected slot from -1400 nA to 1400 nA: control alpha test 1 full SCK > control alpha test 1 full AlphaDelta 1 A : test 1 full testW , readW , testA , readA - 1400 , - 220 . 94 , - 1400 , - 220 . 58 - 1399 , - 220 . 92 , - 1399 , - 220 . 52 - 1398 , - 220 . 78 , - 1398 , - 220 . 37 - 1397 , - 220 . 62 , - 1397 , - 220 . 25 - 1396 , - 220 . 48 , - 1396 , - 220 . 09 ... How to run the validation? Link For validating the boards, we propose verifying that: each nA input can only yield a single output in mV in the ADC, at minimum gain (for each electrode). This means that for a test such as: control alpha test 1 full We should obtain an always positively growing value in the readW, readA channels. For this, we have to check that: \\delta[n] = readX[n]-readX[n-1]>0 \\delta[n] = readX[n]-readX[n-1]>0 If we plot all this results we see that they are normally over 0.1 for all the boards, so we use this value as a minimum threshold, instead of zero: \\delta[n] = readX[n]-readX[n-1]>0.1 \\delta[n] = readX[n]-readX[n-1]>0.1 Finally, this test is also valid for too high gains since once the signal is saturated the \\delta \\delta value is 0 (saturates in a flat plateau). .embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }","title":"Advanced setup"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#advanced-development-setup","text":"","title":"Advanced development setup"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#how-to-use-it","text":"Connect the board The alphaDelta board should be connected to the kit auxiliary groove connector and the tester board to the alphaDelta. In this way the kit will have acces to both boards writing values in tester board and reading them in the sensor board. The tester board should be connected between Electrodes A and W from the slot you want to test. Get the firmware You will need the latest version of SCK 2.0 Firmware. To enable tester board in firmware uncomment # define deltaTest in sckAux.h file compile and upload the firmware.","title":"How to use it?"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#read-the-sensors","text":"read Alphadelta [wichSensor: temperature, humidity, 1A, 2A, 2A, 2W, 3A, 3W] SCK > read alphadelta 1 a AlphaDelta 1 A : 8 . 22","title":"Read the sensors"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#control-digital-potentiometers","text":"control alphadelta 1A set pot [value: 0-100,000] SCK > control alphadelta 1 a set pot 50000 AlphaDelta 1 A : set pot 50000 Setting pot to : 50000 Ohms Actual value : 49803 Ohms","title":"Control digital potentiometers"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#run-the-tests","text":"The tester board is enabled as a control command of Alphasense Delta sensors, so it must be called with the prefix control then the name of the sensor alpha (fuzzy match is supported) then the test keyword followed by the slot number we want to test: control alpha test 1 To complete the line we should select one of the two test modes: set followed by a nA value between -1400/+1400. This will instruct the tester board to output that current and verify the readings of the sensor. control alpha test set SCK > control alpha test 1 set 500 AlphaDelta 1 A : test 1 set 500 Setting test current to : 500 Tester Electrode W : 500 Alphadelta 1 W : 78 . 87 Tester Electrode A : 500 Alphadelta 1 A : 78 . 70 Testing finished ! or full that will ouput a csv formated table with the values for both electrodes of the selected slot from -1400 nA to 1400 nA: control alpha test 1 full SCK > control alpha test 1 full AlphaDelta 1 A : test 1 full testW , readW , testA , readA - 1400 , - 220 . 94 , - 1400 , - 220 . 58 - 1399 , - 220 . 92 , - 1399 , - 220 . 52 - 1398 , - 220 . 78 , - 1398 , - 220 . 37 - 1397 , - 220 . 62 , - 1397 , - 220 . 25 - 1396 , - 220 . 48 , - 1396 , - 220 . 09 ...","title":"Run the tests"},{"location":"Components/Gas Pro Sensor Board/guides/Advanced setup/#how-to-run-the-validation","text":"For validating the boards, we propose verifying that: each nA input can only yield a single output in mV in the ADC, at minimum gain (for each electrode). This means that for a test such as: control alpha test 1 full We should obtain an always positively growing value in the readW, readA channels. For this, we have to check that: \\delta[n] = readX[n]-readX[n-1]>0 \\delta[n] = readX[n]-readX[n-1]>0 If we plot all this results we see that they are normally over 0.1 for all the boards, so we use this value as a minimum threshold, instead of zero: \\delta[n] = readX[n]-readX[n-1]>0.1 \\delta[n] = readX[n]-readX[n-1]>0.1 Finally, this test is also valid for too high gains since once the signal is saturated the \\delta \\delta value is 0 (saturates in a flat plateau). .embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }","title":"How to run the validation?"},{"location":"Components/PM Sensor Board/","text":"PM Sensor Board Link The PM Sensor Board is based around Plantower PMS 5003 1 a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. This includes a custom designed PCB with an MCU to provide I2C connectivity with the Data Board. Check the source code Sensor measurements Link Measurement Units Sensor PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM 10 \u00b5g/m3 Plantower PMS5003 Dual System Sensors selection Link The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 am No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power The selection is based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017) . Compliance with the NAAQS (US National Ambient Air Quality Standards) is based on 24-h PM mass concentrations [...] Both of the FEM instruments correlate with the 24-h PM2.5 mass measurements with an R2 > 0.99. The PMS PM2.5 concentrations are also well correlated with the 24-h mass average concentration (R2 > 0.88), which is slightly better than the GRIMM research-grade instrument (R2 1\u20444 0.7.). South Coast Air Quality Management District (SCAQMD) recently published preliminary comparisons of the PM2.5 measurements from three PMS 1003s and two FEMs, with high correlations (R2 > 0.9) over a 2-month period. This study demonstrated that the PMS 1003/3003 correlates well with FRMs, FEMs, and research-grade instrumentation under ambient conditions during a series of cold-air pools and in a wind-tunnel environment. Under ambient conditions, this sensor correlates better with an FRM than other low-cost sensors in similar studies. [...] these sensors are a promising tool for identifying relative increases or decreases in PM concentration, complementing sparsely distributed monitoring stations and for assessing and minimizing exposure to PM (Kelly et al. 2017) . Design Link The PM Sensor Board runs a dedicated ARM M0+ 32-bits, the same as the Data Board to provide a unified hardware architecture. The board includes an higly efficient step up to provide 5V to drive the PM sensors and a disable/enable circuit to turn off the sensor by software. Info Visit the source files section to download the complete schematics. Setup Link The board is connected to the Data Board using the AUX connector. Before, the Plantower PMS sensors need to be connected. The board will autodetect the PMS sensors and present them seamlessly to the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image. Source files Link Download Check the source code PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf \u21a9","title":"Index"},{"location":"Components/PM Sensor Board/#pm-sensor-board","text":"The PM Sensor Board is based around Plantower PMS 5003 1 a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. This includes a custom designed PCB with an MCU to provide I2C connectivity with the Data Board. Check the source code","title":"PM Sensor Board"},{"location":"Components/PM Sensor Board/#sensor-measurements","text":"Measurement Units Sensor PM 1 \u00b5g/m3 Plantower PMS5003 Dual System PM 2.5 \u00b5g/m3 Plantower PMS5003 Dual System PM 10 \u00b5g/m3 Plantower PMS5003 Dual System","title":"Sensor measurements"},{"location":"Components/PM Sensor Board/#sensors-selection","text":"The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 am No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power The selection is based on the academic references selected above. For a complete Low-Cost Sensors Evaluation see ISCAPE D1.5 Summary of air quality sensors and recommendations for application and the subsequent publication (Rai et al. 2017) . Compliance with the NAAQS (US National Ambient Air Quality Standards) is based on 24-h PM mass concentrations [...] Both of the FEM instruments correlate with the 24-h PM2.5 mass measurements with an R2 > 0.99. The PMS PM2.5 concentrations are also well correlated with the 24-h mass average concentration (R2 > 0.88), which is slightly better than the GRIMM research-grade instrument (R2 1\u20444 0.7.). South Coast Air Quality Management District (SCAQMD) recently published preliminary comparisons of the PM2.5 measurements from three PMS 1003s and two FEMs, with high correlations (R2 > 0.9) over a 2-month period. This study demonstrated that the PMS 1003/3003 correlates well with FRMs, FEMs, and research-grade instrumentation under ambient conditions during a series of cold-air pools and in a wind-tunnel environment. Under ambient conditions, this sensor correlates better with an FRM than other low-cost sensors in similar studies. [...] these sensors are a promising tool for identifying relative increases or decreases in PM concentration, complementing sparsely distributed monitoring stations and for assessing and minimizing exposure to PM (Kelly et al. 2017) .","title":"Sensors selection"},{"location":"Components/PM Sensor Board/#design","text":"The PM Sensor Board runs a dedicated ARM M0+ 32-bits, the same as the Data Board to provide a unified hardware architecture. The board includes an higly efficient step up to provide 5V to drive the PM sensors and a disable/enable circuit to turn off the sensor by software. Info Visit the source files section to download the complete schematics.","title":"Design"},{"location":"Components/PM Sensor Board/#setup","text":"The board is connected to the Data Board using the AUX connector. Before, the Plantower PMS sensors need to be connected. The board will autodetect the PMS sensors and present them seamlessly to the main Firmware running on the Data Board. Multiple sensor board can be daisy-chained as seen on the image.","title":"Setup"},{"location":"Components/PM Sensor Board/#source-files","text":"Download Check the source code PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf \u21a9","title":"Source files"},{"location":"Components/PM Sensor Board/Plantower PMS/","text":"Plantower PMS Link Pulse mode correlation Link The purpose of this test is to determine the time needed to obtain representative readings in a one-shot mode. For this, two kits V2.0 are used with several PM Boards and one PMS5003 connected to each of them: KIT1: Named OSCAR + 1xPMS5003 KIT2: Named TEST7 + 1xPMS5003 One of them is set in a continuous operation mode, while the other operates in on/off mode with different on-times. TEST : - 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE - 2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE Results Link 2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE 30min logging with a candle under the sensors. Initial 3min in stabilised conditions: 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE 30min logging with normal ambient air. Initial 3min in stabilised conditions Target errors Link The initial 3min are used to determine target errors on the stabilisation phase. For each dataset, they are below: High PN Average Std Deviation Relative_error_PM 1.0 0.15 0.17 Relative_error_PM 2.5 -0.02 0.16 Relative_error_PM 10.0 -0.10 0.20 Low PN Average Std Deviation Relative_error_PM 1.0 0.07 0.07 Relative_error_PM 2.5 0.01 0.07 Relative_error_PM 10.0 0.04 0.08 Measurement iterations Link The measurement iterations are plotted below, versus the wake up time: Assuming a confidence interval of 95%, the target value for the measurement mean is (\\mu - \\sigma<\\mu<\\mu + \\sigma) (\\mu - \\sigma<\\mu<\\mu + \\sigma) and the values for each period are extracted from the plots above: Target Time Low PN High PN PM 1.0 15s 4s PM 2.5 15s 5s PM 10.0 12s 5s Conclusion Link Although the PMS has a faster response at high PN, the variability and the measurement averages are higher as well. This can also be due to the measurement method uncertainty For low PN, the time required for stabilisation is between 12 and 15s, to achieve a level of 95% confidence with respect to that of stabilised levels The target time should be 15s, although lower values could be considered down to 12s if there are battery concerns PMS Family correlation tests Link Tests were conducted over two weeks in Barcelona in order to compare both, PlanTower PMS7003 and PMS5003. Results are shown before for normal urban environment levels of exposure: Average Level RMSE R2 PM 1.0 13.89 2.34 0.90 PM 2.5 19.40 3.78 0.88 PM 10.0 20.49 0.85 4.43 Power consumption tests Link PMS7003 Link Datasheet (Check the adaptor position) Power consumption Power consumption is around 50mA in average with peaks of 100mA PMS5003 Link Power consumption Power consumption is around 50mA in average with peaks of 94mA","title":"Plantower PMS"},{"location":"Components/PM Sensor Board/Plantower PMS/#plantower-pms","text":"","title":"Plantower PMS"},{"location":"Components/PM Sensor Board/Plantower PMS/#pulse-mode-correlation","text":"The purpose of this test is to determine the time needed to obtain representative readings in a one-shot mode. For this, two kits V2.0 are used with several PM Boards and one PMS5003 connected to each of them: KIT1: Named OSCAR + 1xPMS5003 KIT2: Named TEST7 + 1xPMS5003 One of them is set in a continuous operation mode, while the other operates in on/off mode with different on-times. TEST : - 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE - 2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE","title":"Pulse mode correlation"},{"location":"Components/PM Sensor Board/Plantower PMS/#results","text":"2018-07_INT_PMS5003_ON_OFF_MID_PARTICLE 30min logging with a candle under the sensors. Initial 3min in stabilised conditions: 2018-07_INT_PMS5003_ON_OFF_LOW_PARTICLE 30min logging with normal ambient air. Initial 3min in stabilised conditions","title":"Results"},{"location":"Components/PM Sensor Board/Plantower PMS/#target-errors","text":"The initial 3min are used to determine target errors on the stabilisation phase. For each dataset, they are below: High PN Average Std Deviation Relative_error_PM 1.0 0.15 0.17 Relative_error_PM 2.5 -0.02 0.16 Relative_error_PM 10.0 -0.10 0.20 Low PN Average Std Deviation Relative_error_PM 1.0 0.07 0.07 Relative_error_PM 2.5 0.01 0.07 Relative_error_PM 10.0 0.04 0.08","title":"Target errors"},{"location":"Components/PM Sensor Board/Plantower PMS/#measurement-iterations","text":"The measurement iterations are plotted below, versus the wake up time: Assuming a confidence interval of 95%, the target value for the measurement mean is (\\mu - \\sigma<\\mu<\\mu + \\sigma) (\\mu - \\sigma<\\mu<\\mu + \\sigma) and the values for each period are extracted from the plots above: Target Time Low PN High PN PM 1.0 15s 4s PM 2.5 15s 5s PM 10.0 12s 5s","title":"Measurement iterations"},{"location":"Components/PM Sensor Board/Plantower PMS/#conclusion","text":"Although the PMS has a faster response at high PN, the variability and the measurement averages are higher as well. This can also be due to the measurement method uncertainty For low PN, the time required for stabilisation is between 12 and 15s, to achieve a level of 95% confidence with respect to that of stabilised levels The target time should be 15s, although lower values could be considered down to 12s if there are battery concerns","title":"Conclusion"},{"location":"Components/PM Sensor Board/Plantower PMS/#pms-family-correlation-tests","text":"Tests were conducted over two weeks in Barcelona in order to compare both, PlanTower PMS7003 and PMS5003. Results are shown before for normal urban environment levels of exposure: Average Level RMSE R2 PM 1.0 13.89 2.34 0.90 PM 2.5 19.40 3.78 0.88 PM 10.0 20.49 0.85 4.43","title":"PMS Family correlation tests"},{"location":"Components/PM Sensor Board/Plantower PMS/#power-consumption-tests","text":"","title":"Power consumption tests"},{"location":"Components/PM Sensor Board/Plantower PMS/#pms7003","text":"Datasheet (Check the adaptor position) Power consumption Power consumption is around 50mA in average with peaks of 100mA","title":"PMS7003"},{"location":"Components/PM Sensor Board/Plantower PMS/#pms5003","text":"Power consumption Power consumption is around 50mA in average with peaks of 94mA","title":"PMS5003"},{"location":"Components/Urban Sensor Board/","text":"Urban Sensor Board Link We are updating We are currently updating the documentation and many of the figures are from V2.0. We will move them shortly to a more updated version. What is it? Link The Urban Sensor Board is a solution that contains a selection of low-cost sensors for environmental monitoring. Its main purpose is to serve as a tool for citizen science and awareness activities, and for that reason, metrics such as temperature, pressure, and humidity, as well as noise levels, ambient light, air quality indicators and PM sensors are included. The Urban Sensor Board has undergone several modifications throughout its development, and its current version is V2.1 : An iteration with a different set of sensors was developed as part of the iScape Project and is shown in the image below: Check the source code A major effort has been carried out on this design to improve the accuracy of the data provided. The sensors on the board include: Air Temperature, Relative Humidity, Noise Levels and Spectrum, Ambient Light and Barometric Pressure. The board also features a section especially focused on Air Quality including a Particle Matter Sensor, and, in version V2.1, an eCO2 and TVOC sensor. Previously, in version V2.0, a Carbon Monoxide and a Nitrogen Dioxide sensors was included, but due to the high power consumption and the need of important calibration efforts, these were removed. The sensor density of the board design offers more than ten different environmental metrics at a very low cost and differentiates the design from other existing solutions. The following sections describe in detail each of the sensors available. Board assembly The Urban Sensor Board connect to the Data Board connector named Sensor Board V2.1 Sensors Measurement Units Sensor Air Temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise Level and Spectrum dBA, dBC, dBZ Invensense ICS-434342 Ambient Light Lux Rohm BH1721FVC Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 eCO2 and TVOC ppm/ppb AMS CCS811 Particulate Matter PM1/PM2.5/PM10 \u00b5g/m3 PMS 5003 V2.0 Sensors Measurement Units Sensor Air Temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise Level and Spectrum dBA, dBC, dBZ Invensense ICS-434342 Ambient Light Lux Rohm BH1721FVC Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Carbon Monoxide ppm (Periodic Baseline Calibration Required) SGX MICS-4514 Nitrogen Dioxide ppb (Periodic Baseline Calibration Required) SGX MICS-4514 Particulate Matter PM2.5 (external - power req) \u00b5g/m3 PMS 5003 A word about Metal Oxide Sensors Link Metal Oxide Sensors measure the resistance (R S ) of a sensitive layer after heating it up with a heating element (normally another resistor). However, this reading cannot be considered as an absolute measurement of the target pollutant concentration, since the resistance varies from sensor to sensor, and it's affected by several conditions, such as temperature, humidity and other non-target pollutant affectations. To mitigate this problem, the output of the sensor is normalized using the baseline resistance (R A ): R S is divided by R A . This baseline resistance is the resistance that the sensor sees in clean air, and the cleaner the air is, the higher the resistance is. Unfortunately, since R A varies with the deployment conditions, R A cannot be determined by a one-time calibration; and in the case of the AMS CCS811 included in the SCK V2.1, is maintained on-the-fly in software. This process is known as baseline correction . Previous versions of the SCK (V1.5, V2.0 and others) included the SGX MICS4514, which was meant to measure CO and NO 2 , and a lot of effort was put in V2.0 to improve the driver for the sensor, aiming to reduce power consumption and improve sensor readings. Unfortunately, this didn't match our expectations in terms of data quality and power consumption, and since individual sensor calibration is not feasible in our case (as some scientific publications have suggested), we decided to focus efforts in simpler, more robust and understandable set of sensors. That being said, the SCK V2.1 includes the AMS CCS811 for Air Quality indicative measurements for indoor air quality in the Urban Sensor Board, and the PMS5003 for outdoor PM exposure. More complex outdoor set-ups will be also possible, for instance using the Gas Pro Sensor Board (featuring up to three Alphasense Electrochemical Sensors) 7 8 9 . This board is currently under evaluation and will be available soon. What to expect from Metal Oxide Sensors Link As said above, this type of sensors is not meant for fine pollution monitoring , but is more oriented for air quality indications and trends detection . Our approach is to use them for indicative measurements, and progressively tend towards a more reliable, fine and robust system, once the technology is capable of providing so. While deploying them, since the air quality is expected to vary in a typical environment, the minimum time over which a baseline correction is applied is 24 hours. This means that the sensor output will change with time, until the baseline is roughly stable. Since the sensor monitors the baseline resistance periodically, if a cleaner air is found, the new baseline resistance is used to calculate the sensor readings (although this is only done for future readings). This also means that the SCK should not be interrupted with an ad hoc power cut since this could erase the baseline resistance and the sensor could always yield wrong readings since it never sees clean air . Read more More on the MICS working principle and field validation What are normal values? More on the AMS CCS811, eCO2 and TVOC Noise Level Sensor (V2.0 onwards) Link The noise sensor is based on the INVENSENSE ICS-43432 2 high-performance, low power, digital output, omnidirectional MEMS microphone with a bottom port and I2S interface. The sensors are similar to the one found on some high-end smartphones. It delivers the information directly in a digital format to the MCU where a custom library has been developed to provide noise data in dB scales A, C and Z. The raw FFT is also accessible to support characterization of specific noise frequencies. The sensor has been calibrated specifically for the project on an anechoic chamber using standard microphone calibration procedures. The following characteristics have been considered for the sensor choice High 65 dBA SNR with a \u221226 dB FS Sensitivity Low Sensitivity Tolerance \u00b11 dB Wide Frequency Response from 50Hz to 20kHz High Acoustic Overload Point 116 dB SPL Low Power Info Check the Noise sensor implementation full documentation Sensor integration Relative Humidity and Air Temperature Sensor (V2.0 onwards) Link Relative Humidity and Air Temperature Sensor are provided by a SENSIRION SHT31 3 module. Sensor upgrade Preliminary tests during the project shown a absolute calibration issues affecting the previously selected sensor, the SENSIRION SHT31. Those we updated the sensor to the newest SHT 31 with a PTFE layer for protection obtaining better results. The following characteristics have been considered for the sensor choice Calibrated, linearized sensor signals in digital, I2C format straight to the MCU where data is provided in degrees Celsius and Relative Humidity. Wide measurement range with high resolution. The relative humidity range of 0-100% RH with a 0.03% resolution and a repeatability of 0.1%, together with a temperature operating range from -40 to +125\u00b0C with a temperature resolution of 0.01 \u00baC and a repeatability of 0.1%. No need for calibration and long-term stability. Low power consumption Commonly found in many commercial weather stations as the Davis Vantage Pro. Sensor integration Ambient Light Sensor (V1.5 onwards) Link The Ambient Light Sensors is based around the ROHM BH1721FVC 4 which uses an LDR10 combined with an ADC and the corresponding circuit that allows communicating with the device with the I2C protocol. The following characteristics have been considered for the sensor choice: No need of external ADC or linearization circuits uses the well-known I2C protocol Measures ambient light data in a wide range from 1lx to 65528 lx a repeatability of 15% and a resolution of 8 lx. Possibility to adjust by an I2C command the kind of light that it should measure (visible or infrared). Low power consumption. 50Hz/60Hz (electric network frequency) light rejection. Filtering the interference of most artificial light sources. Sensor integration Barometric Pressure (V2.0 onwards) Link The Barometric Pressure sensor is based around the NXP MPL3115A2 5 is a compact, piezoresistive, absolute pressure sensor with an I2C digital interface. The following characteristics have been considered for the sensor choice: Wide operating range of 20 kPa to 110 kPa. Temperature compensated utilizing an on-chip temperature sensor. No need for an external ADC or linearization circuits. The pressure and temperature data is fed into an internal high-resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C using the well-known I2C protocol Barometric pressure is also processed by the MCU as height above mean sea level (AMSL) helping to determine the location of the device. Low power consumption. Sensor integration External PM Sensor (V2.0 onwards) Link An external connector on the board supports the connection of a Plantower PMS 5003 or PMS 7003 10 . The device is a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. The sensor can be fully enabled or disabled in software to save energy when not in use. The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 um No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power Sensor integration Source files Link Download Check the source code SGX MICS 4514 Technical Datasheet https://sgx.cdistore.com/datasheets/sgx/0278_Datasheet%20MiCS-4514%20rev%2017.pdf \u21a9 INVENSENSE 43432 Technical Datasheet https://www.invensense.com/wp-content/uploads/2015/02/ICS-43432-data-sheet-v1.3.pdf \u21a9 SENSIRION SHT31 Technical Datasheet https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/2_Humidity_Sensors/ \u21a9 ROHM BH1730 Technical Datasheet http://rohmfs.rohm.com/en/products/databook/datasheet/ic/sensor/light/bh1721fvc-e.pdf \u21a9 NXP MPL3115A2 Technical Datasheet http://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf \u21a9 MAXIM 30105 Technical Datasheet https://datasheets.maximintegrated.com/en/ds/MAX30105.pdf \u21a9 ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf \u21a9 ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf \u21a9 ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf \u21a9 PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf \u21a9","title":"Index"},{"location":"Components/Urban Sensor Board/#urban-sensor-board","text":"We are updating We are currently updating the documentation and many of the figures are from V2.0. We will move them shortly to a more updated version.","title":"Urban Sensor Board"},{"location":"Components/Urban Sensor Board/#what-is-it","text":"The Urban Sensor Board is a solution that contains a selection of low-cost sensors for environmental monitoring. Its main purpose is to serve as a tool for citizen science and awareness activities, and for that reason, metrics such as temperature, pressure, and humidity, as well as noise levels, ambient light, air quality indicators and PM sensors are included. The Urban Sensor Board has undergone several modifications throughout its development, and its current version is V2.1 : An iteration with a different set of sensors was developed as part of the iScape Project and is shown in the image below: Check the source code A major effort has been carried out on this design to improve the accuracy of the data provided. The sensors on the board include: Air Temperature, Relative Humidity, Noise Levels and Spectrum, Ambient Light and Barometric Pressure. The board also features a section especially focused on Air Quality including a Particle Matter Sensor, and, in version V2.1, an eCO2 and TVOC sensor. Previously, in version V2.0, a Carbon Monoxide and a Nitrogen Dioxide sensors was included, but due to the high power consumption and the need of important calibration efforts, these were removed. The sensor density of the board design offers more than ten different environmental metrics at a very low cost and differentiates the design from other existing solutions. The following sections describe in detail each of the sensors available. Board assembly The Urban Sensor Board connect to the Data Board connector named Sensor Board V2.1 Sensors Measurement Units Sensor Air Temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise Level and Spectrum dBA, dBC, dBZ Invensense ICS-434342 Ambient Light Lux Rohm BH1721FVC Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 eCO2 and TVOC ppm/ppb AMS CCS811 Particulate Matter PM1/PM2.5/PM10 \u00b5g/m3 PMS 5003 V2.0 Sensors Measurement Units Sensor Air Temperature \u00baC Sensirion SHT-31 Relative Humidity % REL Sensirion SHT-31 Noise Level and Spectrum dBA, dBC, dBZ Invensense ICS-434342 Ambient Light Lux Rohm BH1721FVC Barometric pressure and AMSL Pa and Meters NXP MPL3115A26 Carbon Monoxide ppm (Periodic Baseline Calibration Required) SGX MICS-4514 Nitrogen Dioxide ppb (Periodic Baseline Calibration Required) SGX MICS-4514 Particulate Matter PM2.5 (external - power req) \u00b5g/m3 PMS 5003","title":"What is it?"},{"location":"Components/Urban Sensor Board/#a-word-about-metal-oxide-sensors","text":"Metal Oxide Sensors measure the resistance (R S ) of a sensitive layer after heating it up with a heating element (normally another resistor). However, this reading cannot be considered as an absolute measurement of the target pollutant concentration, since the resistance varies from sensor to sensor, and it's affected by several conditions, such as temperature, humidity and other non-target pollutant affectations. To mitigate this problem, the output of the sensor is normalized using the baseline resistance (R A ): R S is divided by R A . This baseline resistance is the resistance that the sensor sees in clean air, and the cleaner the air is, the higher the resistance is. Unfortunately, since R A varies with the deployment conditions, R A cannot be determined by a one-time calibration; and in the case of the AMS CCS811 included in the SCK V2.1, is maintained on-the-fly in software. This process is known as baseline correction . Previous versions of the SCK (V1.5, V2.0 and others) included the SGX MICS4514, which was meant to measure CO and NO 2 , and a lot of effort was put in V2.0 to improve the driver for the sensor, aiming to reduce power consumption and improve sensor readings. Unfortunately, this didn't match our expectations in terms of data quality and power consumption, and since individual sensor calibration is not feasible in our case (as some scientific publications have suggested), we decided to focus efforts in simpler, more robust and understandable set of sensors. That being said, the SCK V2.1 includes the AMS CCS811 for Air Quality indicative measurements for indoor air quality in the Urban Sensor Board, and the PMS5003 for outdoor PM exposure. More complex outdoor set-ups will be also possible, for instance using the Gas Pro Sensor Board (featuring up to three Alphasense Electrochemical Sensors) 7 8 9 . This board is currently under evaluation and will be available soon.","title":"A word about Metal Oxide Sensors"},{"location":"Components/Urban Sensor Board/#what-to-expect-from-metal-oxide-sensors","text":"As said above, this type of sensors is not meant for fine pollution monitoring , but is more oriented for air quality indications and trends detection . Our approach is to use them for indicative measurements, and progressively tend towards a more reliable, fine and robust system, once the technology is capable of providing so. While deploying them, since the air quality is expected to vary in a typical environment, the minimum time over which a baseline correction is applied is 24 hours. This means that the sensor output will change with time, until the baseline is roughly stable. Since the sensor monitors the baseline resistance periodically, if a cleaner air is found, the new baseline resistance is used to calculate the sensor readings (although this is only done for future readings). This also means that the SCK should not be interrupted with an ad hoc power cut since this could erase the baseline resistance and the sensor could always yield wrong readings since it never sees clean air . Read more More on the MICS working principle and field validation What are normal values? More on the AMS CCS811, eCO2 and TVOC","title":"What to expect from Metal Oxide Sensors"},{"location":"Components/Urban Sensor Board/#noise-level-sensor-v20-onwards","text":"The noise sensor is based on the INVENSENSE ICS-43432 2 high-performance, low power, digital output, omnidirectional MEMS microphone with a bottom port and I2S interface. The sensors are similar to the one found on some high-end smartphones. It delivers the information directly in a digital format to the MCU where a custom library has been developed to provide noise data in dB scales A, C and Z. The raw FFT is also accessible to support characterization of specific noise frequencies. The sensor has been calibrated specifically for the project on an anechoic chamber using standard microphone calibration procedures. The following characteristics have been considered for the sensor choice High 65 dBA SNR with a \u221226 dB FS Sensitivity Low Sensitivity Tolerance \u00b11 dB Wide Frequency Response from 50Hz to 20kHz High Acoustic Overload Point 116 dB SPL Low Power Info Check the Noise sensor implementation full documentation Sensor integration","title":"Noise Level Sensor (V2.0 onwards)"},{"location":"Components/Urban Sensor Board/#relative-humidity-and-air-temperature-sensor-v20-onwards","text":"Relative Humidity and Air Temperature Sensor are provided by a SENSIRION SHT31 3 module. Sensor upgrade Preliminary tests during the project shown a absolute calibration issues affecting the previously selected sensor, the SENSIRION SHT31. Those we updated the sensor to the newest SHT 31 with a PTFE layer for protection obtaining better results. The following characteristics have been considered for the sensor choice Calibrated, linearized sensor signals in digital, I2C format straight to the MCU where data is provided in degrees Celsius and Relative Humidity. Wide measurement range with high resolution. The relative humidity range of 0-100% RH with a 0.03% resolution and a repeatability of 0.1%, together with a temperature operating range from -40 to +125\u00b0C with a temperature resolution of 0.01 \u00baC and a repeatability of 0.1%. No need for calibration and long-term stability. Low power consumption Commonly found in many commercial weather stations as the Davis Vantage Pro. Sensor integration","title":"Relative Humidity and Air Temperature Sensor (V2.0 onwards)"},{"location":"Components/Urban Sensor Board/#ambient-light-sensor-v15-onwards","text":"The Ambient Light Sensors is based around the ROHM BH1721FVC 4 which uses an LDR10 combined with an ADC and the corresponding circuit that allows communicating with the device with the I2C protocol. The following characteristics have been considered for the sensor choice: No need of external ADC or linearization circuits uses the well-known I2C protocol Measures ambient light data in a wide range from 1lx to 65528 lx a repeatability of 15% and a resolution of 8 lx. Possibility to adjust by an I2C command the kind of light that it should measure (visible or infrared). Low power consumption. 50Hz/60Hz (electric network frequency) light rejection. Filtering the interference of most artificial light sources. Sensor integration","title":"Ambient Light Sensor (V1.5 onwards)"},{"location":"Components/Urban Sensor Board/#barometric-pressure-v20-onwards","text":"The Barometric Pressure sensor is based around the NXP MPL3115A2 5 is a compact, piezoresistive, absolute pressure sensor with an I2C digital interface. The following characteristics have been considered for the sensor choice: Wide operating range of 20 kPa to 110 kPa. Temperature compensated utilizing an on-chip temperature sensor. No need for an external ADC or linearization circuits. The pressure and temperature data is fed into an internal high-resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C using the well-known I2C protocol Barometric pressure is also processed by the MCU as height above mean sea level (AMSL) helping to determine the location of the device. Low power consumption. Sensor integration","title":"Barometric Pressure (V2.0 onwards)"},{"location":"Components/Urban Sensor Board/#external-pm-sensor-v20-onwards","text":"An external connector on the board supports the connection of a Plantower PMS 5003 or PMS 7003 10 . The device is a digital particle concentration sensor that uses the Laser Scattering principle to obtain the number of suspended particles in the air. The sensor can be fully enabled or disabled in software to save energy when not in use. The following characteristics have been considered for the sensor choice: Provides PM 2.5 and PM 10 measurements in ug/m\u00b3 Minimal distinguishable particle diameter of 0.3 um No need for external ADC or linearization circuits. The sensor includes an internal MCU capable of dealing with all the light emitting and sensing processing. All the communication is done using the I2C protocol. A dedicated driver has been designed for this. Ultra Low Cost when compared to other commercial solutions with similar performance Low Power Sensor integration","title":"External PM Sensor (V2.0 onwards)"},{"location":"Components/Urban Sensor Board/#source-files","text":"Download Check the source code SGX MICS 4514 Technical Datasheet https://sgx.cdistore.com/datasheets/sgx/0278_Datasheet%20MiCS-4514%20rev%2017.pdf \u21a9 INVENSENSE 43432 Technical Datasheet https://www.invensense.com/wp-content/uploads/2015/02/ICS-43432-data-sheet-v1.3.pdf \u21a9 SENSIRION SHT31 Technical Datasheet https://www.sensirion.com/fileadmin/user_upload/customers/sensirion/Dokumente/2_Humidity_Sensors/ \u21a9 ROHM BH1730 Technical Datasheet http://rohmfs.rohm.com/en/products/databook/datasheet/ic/sensor/light/bh1721fvc-e.pdf \u21a9 NXP MPL3115A2 Technical Datasheet http://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf \u21a9 MAXIM 30105 Technical Datasheet https://datasheets.maximintegrated.com/en/ds/MAX30105.pdf \u21a9 ALPHASENSE NO2-B43F Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/NO 2 B43F.pdf \u21a9 ALPHASENSE OX-B431 Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2017/07/OX-B431.pdf \u21a9 ALPHASENSE CO-B4 B Technical Datasheet http://www.alphasense.com/WEB1213/wp-content/uploads/2015/04/COB41.pdf \u21a9 PLANTOWER PMS5003 Technical Datasheet https://aqicn.org/air/view/sensor/spec/pms5003.pdf \u21a9","title":"Source files"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/","text":"Metal Oxide sensors Link The Smart Citizen Kit has been using metal oxide sensors for air quality metrics for a long time, and we thought that it would be interesting to dedicate a section for them! In this section, we will compile information available for those using the SCK V2.0 (or before) with the SGX MICS 4514 and the SCK V2.1, with the AMS CCS811. Check the links below for more information about the specifics of: CO - NO 2 sensor from V2.0 and before? Click here eCO2 - TVOC sensor from V2.1? Click here","title":"Index"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/#metal-oxide-sensors","text":"The Smart Citizen Kit has been using metal oxide sensors for air quality metrics for a long time, and we thought that it would be interesting to dedicate a section for them! In this section, we will compile information available for those using the SCK V2.0 (or before) with the SGX MICS 4514 and the SCK V2.1, with the AMS CCS811. Check the links below for more information about the specifics of: CO - NO 2 sensor from V2.0 and before? Click here eCO2 - TVOC sensor from V2.1? Click here","title":"Metal Oxide sensors"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/","text":"eCO2 and TVOC sensor Link The AMS CCS811 is a Metal Oxyde Sensor with I2C connectivity which is capable of measuring a range of volatile organic compounds . This sensor was introduced in the SCK2.1, in replacement of the SGX MICS4514 from previous designs. As mentioned in other parts of the documentation, this decission was mainly due to the lower power consumption of the CCS811 and the already implemented reading processing provided by the manufacturer. Measurements Link eCO2 and eTVOC are two related measurements. The first stands for equivalent CO2 , and is an indication of the concentration of CO2 that would cause the same level of radiative forcing as a given type and concentration of greenhouse gas. eCO2 bottomline starts at 400ppm (current background CO2, sadly). On the other hand, eTVOC stands for equivalent total volatile organic compounds and is a measurement of the total amount of any emitted gases coming from toxins and chemicals. They come from a wide range of everyday items including paints and varnishes, wax and cosmetics, cleaning and hobby products, and even cooking. When you have an enclosed space like a home or office, these emitted gases accumulate and pollute our fresh air. Working principle Link As any metal oxyde sensor, the CCS811 measures the resistance of a sensitive layer, exposed to ambient air. This layer is heated up with a heater element (a resistance) up to several hundred \u00baC. The characteristics of the sensitive element vary from sensor to sensor, and with time, depending as well on the exposure to different chemical components and ambient conditions. For this reason an individual sensor charactersition is tricky, and an indicative approach is followed, using an internal processing that monitors the baseline resistance of the sensor (i.e., the resistance of the sensitive layer when exposed to clean air). Sensor considerations Link Sources: Datasheet Baseline Restore Early-Life (Burn-In) Link The CCS811 performance in terms of resistance levels and sensitivities will change during early life. The change in resistance is greatest over the first 48 hours of operation. CCS811 controls the burn-in period allowing eCO2 and eTVOC readings to be used from first power-on after 60 minutes of operation. Conditioning Period (Run-In) Link After early-life (Burn-In) the conditioning or run-in period is the time required to achieve good sensor stability before measuring VOCs after long idle period. The sensor will need to run for 20 minutes, before accurate readings are generated.","title":"CCS811"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/#eco2-and-tvoc-sensor","text":"The AMS CCS811 is a Metal Oxyde Sensor with I2C connectivity which is capable of measuring a range of volatile organic compounds . This sensor was introduced in the SCK2.1, in replacement of the SGX MICS4514 from previous designs. As mentioned in other parts of the documentation, this decission was mainly due to the lower power consumption of the CCS811 and the already implemented reading processing provided by the manufacturer.","title":"eCO2 and TVOC sensor"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/#measurements","text":"eCO2 and eTVOC are two related measurements. The first stands for equivalent CO2 , and is an indication of the concentration of CO2 that would cause the same level of radiative forcing as a given type and concentration of greenhouse gas. eCO2 bottomline starts at 400ppm (current background CO2, sadly). On the other hand, eTVOC stands for equivalent total volatile organic compounds and is a measurement of the total amount of any emitted gases coming from toxins and chemicals. They come from a wide range of everyday items including paints and varnishes, wax and cosmetics, cleaning and hobby products, and even cooking. When you have an enclosed space like a home or office, these emitted gases accumulate and pollute our fresh air.","title":"Measurements"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/#working-principle","text":"As any metal oxyde sensor, the CCS811 measures the resistance of a sensitive layer, exposed to ambient air. This layer is heated up with a heater element (a resistance) up to several hundred \u00baC. The characteristics of the sensitive element vary from sensor to sensor, and with time, depending as well on the exposure to different chemical components and ambient conditions. For this reason an individual sensor charactersition is tricky, and an indicative approach is followed, using an internal processing that monitors the baseline resistance of the sensor (i.e., the resistance of the sensitive layer when exposed to clean air).","title":"Working principle"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/#sensor-considerations","text":"Sources: Datasheet Baseline Restore","title":"Sensor considerations"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/#early-life-burn-in","text":"The CCS811 performance in terms of resistance levels and sensitivities will change during early life. The change in resistance is greatest over the first 48 hours of operation. CCS811 controls the burn-in period allowing eCO2 and eTVOC readings to be used from first power-on after 60 minutes of operation.","title":"Early-Life (Burn-In)"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/CCS811/#conditioning-period-run-in","text":"After early-life (Burn-In) the conditioning or run-in period is the time required to achieve good sensor stability before measuring VOCs after long idle period. The sensor will need to run for 20 minutes, before accurate readings are generated.","title":"Conditioning Period (Run-In)"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/","text":"Inside the MICS Metal Oxide sensors Link The SGX Mics is a Metal Oxyde Resistive sensor capable of reacting to different substances in the atmosphere. In a simplified way, it is comprised of two main elements: A SnO 2 substrate that acts as a sensor element A heater element to keep the substrate in an optimal working area The SnO 2 is a chemically sensitive metal oxide which has interactions with molecules to be detected in the target gas. The reactions that can occur on SnO 2 surface are adsorption and catalytic reactions , which basically mean that the gas molecules can be adsorbed onto the surface or can catalyse reactions (trigger or enhance them). They take place at the so called active sites or grain boundaries, which are areas where the grains that constitute the sensor resistance are in contact with the air (e.g. with metallic contacts). Hence, metal oxide substrate is basically a collection of sites at which different molecules can be absorbed and therefore interact in various manners with the species present in the atmosphere: either through catalytic reaction, surface reaction, grain boundary reaction ( among others ). 2 . The sensor element is typically heated to a few hundred degrees (\u00baC) using a small resistive heater . The regions within the sensor can be described as in Peterson et al. 1 : the surface, which interacts with the gas, the bulk, which is unaffected by it, and the particle boundary, which lies in between these two . The particle boundary is situated at a distance from any material exposed to the atmosphere into the sensor that chemical electrostatic effects can propagate (the so called Debye length), and this is related to the material\u2019s physical properties. At high temperatures, oxygen atoms bond onto the boundary, extracting electrons in the process from the semiconductor\u2019s surface region. The oxygen either then directly reacts with ambient gases, or these gases also bond onto the sensor, which causes more charge carriers to be withdrawn or injected into the surface region. All these effects change the sensor resistance and it is measured accordingly in 1 : In the case of the SGX 4514, the detection of the pollution gases is achieved by measuring the sensing resistance of both sensors. In a generic way, we could characterise the sensor resistance as follows: RED sensor resistance decreases in the presence of CO and hydrocarbons. OX sensor resistance increases in the presence of NO 2 . Finally, the chemical reactions within the resistive element are directly related to temperature and follow an Arrhenius equation type of behaviour. Each sensor's type has a different optimal operation temperature, which is translated into different heating powers for the heater element. Depending on the heating power and transition speeds, different reactions can be facilitated and this can lead to positive effects such as sensor clean up or battery compsuption savings, for example, when heated up in a pulsed profile. On the other hand, it can facilitate sensor poisoning or ageing, which highlights the need of proper sensor characterisation. Sensor Calibration Link The SGX4514 is a low cost sensor originally ment to detect instances or trends of target gas in the atmosphere 4 5 . The applications intended for these sensors are \u2018event sensing\u2018 applications and the level of accuracy required is not necessarily within regulatory standards. Furthermore, these sensors should not be used with safety related issues. However, despite the low cost nature of these sensors, they have been subject of a great deal of research 1 2 3 and have been reported to give considerably good results in field applications. Before delving into the details of sensor calibration, we will try to understand what these sensors are and how they should be handled. Some important definitions are: Sensor baseline resistance : is the resistance that the sensor exhibits when it's not powered Sensor sensitivity : is the resistance variation with variations in the target gas Sensor cross-sensitivity : is the resistance variation with variations of gases other than the target gas Sensor poisoning : an irreversible resistance variation provoked by the reaction of gases other than the target gas Source: Peterson et al. 1 Peterson et al. 1 describes the various types of interactions between atmospheric gases and a MOS sensor surface. In the image above, the leftmost region describes the unpowered behaviour, or base resistance . The three other regions of the diagram describe different processes that actually occur simultaneously to varying degrees. The sensor\u2019s output is the resistance across the whole of the sensor material, which forms a resistor network with contributions from both the bulk and surface regions. The model described in 1 also explains the wide variation in base resistance between individual sensors of the same type, as the random nature of the surface geometry means an equally random network of resistances. This diagram is a two-dimensional representation of a three-dimensional material; in an actual sensor, the sensitive region is spread into the surface with a distance dependent on the grain size and arrangement resulting from the sintering. Each sensor will then have a different resistance in air and how much this baseline resistance changes with the concentration of the target gas will also differ (what we defined above as sensitivity). Therefore to convert from resistance readings to concentration it is necessary to derive a calibration curve for each sensor . This will require measuring the resistances in air and at a number of gas concentrations over the desired range. It is important that the concentrations are in a background of air as Oxygen is needed for the sensor to work correctly. As stated in 2 , the sensor\u2019s response is only partially a function of the amount of gas to which the surface is exposed. Instead, the sensor will have a baseline resistance that is related to the bulk and particle boundary resistance. Because of the random geometry of the granular sensor surface, the baseline resistance will vary between individual sensors. The change in resistance with the change in gas concentration is generally not a linear response. The response can be measured and fitted to a polynomial relationship , with interactions from other metrics such as temperature, humidity and other gases. It has been proved that air flow around the sensor yields better sensor reactivity, and that the usage of PTFE filters also helps reducing cross-sensitivity and sensor poisoning. An important practical consideration with any in situ air quality sensor design is ensuring adequate flow of sampling air through the device. Stale air inside a casing will produce unrepresentative results , and even sensors mounted outside a casing might not get a properly-mixed sample. Source: Peterson et al. 1 Although the deployment of multiple different sensors can compensate for the cross-sensitivity issues in calibration, it cannot eliminate it. MOS sensors can thus be used only in situations where any interfering species can either be measured by other means, or they must be calibrated regularly and used in locations where the background varies in concentration slowly compared with the target gases. As well, the sensor drift over time is an important issue that requires sensor recalibration over time. There are two major factors in the longevity of a sensor\u2019s calibration. The first is the natural degradation of the heater element, which becomes hotter over prolonged use and causes the sensor\u2019s response profile to vary. The second is the effect of slowly-varying interfering gases, which over the course of months shifts the sensor\u2019s baseline. The first problem may have an engineering solution, but the second will involve taking the results of the tests in an artificial atmosphere, identifying the most critical species and either measuring or possibly modelling their likely concentrations during deployments. An analytical approach to counteracting this drift might be \"merging calibrations\", where a sensor is calibrated at the start and end of a four-month campaign, and the coefficients gradually change from one end of the experiment run to the other. Having all this in mind, the sensor calibration we follow is comprised of the following steps: Sensor behaviour characterisation under different temperature profiles Sensor baseline and sensitivity characterisation in controlled conditions Sensor deployment with reference measurements collocation and model calibration The use of deployment campaigns is of utmost importance in order to develop sensor models that are reality proof . With the possibility of collecting the data with the SmartCitizen Platform and the data treatment provided by the Sensor Calibration Framework , we are able to iterate over the different sensor calibration possibilities, ranging from Ordinary Linear Regression or more advanced techniques such as ML models such as LSTMs networks. Field results Link In this section, we will detail some of the MOS related results obtained during the sensor validation campaigns detailed below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Smart Citizen Stations were deployed in two different sites, with two Smart Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Smart Citizen Station was deployed with two Smart Citizen Kits For both results shown below, we used an LSTM with 200 epochs training and the following structure: from keras.models import Sequential from keras.layers import Dense , Activation , LSTM , Dropout model = Sequential () layers = [ 50 , 100 , 1 ] model . add ( LSTM ( layers [ 0 ], return_sequences = True , input_shape = ( train_X . shape [ 1 ], train_X . shape [ 2 ]))) model . add ( Dropout ( 0.2 )) model . add ( LSTM ( layers [ 1 ], return_sequences = False )) model . add ( Dropout ( 0.2 )) model . add ( Dense ( output_dim = layers [ 2 ])) model . add ( Activation ( \"linear\" )) model . compile ( loss = 'mse' , optimizer = 'rmsprop' ) Carbon Monoxide Link The CO model included the following features: CO_{R}^{-1} CO_{R}^{-1} , CO_R^{-2} CO_R^{-2} , Temp Temp and Temperature^2 Temperature^2 . The results can be seen below: Nitrogen Dioxide Link The NO 2 model included the following features: NO~2~_{R} NO~2~_{R} , NO~2~_R^{-2} NO~2~_R^{-2} , Light, Temp Temp and Temperature^2 Temperature^2 . The results can be seen below: Warning This test campaign contains a short amount of data to be used as a training dataset for a LSTM algorithm. Therefore, this is just to considered as an use case example and further tests and data should be carried out to train broader models. Metal Oxide Sensors Implementation Link Heating stage Link The solution present at Urban Sensor Board V2.0 for MICS-4514 sensor's heaters excitation, pretends to make it compatible with a 3.3V global voltage source. The manufacturer reccomend the following circuit topology, with a global supply voltage of 5V. In the datasheet are collected the electrical nominal conditions for that resistors, in order to operate safely with the heater, without damaging it. Besides that, several other possible conditions could also damage early the heater resistors, like the fact of consider a pure PWM signal, with source 5V and subsequent dutty cycle, as excitation. Even if the frequency is relatively high (100kHz), the resistors are forced to operate briefly with 5V, and this accelerates the destruction of this part of the MICS sensor. So its is possible to provide the nominal voltages for heater resistors from a 3.3V source, if we replace the auxiliar resistors (from recomended topology) with corresponding values, to preserve the total power dissipated and current at same normal operating conditions. Even more, we can upgrade the function of the auxiliar resistors adding a capacitor to form a passive RC filter. In the DC or continuous operation, the capacitor is fully charged and the current is limited by the auxiliar resistor. In AC or pulsed operation, the capacitor can be selected to remove this AC component, and feed the heater resistor with a nearly constant voltage or at least with small variations (<1%). The source for the PWM signal must be buffered, because the resistive load of the system demands currents avobe the SAMD21 can supply. For this purpose, the solution selected is to use a digital hex-inverter buffer, which can drive up to 32mA with each output pin, wich we can paralelize to operate under propper safety factor for the buffer. Simulations Link The first simulations and given values leads to the selection of the RC components values if we set a PWM frequency around 40 kHz. To evaluate the R part of the filter, is needed to take into account the output resistance of the hex-inverter buffer. Prototypes Link We build the circuit into a protoboard, with several IC HEX-INV manufacturers, based on the following schematic: The measures are sumarized in the following table, in which we compare four pre-selected devices, which can fit in our application for size an price considerations. Four cases with paralellized inverters, for each device were performed: pasive load 70R test with DC input, and three tests with 10R+Rheater load at DC input, 60% dutty cycle and 30% dutty cycle. The 74LCX04FT(AE) was selected because it has the lowest LOW output level (0.45V,0.22V), which is considered here as the quality (or close to ideal) of the square wave input source. Final implementation Link The solution implemented in the PCB, has a constant auxilar R (10R+Rout_buff), and constant C (47uF), and also operates at consatant frequency, then, the output power regulation is based on the PWM's dutty cycle. The following circuit represent the implemented schematic. Operation Link First of all, is needed to know the real implemented Rheater of each sensor (which may vary among devices and time), and can be estimated by measuring the V_heater_* at 100% dutty cycle, then: Where Rint_buff can be aproximated with 4 Ohm resistor. The desired_reference_voltage is function of the desired_power_Rheater and dutty cycle. If we set 80mW we can use the value of the Rheater to obtain desired_reference_voltage through tis formula: (Take into account this resistor has a drift over time, therefore is recomended to take periodic measurements of the value of Rheater itself, and check the output power reachability). With selected parameters, after 2ms of PWM operation, the RC reaches the permanent, and then is recomended to take measurements of V_HEATER_ . The loop can be closed to determine the dutty cycle as function of the difference (desired_reference_voltage \u2013 V_HEATER_ (averaged)). Is recomended to average several samples to remove the AC part of the signal. The measured DC signal has a noise of \u00b120mV peak to peak (with triangular distribution). The sign of the PWM signal is inverted due to the action of the inverter, then, a desired x% dutty is obtained as 100%-x%. As initial PWM aproximation to begin to converge close to the regulated dutty cycle can be obtained through this simplification: References Link Practical Use of Metal Oxide Semiconductor Gas Sensors for Measuring Nitrogen Dioxide and Ozone in Urban Environments \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Modelling Of Water Adsorption On SnO 2 Surface \u21a9 \u21a9 \u21a9 MICS-4514 Datasheet \u21a9 Frequently-Asked-Questions-for-MiCS-Gas-Sensors \u21a9 SGX Metal Oxide Gas Sensors - How to use and how they perform \u21a9 Sensors 2017, 17, 1653 \u21a9","title":"MICS"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#inside-the-mics-metal-oxide-sensors","text":"The SGX Mics is a Metal Oxyde Resistive sensor capable of reacting to different substances in the atmosphere. In a simplified way, it is comprised of two main elements: A SnO 2 substrate that acts as a sensor element A heater element to keep the substrate in an optimal working area The SnO 2 is a chemically sensitive metal oxide which has interactions with molecules to be detected in the target gas. The reactions that can occur on SnO 2 surface are adsorption and catalytic reactions , which basically mean that the gas molecules can be adsorbed onto the surface or can catalyse reactions (trigger or enhance them). They take place at the so called active sites or grain boundaries, which are areas where the grains that constitute the sensor resistance are in contact with the air (e.g. with metallic contacts). Hence, metal oxide substrate is basically a collection of sites at which different molecules can be absorbed and therefore interact in various manners with the species present in the atmosphere: either through catalytic reaction, surface reaction, grain boundary reaction ( among others ). 2 . The sensor element is typically heated to a few hundred degrees (\u00baC) using a small resistive heater . The regions within the sensor can be described as in Peterson et al. 1 : the surface, which interacts with the gas, the bulk, which is unaffected by it, and the particle boundary, which lies in between these two . The particle boundary is situated at a distance from any material exposed to the atmosphere into the sensor that chemical electrostatic effects can propagate (the so called Debye length), and this is related to the material\u2019s physical properties. At high temperatures, oxygen atoms bond onto the boundary, extracting electrons in the process from the semiconductor\u2019s surface region. The oxygen either then directly reacts with ambient gases, or these gases also bond onto the sensor, which causes more charge carriers to be withdrawn or injected into the surface region. All these effects change the sensor resistance and it is measured accordingly in 1 : In the case of the SGX 4514, the detection of the pollution gases is achieved by measuring the sensing resistance of both sensors. In a generic way, we could characterise the sensor resistance as follows: RED sensor resistance decreases in the presence of CO and hydrocarbons. OX sensor resistance increases in the presence of NO 2 . Finally, the chemical reactions within the resistive element are directly related to temperature and follow an Arrhenius equation type of behaviour. Each sensor's type has a different optimal operation temperature, which is translated into different heating powers for the heater element. Depending on the heating power and transition speeds, different reactions can be facilitated and this can lead to positive effects such as sensor clean up or battery compsuption savings, for example, when heated up in a pulsed profile. On the other hand, it can facilitate sensor poisoning or ageing, which highlights the need of proper sensor characterisation.","title":"Inside the MICS Metal Oxide sensors"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#sensor-calibration","text":"The SGX4514 is a low cost sensor originally ment to detect instances or trends of target gas in the atmosphere 4 5 . The applications intended for these sensors are \u2018event sensing\u2018 applications and the level of accuracy required is not necessarily within regulatory standards. Furthermore, these sensors should not be used with safety related issues. However, despite the low cost nature of these sensors, they have been subject of a great deal of research 1 2 3 and have been reported to give considerably good results in field applications. Before delving into the details of sensor calibration, we will try to understand what these sensors are and how they should be handled. Some important definitions are: Sensor baseline resistance : is the resistance that the sensor exhibits when it's not powered Sensor sensitivity : is the resistance variation with variations in the target gas Sensor cross-sensitivity : is the resistance variation with variations of gases other than the target gas Sensor poisoning : an irreversible resistance variation provoked by the reaction of gases other than the target gas Source: Peterson et al. 1 Peterson et al. 1 describes the various types of interactions between atmospheric gases and a MOS sensor surface. In the image above, the leftmost region describes the unpowered behaviour, or base resistance . The three other regions of the diagram describe different processes that actually occur simultaneously to varying degrees. The sensor\u2019s output is the resistance across the whole of the sensor material, which forms a resistor network with contributions from both the bulk and surface regions. The model described in 1 also explains the wide variation in base resistance between individual sensors of the same type, as the random nature of the surface geometry means an equally random network of resistances. This diagram is a two-dimensional representation of a three-dimensional material; in an actual sensor, the sensitive region is spread into the surface with a distance dependent on the grain size and arrangement resulting from the sintering. Each sensor will then have a different resistance in air and how much this baseline resistance changes with the concentration of the target gas will also differ (what we defined above as sensitivity). Therefore to convert from resistance readings to concentration it is necessary to derive a calibration curve for each sensor . This will require measuring the resistances in air and at a number of gas concentrations over the desired range. It is important that the concentrations are in a background of air as Oxygen is needed for the sensor to work correctly. As stated in 2 , the sensor\u2019s response is only partially a function of the amount of gas to which the surface is exposed. Instead, the sensor will have a baseline resistance that is related to the bulk and particle boundary resistance. Because of the random geometry of the granular sensor surface, the baseline resistance will vary between individual sensors. The change in resistance with the change in gas concentration is generally not a linear response. The response can be measured and fitted to a polynomial relationship , with interactions from other metrics such as temperature, humidity and other gases. It has been proved that air flow around the sensor yields better sensor reactivity, and that the usage of PTFE filters also helps reducing cross-sensitivity and sensor poisoning. An important practical consideration with any in situ air quality sensor design is ensuring adequate flow of sampling air through the device. Stale air inside a casing will produce unrepresentative results , and even sensors mounted outside a casing might not get a properly-mixed sample. Source: Peterson et al. 1 Although the deployment of multiple different sensors can compensate for the cross-sensitivity issues in calibration, it cannot eliminate it. MOS sensors can thus be used only in situations where any interfering species can either be measured by other means, or they must be calibrated regularly and used in locations where the background varies in concentration slowly compared with the target gases. As well, the sensor drift over time is an important issue that requires sensor recalibration over time. There are two major factors in the longevity of a sensor\u2019s calibration. The first is the natural degradation of the heater element, which becomes hotter over prolonged use and causes the sensor\u2019s response profile to vary. The second is the effect of slowly-varying interfering gases, which over the course of months shifts the sensor\u2019s baseline. The first problem may have an engineering solution, but the second will involve taking the results of the tests in an artificial atmosphere, identifying the most critical species and either measuring or possibly modelling their likely concentrations during deployments. An analytical approach to counteracting this drift might be \"merging calibrations\", where a sensor is calibrated at the start and end of a four-month campaign, and the coefficients gradually change from one end of the experiment run to the other. Having all this in mind, the sensor calibration we follow is comprised of the following steps: Sensor behaviour characterisation under different temperature profiles Sensor baseline and sensitivity characterisation in controlled conditions Sensor deployment with reference measurements collocation and model calibration The use of deployment campaigns is of utmost importance in order to develop sensor models that are reality proof . With the possibility of collecting the data with the SmartCitizen Platform and the data treatment provided by the Sensor Calibration Framework , we are able to iterate over the different sensor calibration possibilities, ranging from Ordinary Linear Regression or more advanced techniques such as ML models such as LSTMs networks.","title":"Sensor Calibration"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#field-results","text":"In this section, we will detail some of the MOS related results obtained during the sensor validation campaigns detailed below: University of Bologna : data collected from 23/January to 13/February. The measured pollutants with reference equipments were CO, NO 2 , NO, NOx and O3. Two prototype Smart Citizen Stations were deployed in two different sites, with two Smart Citizen Kits. University College Dublin : data collected from 27/March to 17/April. The measured pollutants with reference equipments were NO, NO 2 and NOX. One prototype Smart Citizen Station was deployed with two Smart Citizen Kits For both results shown below, we used an LSTM with 200 epochs training and the following structure: from keras.models import Sequential from keras.layers import Dense , Activation , LSTM , Dropout model = Sequential () layers = [ 50 , 100 , 1 ] model . add ( LSTM ( layers [ 0 ], return_sequences = True , input_shape = ( train_X . shape [ 1 ], train_X . shape [ 2 ]))) model . add ( Dropout ( 0.2 )) model . add ( LSTM ( layers [ 1 ], return_sequences = False )) model . add ( Dropout ( 0.2 )) model . add ( Dense ( output_dim = layers [ 2 ])) model . add ( Activation ( \"linear\" )) model . compile ( loss = 'mse' , optimizer = 'rmsprop' )","title":"Field results"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#carbon-monoxide","text":"The CO model included the following features: CO_{R}^{-1} CO_{R}^{-1} , CO_R^{-2} CO_R^{-2} , Temp Temp and Temperature^2 Temperature^2 . The results can be seen below:","title":"Carbon Monoxide"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#nitrogen-dioxide","text":"The NO 2 model included the following features: NO~2~_{R} NO~2~_{R} , NO~2~_R^{-2} NO~2~_R^{-2} , Light, Temp Temp and Temperature^2 Temperature^2 . The results can be seen below: Warning This test campaign contains a short amount of data to be used as a training dataset for a LSTM algorithm. Therefore, this is just to considered as an use case example and further tests and data should be carried out to train broader models.","title":"Nitrogen Dioxide"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#metal-oxide-sensors-implementation","text":"","title":"Metal Oxide Sensors Implementation"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#heating-stage","text":"The solution present at Urban Sensor Board V2.0 for MICS-4514 sensor's heaters excitation, pretends to make it compatible with a 3.3V global voltage source. The manufacturer reccomend the following circuit topology, with a global supply voltage of 5V. In the datasheet are collected the electrical nominal conditions for that resistors, in order to operate safely with the heater, without damaging it. Besides that, several other possible conditions could also damage early the heater resistors, like the fact of consider a pure PWM signal, with source 5V and subsequent dutty cycle, as excitation. Even if the frequency is relatively high (100kHz), the resistors are forced to operate briefly with 5V, and this accelerates the destruction of this part of the MICS sensor. So its is possible to provide the nominal voltages for heater resistors from a 3.3V source, if we replace the auxiliar resistors (from recomended topology) with corresponding values, to preserve the total power dissipated and current at same normal operating conditions. Even more, we can upgrade the function of the auxiliar resistors adding a capacitor to form a passive RC filter. In the DC or continuous operation, the capacitor is fully charged and the current is limited by the auxiliar resistor. In AC or pulsed operation, the capacitor can be selected to remove this AC component, and feed the heater resistor with a nearly constant voltage or at least with small variations (<1%). The source for the PWM signal must be buffered, because the resistive load of the system demands currents avobe the SAMD21 can supply. For this purpose, the solution selected is to use a digital hex-inverter buffer, which can drive up to 32mA with each output pin, wich we can paralelize to operate under propper safety factor for the buffer.","title":"Heating stage"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#simulations","text":"The first simulations and given values leads to the selection of the RC components values if we set a PWM frequency around 40 kHz. To evaluate the R part of the filter, is needed to take into account the output resistance of the hex-inverter buffer.","title":"Simulations"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#prototypes","text":"We build the circuit into a protoboard, with several IC HEX-INV manufacturers, based on the following schematic: The measures are sumarized in the following table, in which we compare four pre-selected devices, which can fit in our application for size an price considerations. Four cases with paralellized inverters, for each device were performed: pasive load 70R test with DC input, and three tests with 10R+Rheater load at DC input, 60% dutty cycle and 30% dutty cycle. The 74LCX04FT(AE) was selected because it has the lowest LOW output level (0.45V,0.22V), which is considered here as the quality (or close to ideal) of the square wave input source.","title":"Prototypes"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#final-implementation","text":"The solution implemented in the PCB, has a constant auxilar R (10R+Rout_buff), and constant C (47uF), and also operates at consatant frequency, then, the output power regulation is based on the PWM's dutty cycle. The following circuit represent the implemented schematic.","title":"Final implementation"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#operation","text":"First of all, is needed to know the real implemented Rheater of each sensor (which may vary among devices and time), and can be estimated by measuring the V_heater_* at 100% dutty cycle, then: Where Rint_buff can be aproximated with 4 Ohm resistor. The desired_reference_voltage is function of the desired_power_Rheater and dutty cycle. If we set 80mW we can use the value of the Rheater to obtain desired_reference_voltage through tis formula: (Take into account this resistor has a drift over time, therefore is recomended to take periodic measurements of the value of Rheater itself, and check the output power reachability). With selected parameters, after 2ms of PWM operation, the RC reaches the permanent, and then is recomended to take measurements of V_HEATER_ . The loop can be closed to determine the dutty cycle as function of the difference (desired_reference_voltage \u2013 V_HEATER_ (averaged)). Is recomended to average several samples to remove the AC part of the signal. The measured DC signal has a noise of \u00b120mV peak to peak (with triangular distribution). The sign of the PWM signal is inverted due to the action of the inverter, then, a desired x% dutty is obtained as 100%-x%. As initial PWM aproximation to begin to converge close to the regulated dutty cycle can be obtained through this simplification:","title":"Operation"},{"location":"Components/Urban Sensor Board/Metal Oxide Sensor/MICS/#references","text":"Practical Use of Metal Oxide Semiconductor Gas Sensors for Measuring Nitrogen Dioxide and Ozone in Urban Environments \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 Modelling Of Water Adsorption On SnO 2 Surface \u21a9 \u21a9 \u21a9 MICS-4514 Datasheet \u21a9 Frequently-Asked-Questions-for-MiCS-Gas-Sensors \u21a9 SGX Metal Oxide Gas Sensors - How to use and how they perform \u21a9 Sensors 2017, 17, 1653 \u21a9","title":"References"},{"location":"Components/Urban Sensor Board/Noise Sensor/","text":"Introduction to Noise Sensor Design Link Basics of MEMs I2S Microphone Link The new Urban Sensor Board SCK 2.0 comes with a digital MEMs I2S microphone . There is a wide range of possibilities in the market, and our pick was the INVENSENSE (now TDK) ICS43432 : a tiny digital MEMs microphone with I2S output. There is an extensive documentation at TDK's website coming from the former and we would recommend to review the nicely put documents for those interested in the topic. Image credit: Invensense ICS43432 To begin with, we'll talk about the microphone itself. The MEMs microphone comes with a transducer element which converts the sound pressure into electric signals. The sound pressure reaches the transducer through a hole drilled in the package and the transducer's signal is sent to an ADC which provides with a signal which can be pulse density modulated (PDM) or in I2S format. Since the ADC is already in the microphone, we have an all-digital audio capture path to the processor and it\u2019s less likely to pick up interferences from other RF, such as the WiFi, for example. The I2S has the advantage of a decimated output, and since the SAMD21 has an I2S port, this allows us to connect it directly to the microcontroller with no CODEC needed to decode the audio data. Additionally, there is a bandpass filter, which eliminates DC and low frequency components (i.e. at fs = 48kHz, the filter has -3dB corner at 3,7Hz) and high frequencies at 0,5\u00b7fs (-3dB cutoff). Both specifications are important to consider when analysing the data and discarding unusable frequencies. The microphone acoustic response has to be considered as well, with subsequent equalisation in the data treatment in order. Image credit: ICS43432 Datasheet - TDK Invensense I2S Protocol Link The I2S protocol ( Inter-IC-Sound ) is a serial bus interface which consists of: a bit clock line or Serial Clock ( SCK ), a word clock line or Word Select ( WS ) and a multiplexed Serial Data line ( SD ). The SD is transmitted in two\u2019s complement with MSB first, with a 24-bit word length in the microphone we picked. The WS is used to indicate which channel is being transmitted (left or right). In the case of the ICS43432, there is an additional pin which corresponds with the L/R, allowing to use the left or right channel to output the signal and the use of stereo configurations. When set to left, the data follows WS\u2019s falling edge and when set to right, the WS\u2019s rising edge. For the SAMD21 processor, there is a well developed I2S library that will take control of this configuration. Image credit: I2S bus specification - Philips Semiconductors Also, we would like to highlight that the SD line of the I2S protocol is quite delicate at high frequencies and it is largely affected by noise in the path the line follows. If you want to try this at home (for example with an Arduino Zero and an I2S microphone like this one , it is important not to use cables in this line and to connect the output pin directly to the board, to avoid having interfaces throughout the SD line. One interesting way to see this is that every time the line sees a medium change, part of it will be reflected and part will be transmitted, just like any other wave. This means that introducing a cable for the line will provoke at least three medium changes and a potential signal quality loss much higher than a direct connection. Apart from this point, the I2S connection is pretty straight forward and it is reasonably easy to retrieve data from the line and start playing around with some FFT analysis. Basics of weighting and human hearing Link The world of acoustics and signal processing for audio analysis is worth several book-length discussions. We might as well try to give an insight of our intentions within this world since we introduced ourselves in it by picking a digital microphone with a quite nice range of capabilities. The very first thing we would like to do is to be able to perform weighting on the buffer we receive from the microphone through the I2S. To explain a bit further on what weighting is, it is no more than a transformation from the real-world sound pressure levels (SPL) travelling around in the air to what our ears can perceive. Just that. Image credit: Human hearing - DSP Guide There are several studies and models of what we actually perceive and depending on them, we have several types of the so called weighting functions . Some of them have been standarised for the purpose of SPL measurement, finding different types like A-weighting (the most common one), B-weighting, D (both in disuse) and others. In the frequency domain, they look like this: Image credit: A-weighting - Wikipedia This means that, even if the are high sound pressure levels floating around in the air, we might not hear them just because of the frequency they are at. Normally humans can hear from something around 20Hz to 20kHz, although most adults might not hear anything in out-of-laboratory conditions above 15kHz. Some animals though, can perceive a great range of frequencies , and for example mouses can hear up to 80kHz! So, now we know what this all is about, the I2S microphone is going to help us understand better how beluga whales communicate among themselves ... But also! The I2S microphone is interesting in order to understand sources of urban noise pollution since it provides us with a raw SPL buffer we can play with. As well, we can obtain dBA levels (SPL with a-weighting correction) by processing this buffer in several ways and calculate the RMS level of the resulting signal. Signal postprocessing Link RMS and FFT algorithm simplified Link In this paragraph we'll continue with some bits and pieces about acoustics and signal processing . In the previous section we introduced the concept of weighting and our interest on calculating the sound pressure level in different scales. Normally, SPL is expressed in RMS levels, or root mean square . This is nothing more than a modified arithmetic average, where each term of the expression is added in its square form. Therefore, to keep the same units, we then take the square root of all the average and we have: x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} The interesting thing about the RMS level, is that it expresses an average signal level throughout the signal, and it actually relates to the peak level of sinusoid wave by \u221a2. Therefore, it is a very interesting way to express average levels for signals and for that reason, it's the common standard used. Image credit: Sine wave parameters- Wikipedia Now that we know how to calculate the RMS level of our signal, let's go into something more interesting: how do we actually perform the weighting? Well, if you recall the previous section, when we talked about hearing, we were talking about the different hearing capabilities in terms of frequencies (in humans, mouses, beluga whales... ). Therefore, something interesting to know about our signal is its frequency content , so that we are able to perform the weighting. For this purpose, we have the FFT algorithm , which we won't tell you is easy, but we'll try to put it simply here. So FFT stands for Fast Fourier Transform , and it's an algorithm capable of performing a Fourier Transform in a simplified and efficient way (that's where the fast comes in). What it does in a detailed mathematical way is something quite complicated and we don't want to bore you and ourselves with the details; but being practical, it is basically a convertion between the signal in time domain and its frequency domain components. Interestingly, this process is reversible and the other way around it is called IFFT ( I for Inverse , obviously...). Image credit: Smart Citizen In the example above, things in the time domain get a bit messy, but in the frequency domain we can clearly see the composition of two sine waves of the same amplitude of roughly 40Hz and 120Hz. The FFT algorithm hence helps us digest the information contained in a signal in a more visually understandable way. For this introduction, let's move on to what we actually want to do: the much anticipated weighting . At this point, our task is fairly easy: we just have to multiply both: our signal in the frequency domain with the weighting function and that's it! If we have a look at the figure below, in the time and frequency domain, the signals look like this: Image credit: Smart Citizen This example shows how our ears are only capable of perceiving the signal in red, but the actual sound components are in blue -- being much higher in the amplitude spectrum. If you want to get into the thick of it, here you have the actual implementation in Matlab of the A-weighting function that we'll use in the SCK V2.0. And finally, to close, let's take a look at the whole chain of processing, where we will continue in future sections: Signal acquisition Windowing FFT Spectrum Normalisation Equalisation A-weighting RMS calculation This is the whole signal treatment process we use for the I2S microphone ICS43432. We will have a look at windowing and its use in future sections, as well as its implementation in the SAMD21 Cortex M0+ for our firmware. NB NB : Being mathematical purist, there is yet another possibility for this procedure using convolution in time domain, which we will cover in future sections. Pre/post processing: signal windowing and equalisation Link Signal windowing Link In this section we are going to describe how we have to pre-post process our signals in order to obtain the results in the manner we are expecting. These are very important steps in our processing chain, since the FFT algorithms -or convolution FIR Filters- won't be able to cope with our system's limitations. These limitations might not be obvious at the beginning, but you really don't want to ignore them while designing your system, since they'll invalidate many of your measurements. The very first of these limitations, is the fact that our microphone is, in fact, taking discrete samples of the ambient noise surrounding it. This means that, from the very beginning, we are missing some pieces of information and we will never be able to process them. But it's OK! For the purpose of our analysis, we don't need to sample continuosly and this situation is easily bypassed. Image credit: NUTAQ - Signal processing Discrete sampling has two main consequences for us: the first one is that we are taking samples once every 1/f_s 1/f_s , where f_s f_s is the sampling frequency. Normal audio systems sample at 44,1kHz, but this number might vary depending on the application. If you remember this chart , you might be wondering why we have to sample at such a high frequency. Image credit: Signal acquisition - Adinstruments This is due to the Nyquist sampling criterion , which states that at a minimum, we have to sample at double the maximum frequency we want to analyse . Since humans hearing has a limited frequency range that goes up to 20kHz in some cases, it is reasonable to use something around 40kHz. With this, the Nyquist criterion solves the so called aliasing problem , in which several sinusoid signals could fit the same sampling pattern if the number of samples is too low: Image credit: Wikipedia - Aliasing The second of the discrete sampling limitation comes from the amount of samples we are able to handle at a time . Normally, this is due to memory limitations in the RAM, although we'll see in the future where to allocate them. Nevertheless, it is not useful to handle buffers that are too long , since at some point, the increase of buffer length does not provide any additional information. Buffer length requirements in our case come from the minimum frequency we want to sample, which is around 20Hz . Doing some quick math, we need 0,05s worth of sample buffer, which at 44,1kHz is roughly 2200 samples . This is equally too many samples, considering that each could be allocated as a uint8_t , taking up to 16kB just for the raw buffer! This is where signal windowing kicks in. Imagine that we have a very-low-frequency sinusoid and that we are not able to sample completely the whole sine wave, due to buffer limitations. By definition, our system is assuming that the discrete samples we measure are constantly being repeated in the environment, one after the other: Image credit: Smart Citizen When we take the FFT of this signal, we see undesired frequencies that make our frequency spectrum invalid. This is called spectral leakage and it's mitigated by the use of windows (math funcions, not the OS). These windows operate by smoothing the edges of our measurement and preventing the jumps in the signal helping the FFT algorithm to properly analyse the signals. Image credit: Smart Citizen With the use of signal windowing , more specifically with the use of the hamming window , we are then able to reduce the amount of samples needed to roughly 1000 samples. Now we are down to 50% of the memory allocation needed without windowing . You can see the effect on the RMS relative errors in the image below, where the trend of the Hann (another common window) and the Hamming treated buffers, with respect to the frequency tends to stabilise much more quickly than the raw buffers. Image credit: Smart Citizen There is a wide range of functions to use and the decision depends on your application. For audio applications, the most common ones are the Hann, Hamming, and Blackmann. We chose the Hamming because it's trend is to stabilise a bit more quickly than the rest, although the differencies are minimal. For your reference, there is a very interesting description of all these phenomena in this article , where you'll find a more mathematical approach. Info Talk about the microphone response and how to correct it. Filtering and convolution Link In this section we are going to talk about a different approach to the FFT Analysis we have seen in previous sections. What if we don't like the FFT algorithm and we only want to obtain a dBA or dBC results? There is a fairly simple solution to this problem, and it's called filtering . Filtering is a very common technique in signal acquisition that eliminates some frequency components of the raw signal. Examples of filters you very likely have heard of are low-pass, high-pass and band-pass filters . These only let pass the low, high or a defined interval range of frequencies, mostly cancelling out the rest. In the frequency domain, they basicly multiply the spectrum of our signal with its filter spectrum. Exactly what we have done with the weighting. Image credit: Norwegian Creations First, it is important to get a glimpse of the math behind the filters and why they do their magic. And for this, the most important thing we need to know is called convolution . Image credit: River Trail For the purpose of audio analysis , let's consider we have an input vector, a filter kernel and an output vector. Our input vector can be the raw audio signal we have captured, being the output signal the result of the convolution operation. The filter kernel is the characteristic of the filter and will be, for this example, a one dimension array. What the convolution operation is going to do, in a very very very simplified way , is to sweep through the input sample and multiply each component with it's corresponding filter kernel component, then sum the results and put them in the corresponding output sample. If we put some math notation and call x[n] to the input vector, h[n] to the filter kernel and y[n] to the output vector, it all ends up looking like this: Image credit: DSP Guide Now, the most interesting thing of all this theory is that convolution and multiplication are equivalent operations when we jump from the time to the frequency domain . This means that multiplication in time domain equals to convolution in frequency domain, and more importantly for us, convolution in the time domain, equals to multiplication in the frequency domain . To sum up, the relationship between both domains would look like: Image credit: SmartCitizen Therefore, what we could do is to define a custom filter function and apply it via convolution to our input buffer. This is basically a FIR filter , where FIR stands for Finite Impulse Response . There is another type of filters called IIR , where IIR stands for Infinite impulse response . The difference between them is that FIR uses convolution and IIR uses recursion . The concept of recursion is very simple and it's nothing else than a simplification of the convolution, given that in the convolution algorithm, there are many recursive operations that we repeat over an over and we can implement into a smarter algorithm. Normally, IIR filters are more efficient in terms of speed and memory , but we need to specify a series of coefficients, and it's tricky, if not impossible, to create a custom filter response. Image credit: DSP Guide So finally! How can we avoid using the FFT algorithm to extract the desired frequency content of a signal and recreate the signal without it? Sounds complex, but now we know that we can use a FIR filter , with a custom frequency response and apply it via convolution to our input buffer. As simple as that. The custom frequency response, with the proper math, can be optained by applying the IFFT algorithm to the desired frequency response (for example, the A-weighting function). You can have a look to this example if you want to create a custom filter function in octave , with A or C weighting and implement it to a FIR filter in C++. Image credit: SmartCitizen Also, if you are really into it, you can read more about convolution and other DSP topics, we would recommended to go through this fantastic guide . AFSK Analyser Link In this section we are going to talk about a new feature we are planning to introduce in the upcoming version of the SCK: a FSK communication protocol via Audio (A-FSK). You might have read about this technique and it\u2019s usage in the Amazon Dash configuration process, and on the post today we are going to describe very briefly the work in progress for this feature. So! FSK stands for Frequency Shift Keying, which is a form of transmission through frequency variations on the carrying waveforms. It\u2019s major counterpart is the so called ASK, or Amplitude Shift Keying, in which the transmission is carried out via amplitude variations. A very simple form of ASK is OOK, which stands for On-Off-Keying, in which the amplitude of the carrier wave oscillates between a value and nothingness: Image credit: Electric Stack Exchange As in many other situations, there is a trade off between the options on the table: ASK or FSK? Maybe another one? The main disadvantage of ASK it is said to have a higher probability of error with respect to FSK, since noise interference affects amplitude of the transmitted wave. FSK, on the other hand, it is said to have a lower bandwidth efficiency. However, since we have talked about FFT quite a lot now, we thought FSK would be our best bet and also, because maybe bandwidth is not such a big deal after all as we can see below. Then, the idea is to implement an algorithm that is able to identify if the sound transmitted from an emitter (i.e. a smartphone) contains a series of reference frequencies in certain known spots. Following this principle, our aim is to transmit a byte per sound wave, hence, in a sound wave containing up to 8 possible carrier frequencies that might or not be activated. The activation (or not) of these frequencies in the analysed spectrum will yield a 1 or a 0, that we can use on a bit mask and extract 8-bit ASCII characters codes : Image credit: Martin Melhus The emitter could be based on the Web Audio API, as the example from Martin Melhus above from his project on a Web Audio Modem. Finally, the receiver would be our beloved I2S Mems microphone that we have been talking about for so long now, doing a FFT algorithm and detecting the peaks in it, identifying the carrier frequencies activation. Field Evaluation Link The sensor is calibrated in an anechoic chamber with a reference microphone to obtain sensor characteristics for spectrum equalisation. The TDK ICS43432 (former Invensense) has a clear non-linear response, which is specified in it's datasheet and is characterised in an anechoic chamber as specified above: Image credit: Invensense ICS43432 The results for this characterisation, for different SPLs are shown below: The microphone's spectrum response is not dependent on the SPL, but only on the frequency. The above response is corrected in the Smart Citizen Kit on real time. A double point validation is performed on both microphones, from the SCK1.5 and the SCK2.0, yielding the following results: Finally, if comparing these with the thresholds, in dBA scale IEC 61672-1 , without accounting for the previous equalisation: Which yields a very good linearity off-the-shelf over the common urban frequency range (below 2000Hz). Source files Link Download Check the source code","title":"Index"},{"location":"Components/Urban Sensor Board/Noise Sensor/#introduction-to-noise-sensor-design","text":"","title":"Introduction to Noise Sensor Design"},{"location":"Components/Urban Sensor Board/Noise Sensor/#basics-of-mems-i2s-microphone","text":"The new Urban Sensor Board SCK 2.0 comes with a digital MEMs I2S microphone . There is a wide range of possibilities in the market, and our pick was the INVENSENSE (now TDK) ICS43432 : a tiny digital MEMs microphone with I2S output. There is an extensive documentation at TDK's website coming from the former and we would recommend to review the nicely put documents for those interested in the topic. Image credit: Invensense ICS43432 To begin with, we'll talk about the microphone itself. The MEMs microphone comes with a transducer element which converts the sound pressure into electric signals. The sound pressure reaches the transducer through a hole drilled in the package and the transducer's signal is sent to an ADC which provides with a signal which can be pulse density modulated (PDM) or in I2S format. Since the ADC is already in the microphone, we have an all-digital audio capture path to the processor and it\u2019s less likely to pick up interferences from other RF, such as the WiFi, for example. The I2S has the advantage of a decimated output, and since the SAMD21 has an I2S port, this allows us to connect it directly to the microcontroller with no CODEC needed to decode the audio data. Additionally, there is a bandpass filter, which eliminates DC and low frequency components (i.e. at fs = 48kHz, the filter has -3dB corner at 3,7Hz) and high frequencies at 0,5\u00b7fs (-3dB cutoff). Both specifications are important to consider when analysing the data and discarding unusable frequencies. The microphone acoustic response has to be considered as well, with subsequent equalisation in the data treatment in order. Image credit: ICS43432 Datasheet - TDK Invensense","title":"Basics of MEMs I2S Microphone"},{"location":"Components/Urban Sensor Board/Noise Sensor/#i2s-protocol","text":"The I2S protocol ( Inter-IC-Sound ) is a serial bus interface which consists of: a bit clock line or Serial Clock ( SCK ), a word clock line or Word Select ( WS ) and a multiplexed Serial Data line ( SD ). The SD is transmitted in two\u2019s complement with MSB first, with a 24-bit word length in the microphone we picked. The WS is used to indicate which channel is being transmitted (left or right). In the case of the ICS43432, there is an additional pin which corresponds with the L/R, allowing to use the left or right channel to output the signal and the use of stereo configurations. When set to left, the data follows WS\u2019s falling edge and when set to right, the WS\u2019s rising edge. For the SAMD21 processor, there is a well developed I2S library that will take control of this configuration. Image credit: I2S bus specification - Philips Semiconductors Also, we would like to highlight that the SD line of the I2S protocol is quite delicate at high frequencies and it is largely affected by noise in the path the line follows. If you want to try this at home (for example with an Arduino Zero and an I2S microphone like this one , it is important not to use cables in this line and to connect the output pin directly to the board, to avoid having interfaces throughout the SD line. One interesting way to see this is that every time the line sees a medium change, part of it will be reflected and part will be transmitted, just like any other wave. This means that introducing a cable for the line will provoke at least three medium changes and a potential signal quality loss much higher than a direct connection. Apart from this point, the I2S connection is pretty straight forward and it is reasonably easy to retrieve data from the line and start playing around with some FFT analysis.","title":"I2S Protocol"},{"location":"Components/Urban Sensor Board/Noise Sensor/#basics-of-weighting-and-human-hearing","text":"The world of acoustics and signal processing for audio analysis is worth several book-length discussions. We might as well try to give an insight of our intentions within this world since we introduced ourselves in it by picking a digital microphone with a quite nice range of capabilities. The very first thing we would like to do is to be able to perform weighting on the buffer we receive from the microphone through the I2S. To explain a bit further on what weighting is, it is no more than a transformation from the real-world sound pressure levels (SPL) travelling around in the air to what our ears can perceive. Just that. Image credit: Human hearing - DSP Guide There are several studies and models of what we actually perceive and depending on them, we have several types of the so called weighting functions . Some of them have been standarised for the purpose of SPL measurement, finding different types like A-weighting (the most common one), B-weighting, D (both in disuse) and others. In the frequency domain, they look like this: Image credit: A-weighting - Wikipedia This means that, even if the are high sound pressure levels floating around in the air, we might not hear them just because of the frequency they are at. Normally humans can hear from something around 20Hz to 20kHz, although most adults might not hear anything in out-of-laboratory conditions above 15kHz. Some animals though, can perceive a great range of frequencies , and for example mouses can hear up to 80kHz! So, now we know what this all is about, the I2S microphone is going to help us understand better how beluga whales communicate among themselves ... But also! The I2S microphone is interesting in order to understand sources of urban noise pollution since it provides us with a raw SPL buffer we can play with. As well, we can obtain dBA levels (SPL with a-weighting correction) by processing this buffer in several ways and calculate the RMS level of the resulting signal.","title":"Basics of weighting and human hearing"},{"location":"Components/Urban Sensor Board/Noise Sensor/#signal-postprocessing","text":"","title":"Signal postprocessing"},{"location":"Components/Urban Sensor Board/Noise Sensor/#rms-and-fft-algorithm-simplified","text":"In this paragraph we'll continue with some bits and pieces about acoustics and signal processing . In the previous section we introduced the concept of weighting and our interest on calculating the sound pressure level in different scales. Normally, SPL is expressed in RMS levels, or root mean square . This is nothing more than a modified arithmetic average, where each term of the expression is added in its square form. Therefore, to keep the same units, we then take the square root of all the average and we have: x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} x = {\\sqrt{x_1^2+x_2^2+...+x_N^2 \\over N}} The interesting thing about the RMS level, is that it expresses an average signal level throughout the signal, and it actually relates to the peak level of sinusoid wave by \u221a2. Therefore, it is a very interesting way to express average levels for signals and for that reason, it's the common standard used. Image credit: Sine wave parameters- Wikipedia Now that we know how to calculate the RMS level of our signal, let's go into something more interesting: how do we actually perform the weighting? Well, if you recall the previous section, when we talked about hearing, we were talking about the different hearing capabilities in terms of frequencies (in humans, mouses, beluga whales... ). Therefore, something interesting to know about our signal is its frequency content , so that we are able to perform the weighting. For this purpose, we have the FFT algorithm , which we won't tell you is easy, but we'll try to put it simply here. So FFT stands for Fast Fourier Transform , and it's an algorithm capable of performing a Fourier Transform in a simplified and efficient way (that's where the fast comes in). What it does in a detailed mathematical way is something quite complicated and we don't want to bore you and ourselves with the details; but being practical, it is basically a convertion between the signal in time domain and its frequency domain components. Interestingly, this process is reversible and the other way around it is called IFFT ( I for Inverse , obviously...). Image credit: Smart Citizen In the example above, things in the time domain get a bit messy, but in the frequency domain we can clearly see the composition of two sine waves of the same amplitude of roughly 40Hz and 120Hz. The FFT algorithm hence helps us digest the information contained in a signal in a more visually understandable way. For this introduction, let's move on to what we actually want to do: the much anticipated weighting . At this point, our task is fairly easy: we just have to multiply both: our signal in the frequency domain with the weighting function and that's it! If we have a look at the figure below, in the time and frequency domain, the signals look like this: Image credit: Smart Citizen This example shows how our ears are only capable of perceiving the signal in red, but the actual sound components are in blue -- being much higher in the amplitude spectrum. If you want to get into the thick of it, here you have the actual implementation in Matlab of the A-weighting function that we'll use in the SCK V2.0. And finally, to close, let's take a look at the whole chain of processing, where we will continue in future sections: Signal acquisition Windowing FFT Spectrum Normalisation Equalisation A-weighting RMS calculation This is the whole signal treatment process we use for the I2S microphone ICS43432. We will have a look at windowing and its use in future sections, as well as its implementation in the SAMD21 Cortex M0+ for our firmware. NB NB : Being mathematical purist, there is yet another possibility for this procedure using convolution in time domain, which we will cover in future sections.","title":"RMS and FFT algorithm simplified"},{"location":"Components/Urban Sensor Board/Noise Sensor/#prepost-processing-signal-windowing-and-equalisation","text":"","title":"Pre/post processing: signal windowing and equalisation"},{"location":"Components/Urban Sensor Board/Noise Sensor/#signal-windowing","text":"In this section we are going to describe how we have to pre-post process our signals in order to obtain the results in the manner we are expecting. These are very important steps in our processing chain, since the FFT algorithms -or convolution FIR Filters- won't be able to cope with our system's limitations. These limitations might not be obvious at the beginning, but you really don't want to ignore them while designing your system, since they'll invalidate many of your measurements. The very first of these limitations, is the fact that our microphone is, in fact, taking discrete samples of the ambient noise surrounding it. This means that, from the very beginning, we are missing some pieces of information and we will never be able to process them. But it's OK! For the purpose of our analysis, we don't need to sample continuosly and this situation is easily bypassed. Image credit: NUTAQ - Signal processing Discrete sampling has two main consequences for us: the first one is that we are taking samples once every 1/f_s 1/f_s , where f_s f_s is the sampling frequency. Normal audio systems sample at 44,1kHz, but this number might vary depending on the application. If you remember this chart , you might be wondering why we have to sample at such a high frequency. Image credit: Signal acquisition - Adinstruments This is due to the Nyquist sampling criterion , which states that at a minimum, we have to sample at double the maximum frequency we want to analyse . Since humans hearing has a limited frequency range that goes up to 20kHz in some cases, it is reasonable to use something around 40kHz. With this, the Nyquist criterion solves the so called aliasing problem , in which several sinusoid signals could fit the same sampling pattern if the number of samples is too low: Image credit: Wikipedia - Aliasing The second of the discrete sampling limitation comes from the amount of samples we are able to handle at a time . Normally, this is due to memory limitations in the RAM, although we'll see in the future where to allocate them. Nevertheless, it is not useful to handle buffers that are too long , since at some point, the increase of buffer length does not provide any additional information. Buffer length requirements in our case come from the minimum frequency we want to sample, which is around 20Hz . Doing some quick math, we need 0,05s worth of sample buffer, which at 44,1kHz is roughly 2200 samples . This is equally too many samples, considering that each could be allocated as a uint8_t , taking up to 16kB just for the raw buffer! This is where signal windowing kicks in. Imagine that we have a very-low-frequency sinusoid and that we are not able to sample completely the whole sine wave, due to buffer limitations. By definition, our system is assuming that the discrete samples we measure are constantly being repeated in the environment, one after the other: Image credit: Smart Citizen When we take the FFT of this signal, we see undesired frequencies that make our frequency spectrum invalid. This is called spectral leakage and it's mitigated by the use of windows (math funcions, not the OS). These windows operate by smoothing the edges of our measurement and preventing the jumps in the signal helping the FFT algorithm to properly analyse the signals. Image credit: Smart Citizen With the use of signal windowing , more specifically with the use of the hamming window , we are then able to reduce the amount of samples needed to roughly 1000 samples. Now we are down to 50% of the memory allocation needed without windowing . You can see the effect on the RMS relative errors in the image below, where the trend of the Hann (another common window) and the Hamming treated buffers, with respect to the frequency tends to stabilise much more quickly than the raw buffers. Image credit: Smart Citizen There is a wide range of functions to use and the decision depends on your application. For audio applications, the most common ones are the Hann, Hamming, and Blackmann. We chose the Hamming because it's trend is to stabilise a bit more quickly than the rest, although the differencies are minimal. For your reference, there is a very interesting description of all these phenomena in this article , where you'll find a more mathematical approach. Info Talk about the microphone response and how to correct it.","title":"Signal windowing"},{"location":"Components/Urban Sensor Board/Noise Sensor/#filtering-and-convolution","text":"In this section we are going to talk about a different approach to the FFT Analysis we have seen in previous sections. What if we don't like the FFT algorithm and we only want to obtain a dBA or dBC results? There is a fairly simple solution to this problem, and it's called filtering . Filtering is a very common technique in signal acquisition that eliminates some frequency components of the raw signal. Examples of filters you very likely have heard of are low-pass, high-pass and band-pass filters . These only let pass the low, high or a defined interval range of frequencies, mostly cancelling out the rest. In the frequency domain, they basicly multiply the spectrum of our signal with its filter spectrum. Exactly what we have done with the weighting. Image credit: Norwegian Creations First, it is important to get a glimpse of the math behind the filters and why they do their magic. And for this, the most important thing we need to know is called convolution . Image credit: River Trail For the purpose of audio analysis , let's consider we have an input vector, a filter kernel and an output vector. Our input vector can be the raw audio signal we have captured, being the output signal the result of the convolution operation. The filter kernel is the characteristic of the filter and will be, for this example, a one dimension array. What the convolution operation is going to do, in a very very very simplified way , is to sweep through the input sample and multiply each component with it's corresponding filter kernel component, then sum the results and put them in the corresponding output sample. If we put some math notation and call x[n] to the input vector, h[n] to the filter kernel and y[n] to the output vector, it all ends up looking like this: Image credit: DSP Guide Now, the most interesting thing of all this theory is that convolution and multiplication are equivalent operations when we jump from the time to the frequency domain . This means that multiplication in time domain equals to convolution in frequency domain, and more importantly for us, convolution in the time domain, equals to multiplication in the frequency domain . To sum up, the relationship between both domains would look like: Image credit: SmartCitizen Therefore, what we could do is to define a custom filter function and apply it via convolution to our input buffer. This is basically a FIR filter , where FIR stands for Finite Impulse Response . There is another type of filters called IIR , where IIR stands for Infinite impulse response . The difference between them is that FIR uses convolution and IIR uses recursion . The concept of recursion is very simple and it's nothing else than a simplification of the convolution, given that in the convolution algorithm, there are many recursive operations that we repeat over an over and we can implement into a smarter algorithm. Normally, IIR filters are more efficient in terms of speed and memory , but we need to specify a series of coefficients, and it's tricky, if not impossible, to create a custom filter response. Image credit: DSP Guide So finally! How can we avoid using the FFT algorithm to extract the desired frequency content of a signal and recreate the signal without it? Sounds complex, but now we know that we can use a FIR filter , with a custom frequency response and apply it via convolution to our input buffer. As simple as that. The custom frequency response, with the proper math, can be optained by applying the IFFT algorithm to the desired frequency response (for example, the A-weighting function). You can have a look to this example if you want to create a custom filter function in octave , with A or C weighting and implement it to a FIR filter in C++. Image credit: SmartCitizen Also, if you are really into it, you can read more about convolution and other DSP topics, we would recommended to go through this fantastic guide .","title":"Filtering and convolution"},{"location":"Components/Urban Sensor Board/Noise Sensor/#afsk-analyser","text":"In this section we are going to talk about a new feature we are planning to introduce in the upcoming version of the SCK: a FSK communication protocol via Audio (A-FSK). You might have read about this technique and it\u2019s usage in the Amazon Dash configuration process, and on the post today we are going to describe very briefly the work in progress for this feature. So! FSK stands for Frequency Shift Keying, which is a form of transmission through frequency variations on the carrying waveforms. It\u2019s major counterpart is the so called ASK, or Amplitude Shift Keying, in which the transmission is carried out via amplitude variations. A very simple form of ASK is OOK, which stands for On-Off-Keying, in which the amplitude of the carrier wave oscillates between a value and nothingness: Image credit: Electric Stack Exchange As in many other situations, there is a trade off between the options on the table: ASK or FSK? Maybe another one? The main disadvantage of ASK it is said to have a higher probability of error with respect to FSK, since noise interference affects amplitude of the transmitted wave. FSK, on the other hand, it is said to have a lower bandwidth efficiency. However, since we have talked about FFT quite a lot now, we thought FSK would be our best bet and also, because maybe bandwidth is not such a big deal after all as we can see below. Then, the idea is to implement an algorithm that is able to identify if the sound transmitted from an emitter (i.e. a smartphone) contains a series of reference frequencies in certain known spots. Following this principle, our aim is to transmit a byte per sound wave, hence, in a sound wave containing up to 8 possible carrier frequencies that might or not be activated. The activation (or not) of these frequencies in the analysed spectrum will yield a 1 or a 0, that we can use on a bit mask and extract 8-bit ASCII characters codes : Image credit: Martin Melhus The emitter could be based on the Web Audio API, as the example from Martin Melhus above from his project on a Web Audio Modem. Finally, the receiver would be our beloved I2S Mems microphone that we have been talking about for so long now, doing a FFT algorithm and detecting the peaks in it, identifying the carrier frequencies activation.","title":"AFSK Analyser"},{"location":"Components/Urban Sensor Board/Noise Sensor/#field-evaluation","text":"The sensor is calibrated in an anechoic chamber with a reference microphone to obtain sensor characteristics for spectrum equalisation. The TDK ICS43432 (former Invensense) has a clear non-linear response, which is specified in it's datasheet and is characterised in an anechoic chamber as specified above: Image credit: Invensense ICS43432 The results for this characterisation, for different SPLs are shown below: The microphone's spectrum response is not dependent on the SPL, but only on the frequency. The above response is corrected in the Smart Citizen Kit on real time. A double point validation is performed on both microphones, from the SCK1.5 and the SCK2.0, yielding the following results: Finally, if comparing these with the thresholds, in dBA scale IEC 61672-1 , without accounting for the previous equalisation: Which yields a very good linearity off-the-shelf over the common urban frequency range (below 2000Hz).","title":"Field Evaluation"},{"location":"Components/Urban Sensor Board/Noise Sensor/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Components/Urban Sensor Board/Noise Sensor/Implementation/","text":"Noise Sensor Implementation Link Firmware Link Audio I2S Library Link A custom library for audio analysis. Work in progress Audio I2S Base library, intented to be generic purpose audio analysis library for an I2S Microphone on the SAMD21 with: FFT Analysis FIR Analysis Custom window selection Custom weighting function selection Custom buffer size and custom fft bin size (in case of FFT analyser) Custom equalisation Octave auto generation of .h files for coefficients and so on Smart Citizen Firmware Link Smart Citizen Firmware Firmware implementation in the SmartCitizen Kit 2.0 and 2.1, with a better usage of memory and SCK related functionalities: FFT analysis Selection of A or C weighting through LUT Two user cases: General audio analysis with fixed buffer size and fixed FFT bins size (fs = 44,1kHz) Source files Link Download Check the source code","title":"Implementation"},{"location":"Components/Urban Sensor Board/Noise Sensor/Implementation/#noise-sensor-implementation","text":"","title":"Noise Sensor Implementation"},{"location":"Components/Urban Sensor Board/Noise Sensor/Implementation/#firmware","text":"","title":"Firmware"},{"location":"Components/Urban Sensor Board/Noise Sensor/Implementation/#audio-i2s-library","text":"A custom library for audio analysis. Work in progress Audio I2S Base library, intented to be generic purpose audio analysis library for an I2S Microphone on the SAMD21 with: FFT Analysis FIR Analysis Custom window selection Custom weighting function selection Custom buffer size and custom fft bin size (in case of FFT analyser) Custom equalisation Octave auto generation of .h files for coefficients and so on","title":"Audio I2S Library"},{"location":"Components/Urban Sensor Board/Noise Sensor/Implementation/#smart-citizen-firmware","text":"Smart Citizen Firmware Firmware implementation in the SmartCitizen Kit 2.0 and 2.1, with a better usage of memory and SCK related functionalities: FFT analysis Selection of A or C weighting through LUT Two user cases: General audio analysis with fixed buffer size and fixed FFT bins size (fs = 44,1kHz)","title":"Smart Citizen Firmware"},{"location":"Components/Urban Sensor Board/Noise Sensor/Implementation/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Legacy Hardware/","text":"Getting Started Link Installing a Smart Smart Citizen Kit 1.0 / 1.1 Link Welcome aboard! The Smart Citizen Team wants to thank you for being here, for purchasing a kit, and for joining the community taking part in this adventure. To join the Smart Citizen family , we're going to walk you through the steps to add your Smart Smart Citizen Kit to the platform, we'll refer to the Smart Smart Citizen Kit as the SCK for now on. SIGN UP First, go to smartcitizen.me using your web browser, currently only Google Chrome is supported for the SCK configuration process. Click in Go to the platform and then Sign up on the upper right menu. Complete the required fields, accept the Terms of use and privacy and click the Sign up button. Required Fields: Username - Pick any name you want as long as someone else isn't already using the it. Email - Enter your email address. Password - Must be at least 6 characters. You are now registered, you will receive an email notification. You will be able to complete your user details later on your profile page . ADD YOUR SMART Smart Citizen Kit On the upper right menu click on Log in and write the access credentials you just choose. Go on your user icon on the upper right corner and click Profile . On your kit's profile page click on Add a new kit . Please, provide basic information about your kit so others can understand better how you set it up and how you plan to use it. Title - Give your SCK a name. This title will be associated with your SCK data. Exposure - The SCK is designed to work outdoors but maybe you like to test it indoors first. Choose INDOOR or OUTDOOR to help others understand the data you will provide. Kit location - Please, let us locate you, later you can adjust the location by dragging the marker on the map. Kit tags - We suggest you to add tags to help other find your kit. Choose from the available tags or submit a tag request on the Forum . Description - This is an optional field that helps others understand the data you provide. Why is it for? Is this part of any kind of project? Information like \"outdoors in my balcony facing the road\" or \"in my garden under a tree\" could help others understand why some of your data looks the way it does. Click on the Next button, you are close to the end. SETUP YOUR SMART Smart Citizen Kit In order to have your kit connected to the Smart Citizen platform, we need a few step involving the connexion of your kit to your computer. This tool will help you register your kit to the platform, setup your kit's Wi-Fi settings and update its firmware. Currently we support Google Chrome in Win, Mac and Linux. If you are on Windows check first How to install the drivers on Windows? section for more information. Click on the ADD TO CHROME button and wait for the extension to install. Finally its time to unpack your SCK. Connect the micro USB cable to your SCK and your computer and turn on the SCK switch on the upper left corner. On the dropdown menu you should select the port your SCK is connected. On Mac and Linux the port will be named Smartcitizen or something like /dev/ttyACM0. On Windows this is likely to be COM3 or higher (COM1 and COM2 are usually reserved for hardware serial ports). To find out, you can disconnect your SCK and check the dropdown; the entry that disappears should be the SCK board. Reconnect the board and select that serial port. If you have any issue check your kit is properly connected, switched ON and you do not have the Arduino IDE or other software that uses the serial port open. We recommend you to switch your kit OFF and ON in order to reset the kit before you start. Now just click Start process in order to start configuring your kit. The configurator will try to determine your hardware and firmware version, if your firmware version is below 0.9.3 you need to update the firmware in order to continue with the process. If the configurator can't communicate with your board it will report an Unrecognized board , we recommend you to try a couple of times, disconnecting your kit, reloading the page and connecting it again to make sure that this is not just a serial port communication problem. If the configurator still can't communicate with your kit it may be a firmware/hardware problem. You may try to install the firmware and see if this solves the problem. If you can't upload the firmware please refer to the Firmware update problem section or try doing a Manual set up. After firmware is installed/updated we can continue with Wi-Fi settings. You can add up to 5 different Wi-Fi credentials in your kit. This will allow your kit to connect to multiple networks in case one fails or you will like to move in between to places You should complete the fields with your router or access point information: At home you should find all the requested information below your home fiber or DSL router on schools and companies you can contact your IT team SSID - This is your Wifi network's name, for example: My Home Wifi . Phrase - This is your Wi-Fi password , you will usually find it written under your router or you can contact your IT team. If your Wi-Fi doesn't have a password just leave it empty and select Open Wi-Fi network on the Encryption dropdown. Take care the SSID and Phrase can't be longer than 19 characters and they can't contain the $ symbol. Encryption - Optional You can leave it to WPA2 this is the default for most modern networks. External Antenna - Optional Is your SCK quite far away from Wi-Fi access point? You can use an external antenna with your SCK. Check the How to use an external antenna? ) Next step is optional, you can set your SCK update interval to optimize the battery performance and sensor resolution ratio. By default your SCK will take a reading every minute and post it on-line Reading interval - This defines every how much time your SCK sensors will take a reading and record it. You can set it from 1 minute to an hour. Number posts - This defines every how much sensor readings your SCK will publish the reading on-line. You can set it from 1 to 20. Now is time to record the settings on your SCK, just click on Sync Settings and wait for a moment. *If there is any issue during the process this will be displayed on the Message window above. I f you need help please contact support@smartcitizen.me * Last but now least you will see your SCK Mac Address registered below this is the ID of your SCK. Just click on Save and wait for your kit to publish. Done! You might need to wait up to 2 minutes or more if you changed the time update settings and refresh your browser in order to see your SCK first post in your device page. Did you registered your SCK before or did your SCK belong to someone else before? Take care your SCK can be registered once at a time, in case you registered before check How to unlink your SCK? or contact support@smartcitizen.me . Please, if your kit is not publishing properly contact support@smartcitizen.me or ask for help in the forum . Manual set up: The Serial Way Link In this tutorial aimed to advanced users you will configure your SCK using serial communication. By using serial communication, you will register your Wi-Fi settings into the SCK and save the SCK\u2019s MAC address in our server. The SCK, like most Arduino chips, has the ability to communicate through serial protocol (when plugged with a proper USB cable). The SCK uses the WiFly module to communicate with your Wi-Fi router. Anyway, through serial communication you will be able to send the commands directly with this module to set your Wi-Fi settings and extract the MAC address used by our server to verify your identity. Note that this tutorial works for both SCK v1.0 (from the Goteo crowdfunding campaign) and SCK v1.1 (from the KickStarter crowdfunding campaign), independently of the firmware version used. Configuring the Wi-Fi settings Link Open Arduino IDE. Connect your SCK via USB. From the Tools > Board menu, choose the right USB port (generally the last one). From the Tools > Serial port menu, select the right board. This is Leonardo for SCK v1.0 (Goteo) or LilyPad Arduino USB for SCK v1.1 (Kickstarter). Open the serial monitor window in the Arduino IDE (button at the top-right of the main window). Set the options to \"115200 baud\" and \u201cNo line return\u201d (drop-down menu at the bottom-right of the monitor window). Wake up the module and activate the Wi-Fi command mode by typing in the serial monitor: $$$ Change to \u201cCarriage return\u201d option (drop-down menu at the bottom-right of the monitor window) Add a new SSID to memory by typing: set wlan ssid XXX Note: You have to replace XXX with your ssid name, filling any space with the dollar ($) character. Due to hardware limitations it can't be longer than 32 characters. Add a new phrase to memory (optional, password for WPA1 & WPA2): set wlan phrase XXX Note: You have to replace XXX with your phrase, filling any space with the dollar ($) character. Add a new key to memory (optional, password for WEP & WEP64): set wlan key XXX Add an authentication method into memory (replace XXX by \u201c0\u201d for Open, \u201c1\u201d for WEP, \u201c2\u201d for WPA1, \u201c4\u201d for WPA2, \u201c8\u201d for WEP64): set wlan auth XXX Add an antenna type into memory (replace XXX by \u201c0\u201d to use the internal antenna or \u201c1\u201d if you use an external antenna): set wlan ext_antenna XXX Get the MAC address of the kit by typing: get mac Copy/Save the answer for further use. Exit and go back to the normal operational mode by typing: exit Registering the kit in the platform Link After you've uploaded your settings, don't forget to register your kit in our database by saving it's mac address. To find the mac address, you can use the serial command \"get mac\". Or have a look at the wifi module on the board and read the serial number under the bar code (something like \"131G0006662116E4\" on kit v1.0 or \"0006662116E4\" on kit v.1.1). The mac address is the last 12 digit of this serial, separated by a colon every two number. From a number like 0006662116 E4 you would write 00 : 06 : 66 : 21 : 16 : E4 . In both cases, you have to fill the mac address input field in the configuration page of your kit and press the save button. You are now done with the manual configuration of your SCK. Wait for a few minutes to see your data coming on the server and being displayed on the web page. You can also check that everything is ok by looking at the Arduino serial monitor. Debug messages coming from your SCK should look like this: If you want to explore further options with the WiFly module check The SCK Command Line section. If you encounter any issue, please share your problem on the forum Manual set up: The Compilation Way Link This tutorial is aimed to advanced users, we will guide you through the process of setting up your kit by editing directly the source code. As the code is Open Source, one way of setting the Wi-Fi of your SCK is to download the latest firmware, edit some lines of code, recompile it and upload it to the kit. One advantage of this method is that it gives you the opportunity to register multiple Wi-Fi networks at the same time and make the persistent. The Wi-fi networks that you register directly in the source code are called hardcoded and the only way to remove them is with the same process of compiling and uploading the firmware again. This is useful if your SCK is traveling from one location to another where the Wi-Fi credentials are known. The downside of this method is that you can not extract the MAC address of your kit, if you don't know it yet you will have to use the method described in The Serial Way or via the configurator in the setup page of your kit. Getting the Firmware Link You can download the latest firmware on our Github: https://github.com/fablabbcn/Smart-Citizen-Kit/releases As you may know, the hardware and software are based on the Arduino project. We will use the Arduino IDE to edit the firmware and upload it to the kit. This tutorial have been tested with Arduino 1.6.8, please download and install the Arduino IDE . Once installed open the file Smart - Citizen - Kit / sck_beta_v0_9_0 / sck_beta_v0_9 . ino Editing the code Link If you want to set the network configuration manually, you should go to the Constants . h tab and modify the lines you see below: #define networks 0 #if (networks > 0) static char * mySSID [ networks ] = { \"SSID1\" , \"SSID2\" }; static char * myPassword [ networks ] = { \"PASS1\" , \"PASS2\" }; static char * wifiEncript [ networks ] = { WPA2 , WPA2 }; static char * antennaExt [ networks ] = { INT_ANT , INT_ANT }; #endif The easiest way would be to write \"#define networks X\" (where X is the number of WI-FI networks you are going to use) and fill the options for your network: Add the name of your network in SSIDX and the corresponding password in PASSX . Due to hardware limitations neither the password or the ssid can't be longer tham 32 characters. On wifiEncript you could also choose the encryption mode that fits with your network's configuration ( OPEN , WEP , WPA1 , WPA2 , WEP64 ). On antennaExt you can choose the type of antenna you are using ( INT_ANT for internal antenna (default) or EXT_ANT for external antenna). If you register only one wifi credential, you should obtain something like this: #define networks 1 #if (networks > 0) char * mySSID [ networks ] = { \"MyWifiSSID\" }; char * myPassword [ networks ] = { \"MyPassword\" }; char * wifiEncript [ networks ] = { WPA2 }; char * antennaExt [ networks ] = { INT_ANT }; #endif Note that if you configure more than one Wi-fi network you have to separate the variables with a comma, for example: char * mySSID [ networks ] = { \"MyFirstSSID\" , \"MySecondSSID\" }; Uploading the code Link On the Arduino IDE Tools menu you should select the right Board in the Boards menu: For SmartSmart Citizen Kit version 1.0 select Arduino Leonardo (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Arduino LilyPad USB (ATmega 32U4 at 8Mhz) The Arduino IDE should automatically select the right USB port but you can check it in the Tools >> Port menu. Now you just need to click the Upload button and Arduino will do the rest for you! In case you have any issue please check the Arduino Troubleshooting guide. Registering the kit in the platform Link After you\u2019ve uploaded your settings, don\u2019t forget to register your kit in our database by saving it\u2019s mac address. To find the mac address, you can use the serial command \u201cget mac\u201d by following the section The Serial Way . Or have a look at the wifi module on the board and read the serial number under the bar code (something like \u201c131G0006662116E4\u201d on kit v1.0 or \u201c0006662116E4\u201d on kit v.1.1). The mac address is the last 12 digit of this serial, separated by a colon every two number. From a number like 0006662116 E4 you would write 00 : 06 : 66 : 21 : 16 : E4 . In both cases, you have to fill the mac address input field in the configuration page of your kit and press the save button. You are now done with the manual configuration of your SCK. Wait for a few minutes to see your data coming on the server and being displayed on the web page. You can also check that everything is ok by looking the output of your kit via the Arduino serial monitor. If you encounter any issue, please share your problem on the forum Attaching the solar panel Link The solar panel should fulfill the specification of a voltage bigger than 8v and less than 15v, 12v is the recommended voltage, and a minimum of 500mA. In order to attach the solar panel you have to solder the cables of the solar panel to the pads marked in the next image for version 1.0 of the SCK. For version 1.1 you have to connect the cables to the connector marked in the next image. In both versions, yo have to attach the plus of solar panel to the plus pad of the SCK, and the minus of the solar panel to the minus pad of the SCK.","title":"Index"},{"location":"Legacy Hardware/#getting-started","text":"","title":"Getting Started"},{"location":"Legacy Hardware/#installing-a-smart-smart-citizen-kit-10-11","text":"Welcome aboard! The Smart Citizen Team wants to thank you for being here, for purchasing a kit, and for joining the community taking part in this adventure. To join the Smart Citizen family , we're going to walk you through the steps to add your Smart Smart Citizen Kit to the platform, we'll refer to the Smart Smart Citizen Kit as the SCK for now on. SIGN UP First, go to smartcitizen.me using your web browser, currently only Google Chrome is supported for the SCK configuration process. Click in Go to the platform and then Sign up on the upper right menu. Complete the required fields, accept the Terms of use and privacy and click the Sign up button. Required Fields: Username - Pick any name you want as long as someone else isn't already using the it. Email - Enter your email address. Password - Must be at least 6 characters. You are now registered, you will receive an email notification. You will be able to complete your user details later on your profile page . ADD YOUR SMART Smart Citizen Kit On the upper right menu click on Log in and write the access credentials you just choose. Go on your user icon on the upper right corner and click Profile . On your kit's profile page click on Add a new kit . Please, provide basic information about your kit so others can understand better how you set it up and how you plan to use it. Title - Give your SCK a name. This title will be associated with your SCK data. Exposure - The SCK is designed to work outdoors but maybe you like to test it indoors first. Choose INDOOR or OUTDOOR to help others understand the data you will provide. Kit location - Please, let us locate you, later you can adjust the location by dragging the marker on the map. Kit tags - We suggest you to add tags to help other find your kit. Choose from the available tags or submit a tag request on the Forum . Description - This is an optional field that helps others understand the data you provide. Why is it for? Is this part of any kind of project? Information like \"outdoors in my balcony facing the road\" or \"in my garden under a tree\" could help others understand why some of your data looks the way it does. Click on the Next button, you are close to the end. SETUP YOUR SMART Smart Citizen Kit In order to have your kit connected to the Smart Citizen platform, we need a few step involving the connexion of your kit to your computer. This tool will help you register your kit to the platform, setup your kit's Wi-Fi settings and update its firmware. Currently we support Google Chrome in Win, Mac and Linux. If you are on Windows check first How to install the drivers on Windows? section for more information. Click on the ADD TO CHROME button and wait for the extension to install. Finally its time to unpack your SCK. Connect the micro USB cable to your SCK and your computer and turn on the SCK switch on the upper left corner. On the dropdown menu you should select the port your SCK is connected. On Mac and Linux the port will be named Smartcitizen or something like /dev/ttyACM0. On Windows this is likely to be COM3 or higher (COM1 and COM2 are usually reserved for hardware serial ports). To find out, you can disconnect your SCK and check the dropdown; the entry that disappears should be the SCK board. Reconnect the board and select that serial port. If you have any issue check your kit is properly connected, switched ON and you do not have the Arduino IDE or other software that uses the serial port open. We recommend you to switch your kit OFF and ON in order to reset the kit before you start. Now just click Start process in order to start configuring your kit. The configurator will try to determine your hardware and firmware version, if your firmware version is below 0.9.3 you need to update the firmware in order to continue with the process. If the configurator can't communicate with your board it will report an Unrecognized board , we recommend you to try a couple of times, disconnecting your kit, reloading the page and connecting it again to make sure that this is not just a serial port communication problem. If the configurator still can't communicate with your kit it may be a firmware/hardware problem. You may try to install the firmware and see if this solves the problem. If you can't upload the firmware please refer to the Firmware update problem section or try doing a Manual set up. After firmware is installed/updated we can continue with Wi-Fi settings. You can add up to 5 different Wi-Fi credentials in your kit. This will allow your kit to connect to multiple networks in case one fails or you will like to move in between to places You should complete the fields with your router or access point information: At home you should find all the requested information below your home fiber or DSL router on schools and companies you can contact your IT team SSID - This is your Wifi network's name, for example: My Home Wifi . Phrase - This is your Wi-Fi password , you will usually find it written under your router or you can contact your IT team. If your Wi-Fi doesn't have a password just leave it empty and select Open Wi-Fi network on the Encryption dropdown. Take care the SSID and Phrase can't be longer than 19 characters and they can't contain the $ symbol. Encryption - Optional You can leave it to WPA2 this is the default for most modern networks. External Antenna - Optional Is your SCK quite far away from Wi-Fi access point? You can use an external antenna with your SCK. Check the How to use an external antenna? ) Next step is optional, you can set your SCK update interval to optimize the battery performance and sensor resolution ratio. By default your SCK will take a reading every minute and post it on-line Reading interval - This defines every how much time your SCK sensors will take a reading and record it. You can set it from 1 minute to an hour. Number posts - This defines every how much sensor readings your SCK will publish the reading on-line. You can set it from 1 to 20. Now is time to record the settings on your SCK, just click on Sync Settings and wait for a moment. *If there is any issue during the process this will be displayed on the Message window above. I f you need help please contact support@smartcitizen.me * Last but now least you will see your SCK Mac Address registered below this is the ID of your SCK. Just click on Save and wait for your kit to publish. Done! You might need to wait up to 2 minutes or more if you changed the time update settings and refresh your browser in order to see your SCK first post in your device page. Did you registered your SCK before or did your SCK belong to someone else before? Take care your SCK can be registered once at a time, in case you registered before check How to unlink your SCK? or contact support@smartcitizen.me . Please, if your kit is not publishing properly contact support@smartcitizen.me or ask for help in the forum .","title":"Installing a Smart Smart Citizen Kit 1.0 / 1.1"},{"location":"Legacy Hardware/#manual-set-up-the-serial-way","text":"In this tutorial aimed to advanced users you will configure your SCK using serial communication. By using serial communication, you will register your Wi-Fi settings into the SCK and save the SCK\u2019s MAC address in our server. The SCK, like most Arduino chips, has the ability to communicate through serial protocol (when plugged with a proper USB cable). The SCK uses the WiFly module to communicate with your Wi-Fi router. Anyway, through serial communication you will be able to send the commands directly with this module to set your Wi-Fi settings and extract the MAC address used by our server to verify your identity. Note that this tutorial works for both SCK v1.0 (from the Goteo crowdfunding campaign) and SCK v1.1 (from the KickStarter crowdfunding campaign), independently of the firmware version used.","title":"Manual set up: The Serial Way"},{"location":"Legacy Hardware/#configuring-the-wi-fi-settings","text":"Open Arduino IDE. Connect your SCK via USB. From the Tools > Board menu, choose the right USB port (generally the last one). From the Tools > Serial port menu, select the right board. This is Leonardo for SCK v1.0 (Goteo) or LilyPad Arduino USB for SCK v1.1 (Kickstarter). Open the serial monitor window in the Arduino IDE (button at the top-right of the main window). Set the options to \"115200 baud\" and \u201cNo line return\u201d (drop-down menu at the bottom-right of the monitor window). Wake up the module and activate the Wi-Fi command mode by typing in the serial monitor: $$$ Change to \u201cCarriage return\u201d option (drop-down menu at the bottom-right of the monitor window) Add a new SSID to memory by typing: set wlan ssid XXX Note: You have to replace XXX with your ssid name, filling any space with the dollar ($) character. Due to hardware limitations it can't be longer than 32 characters. Add a new phrase to memory (optional, password for WPA1 & WPA2): set wlan phrase XXX Note: You have to replace XXX with your phrase, filling any space with the dollar ($) character. Add a new key to memory (optional, password for WEP & WEP64): set wlan key XXX Add an authentication method into memory (replace XXX by \u201c0\u201d for Open, \u201c1\u201d for WEP, \u201c2\u201d for WPA1, \u201c4\u201d for WPA2, \u201c8\u201d for WEP64): set wlan auth XXX Add an antenna type into memory (replace XXX by \u201c0\u201d to use the internal antenna or \u201c1\u201d if you use an external antenna): set wlan ext_antenna XXX Get the MAC address of the kit by typing: get mac Copy/Save the answer for further use. Exit and go back to the normal operational mode by typing: exit","title":"Configuring the Wi-Fi settings"},{"location":"Legacy Hardware/#registering-the-kit-in-the-platform","text":"After you've uploaded your settings, don't forget to register your kit in our database by saving it's mac address. To find the mac address, you can use the serial command \"get mac\". Or have a look at the wifi module on the board and read the serial number under the bar code (something like \"131G0006662116E4\" on kit v1.0 or \"0006662116E4\" on kit v.1.1). The mac address is the last 12 digit of this serial, separated by a colon every two number. From a number like 0006662116 E4 you would write 00 : 06 : 66 : 21 : 16 : E4 . In both cases, you have to fill the mac address input field in the configuration page of your kit and press the save button. You are now done with the manual configuration of your SCK. Wait for a few minutes to see your data coming on the server and being displayed on the web page. You can also check that everything is ok by looking at the Arduino serial monitor. Debug messages coming from your SCK should look like this: If you want to explore further options with the WiFly module check The SCK Command Line section. If you encounter any issue, please share your problem on the forum","title":"Registering the kit in the platform"},{"location":"Legacy Hardware/#manual-set-up-the-compilation-way","text":"This tutorial is aimed to advanced users, we will guide you through the process of setting up your kit by editing directly the source code. As the code is Open Source, one way of setting the Wi-Fi of your SCK is to download the latest firmware, edit some lines of code, recompile it and upload it to the kit. One advantage of this method is that it gives you the opportunity to register multiple Wi-Fi networks at the same time and make the persistent. The Wi-fi networks that you register directly in the source code are called hardcoded and the only way to remove them is with the same process of compiling and uploading the firmware again. This is useful if your SCK is traveling from one location to another where the Wi-Fi credentials are known. The downside of this method is that you can not extract the MAC address of your kit, if you don't know it yet you will have to use the method described in The Serial Way or via the configurator in the setup page of your kit.","title":"Manual set up: The Compilation Way"},{"location":"Legacy Hardware/#getting-the-firmware","text":"You can download the latest firmware on our Github: https://github.com/fablabbcn/Smart-Citizen-Kit/releases As you may know, the hardware and software are based on the Arduino project. We will use the Arduino IDE to edit the firmware and upload it to the kit. This tutorial have been tested with Arduino 1.6.8, please download and install the Arduino IDE . Once installed open the file Smart - Citizen - Kit / sck_beta_v0_9_0 / sck_beta_v0_9 . ino","title":"Getting the Firmware"},{"location":"Legacy Hardware/#editing-the-code","text":"If you want to set the network configuration manually, you should go to the Constants . h tab and modify the lines you see below: #define networks 0 #if (networks > 0) static char * mySSID [ networks ] = { \"SSID1\" , \"SSID2\" }; static char * myPassword [ networks ] = { \"PASS1\" , \"PASS2\" }; static char * wifiEncript [ networks ] = { WPA2 , WPA2 }; static char * antennaExt [ networks ] = { INT_ANT , INT_ANT }; #endif The easiest way would be to write \"#define networks X\" (where X is the number of WI-FI networks you are going to use) and fill the options for your network: Add the name of your network in SSIDX and the corresponding password in PASSX . Due to hardware limitations neither the password or the ssid can't be longer tham 32 characters. On wifiEncript you could also choose the encryption mode that fits with your network's configuration ( OPEN , WEP , WPA1 , WPA2 , WEP64 ). On antennaExt you can choose the type of antenna you are using ( INT_ANT for internal antenna (default) or EXT_ANT for external antenna). If you register only one wifi credential, you should obtain something like this: #define networks 1 #if (networks > 0) char * mySSID [ networks ] = { \"MyWifiSSID\" }; char * myPassword [ networks ] = { \"MyPassword\" }; char * wifiEncript [ networks ] = { WPA2 }; char * antennaExt [ networks ] = { INT_ANT }; #endif Note that if you configure more than one Wi-fi network you have to separate the variables with a comma, for example: char * mySSID [ networks ] = { \"MyFirstSSID\" , \"MySecondSSID\" };","title":"Editing the code"},{"location":"Legacy Hardware/#uploading-the-code","text":"On the Arduino IDE Tools menu you should select the right Board in the Boards menu: For SmartSmart Citizen Kit version 1.0 select Arduino Leonardo (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Arduino LilyPad USB (ATmega 32U4 at 8Mhz) The Arduino IDE should automatically select the right USB port but you can check it in the Tools >> Port menu. Now you just need to click the Upload button and Arduino will do the rest for you! In case you have any issue please check the Arduino Troubleshooting guide.","title":"Uploading the code"},{"location":"Legacy Hardware/#registering-the-kit-in-the-platform_1","text":"After you\u2019ve uploaded your settings, don\u2019t forget to register your kit in our database by saving it\u2019s mac address. To find the mac address, you can use the serial command \u201cget mac\u201d by following the section The Serial Way . Or have a look at the wifi module on the board and read the serial number under the bar code (something like \u201c131G0006662116E4\u201d on kit v1.0 or \u201c0006662116E4\u201d on kit v.1.1). The mac address is the last 12 digit of this serial, separated by a colon every two number. From a number like 0006662116 E4 you would write 00 : 06 : 66 : 21 : 16 : E4 . In both cases, you have to fill the mac address input field in the configuration page of your kit and press the save button. You are now done with the manual configuration of your SCK. Wait for a few minutes to see your data coming on the server and being displayed on the web page. You can also check that everything is ok by looking the output of your kit via the Arduino serial monitor. If you encounter any issue, please share your problem on the forum","title":"Registering the kit in the platform"},{"location":"Legacy Hardware/#attaching-the-solar-panel","text":"The solar panel should fulfill the specification of a voltage bigger than 8v and less than 15v, 12v is the recommended voltage, and a minimum of 500mA. In order to attach the solar panel you have to solder the cables of the solar panel to the pads marked in the next image for version 1.0 of the SCK. For version 1.1 you have to connect the cables to the connector marked in the next image. In both versions, yo have to attach the plus of solar panel to the plus pad of the SCK, and the minus of the solar panel to the minus pad of the SCK.","title":"Attaching the solar panel"},{"location":"Legacy Hardware/Command Line/","text":"SCK Command Line Link The Smart Smart Citizen Kit can be managed over a basic serial protocol. You just need the Arduino IDE Serial Monitor or any other Serial Utility like Screen in order to use it. How to use it Connect to your kit using any serial utility, any baud-rate should work but 115200 is recommendable. Send the starting commands. Notice all the commands except the starting command($$$) require a carriage return at the end: CR or \\r. If you are using the Arduino IDE is enough if you change to \u201cCarriage return\u201d option (drop-down menu at the bottom-right of the monitor window). Call any command you want, change XXX with the corresponding value, filling any space with the dollar ($) character. SCK Wifly commands Link $$$ (Wake up the module and activate the Wi-Fi) set wlan ssid XXX (Add a new SSID to memory9) set wlan phrase XXX (Add a new phrase to memory) set wlan key XXX (Add a new key to memory) set wlan auth XXX (Add an authentication method into memory) set wlan ext_antenna XXX (Add an antenna type into memory) exit (Go back to normal operational mode) If you want to know more about wifly commands look at the WiFly Command Reference SCK commands Link ### (Wake up the module and enter SCK commands mode) get mac (Get the MAC address of the kit) get time update (Retrieve the sensor update interval) set time update XXX (Update the sensor update interval, 10-3600 sec ) get number updates (Retrieve the max number of bulk updates) set number updates XXX (Update the max number of bulk updates, 1-20 updates ) get apikey (Retrieve the kit APIKEY) set apikey XXX (Update the kit APIKEY) get wlan ssid (Retrieve the SSID saved on the kit) get wlan phrase (Retrieve the phrase and KEY saved on the kit) get wlan auth (Retrieve the authentication method saved on the kit) get wlan ext_antenna (Retrieve the antenna type saved on the kit) clear nets (Remove all saved Wi-Fi configuration information) clear memory (Reset to defaults all configuration information) get all (Retrieve all settings saved on the kit in a single line: |version|MAC|ssid,phrase,auth,ext_antenna|hardcodedNets|timeUpdate|numUpdate| ) data (Retrieves sensor readings stored in memory) exit (Goes back to normal operational mode)","title":"Command Line"},{"location":"Legacy Hardware/Command Line/#sck-command-line","text":"The Smart Smart Citizen Kit can be managed over a basic serial protocol. You just need the Arduino IDE Serial Monitor or any other Serial Utility like Screen in order to use it. How to use it Connect to your kit using any serial utility, any baud-rate should work but 115200 is recommendable. Send the starting commands. Notice all the commands except the starting command($$$) require a carriage return at the end: CR or \\r. If you are using the Arduino IDE is enough if you change to \u201cCarriage return\u201d option (drop-down menu at the bottom-right of the monitor window). Call any command you want, change XXX with the corresponding value, filling any space with the dollar ($) character.","title":"SCK Command Line"},{"location":"Legacy Hardware/Command Line/#sck-wifly-commands","text":"$$$ (Wake up the module and activate the Wi-Fi) set wlan ssid XXX (Add a new SSID to memory9) set wlan phrase XXX (Add a new phrase to memory) set wlan key XXX (Add a new key to memory) set wlan auth XXX (Add an authentication method into memory) set wlan ext_antenna XXX (Add an antenna type into memory) exit (Go back to normal operational mode) If you want to know more about wifly commands look at the WiFly Command Reference","title":"SCK Wifly commands"},{"location":"Legacy Hardware/Command Line/#sck-commands","text":"### (Wake up the module and enter SCK commands mode) get mac (Get the MAC address of the kit) get time update (Retrieve the sensor update interval) set time update XXX (Update the sensor update interval, 10-3600 sec ) get number updates (Retrieve the max number of bulk updates) set number updates XXX (Update the max number of bulk updates, 1-20 updates ) get apikey (Retrieve the kit APIKEY) set apikey XXX (Update the kit APIKEY) get wlan ssid (Retrieve the SSID saved on the kit) get wlan phrase (Retrieve the phrase and KEY saved on the kit) get wlan auth (Retrieve the authentication method saved on the kit) get wlan ext_antenna (Retrieve the antenna type saved on the kit) clear nets (Remove all saved Wi-Fi configuration information) clear memory (Reset to defaults all configuration information) get all (Retrieve all settings saved on the kit in a single line: |version|MAC|ssid,phrase,auth,ext_antenna|hardcodedNets|timeUpdate|numUpdate| ) data (Retrieves sensor readings stored in memory) exit (Goes back to normal operational mode)","title":"SCK commands"},{"location":"Legacy Hardware/Faq/","text":"FAQ Link How do I register again my SCK? Link It is really important to understand a SCK can be just registered one time to one device in the platform. Imagine how confusing it will be a single physical device publishing as two separate kits on the platform in two different locations! That's why you will need to unlink your SCK before you can register it again as another kit or when you would like to give your device to someone else to use it. Go to your Kits profile page select the kit you will like to unlink and go to Setup . You don't need to connect your SCK, just scroll down, remove the Mad Address number from the field and click Save . This way your kit will keep all the data on the platform but you will be able to register your SCK again as another kit. You can alway register again your SCK on the same device by following the standard setup process. Is my home wireless internet going to work with the SCK? Link The Smart Smart Citizen Kit is designed to work with most home and office standard Wi-Fi routers and access points. However we do not support network names or passwords longer than 19 characters or with a $ character. We also do not support WPA Enterprise networks or Captive portal log in as the ones on some big companies and airports. We suggest you contact your IT support team, they can enable you special access in the network based on your device Mac Address . How to use the SD Card? Link microSD : We recommend formatting micro SD cards using the official SD tool you can download here . RTC : Place a CR1220 cell battery on your kit. Before uploading the SD firmware use the on-line configuration tool at smartcitizen.me to set your Wi-Fi credentials. Turn your kit off and on for a minute, the blue led's will blink and your kit will connect to the internet and sync its the internal clock with our remote servers. Once the time is set the cell battery will keep SCK time in sync for more than 4 years. You can now install the SD firmware using the Arduino IDE . Dependencies: In order to compile and upload the firmware you will need to install the SdFat library for Arduino. Download the library here and install the library following the instructions . Boards: For SmartSmart Citizen Kit version 1.0 select Tools / Boards / Arduino Leonardo on the Arduino IDE (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Tools / Boards / Lylipad Arduino USB on the Arduino IDE (ATmega 32U4 at 8Mhz) SD data format When using the SD firmware on the SCK, data is stored as CSV ( comma separated ) file on the SD card. This is an example of the output file once opened on a spreadsheet application: Temperature Humidity Light Battery Solar Panel CO NO2 Noise UTC 2821.20 4072.00 4413.10 96.40 0.00 94.67 0.65 5.23 2000-01-01 00:00:02 2784.40 4236.80 5936.70 96.10 0.00 278.27 1.05 2.39 2000-01-01 00:00:02 Data Conversions The data stored is automatically converted to the proper units in firmware. If you prefer to do the conversions manually set DataRaw false in the Constants . h file and apply the formulas on the following table: ID Sensor Units Conversion Formula 0 Temperature \u00baC T = -53 + 175.72 / 65536.0 * ( Traw * 10 ) 1 Humidity %Rel H = 7 + 125.0 / 65536.0 * ( Hraw * 10 ) 2 Light Lux L = Lraw / 10 3 Battery % Not required 4 Panel mV Not required 5 CO kOhm Not required 6 NO2 kOhm Not required 7 Noise dB Apply the conversion table from mV to dB: CSV 8 Date DD:MM:YY Not required 9 Time hh ss Not required How to import the SD card data? Link Sorry, this is temporary disabled! We are working on a new release. You can import the recorded data in to smartcitizen.me In your device page you will find the Import SD along with the Edit and Configure options. Using a microSD card reader get the post.csv file from your card, select it and click import. Data will be imported in to your device, data existing on the file already imported will be skipped. Your kit should be running the latest SD firmware and the SCK time (RTC) should be set in order data can be imported. Is my kit publishing data properly? Link Sorry, this is temporary disabled! We are working on a new release. You can easily check each time your kit is publishing data to our platform in real time by enabling the debug mode on your device. Go to your device edit page in smartcitizen.me , set Debug Enabled and save it. Visit data.smartcitizen.me/debug you will see the data from all the devices on debug mode every time they publish in real time. You can identify your device by the device id. **Note data comes uncalibrated.* How to retrieve other kit's data? Link Current API allows you full access to all the Smart Citizen Platform. Please, ask in the forum or contact support@smartcitizen.me for any questions regarding the API. How to store data in your own database? Link Kit's request The Smart Smart Citizen Kit is publishing by default the data as a PUT Http request, the sensor data is encoded as JSON. Here you can see how a kit's request will look like (Note the request is not standard as it do not contains a payload) : PUT /add HTTP/1.1 Host: data.smartcitizen.me User-Agent: SmartCitizen X-SmartCitizenMacADDR: 00 :00:00:00:00:00 X-SmartCitizenVersion: 1 .1-0.8.5-A X-SmartCitizenData: [{ \"temp\" : \"29090.6\" , \"hum\" : \"6815.74\" , \"light\" : \"30000\" , \"bat\" : \"786\" , \"panel\" : \"0\" , \"co\" : \"112500\" , \"no2\" : \"200000\" , \"noise\" : \"2\" , \"nets\" : \"10\" , \"timestamp\" : \"2013-10-28 1:34:26\" }] Here you have a kit's request as a Curl for test purposes: $ curl -X PUT -H 'Host: data.smartcitizen.me' -H 'User-Agent: SmartCitizen' -H 'X-SmartCitizenMacADDR: 00:00:00:00:00:00' -H 'X-SmartCitizenVersion: 1.1-0.8.5-A' -H 'X-SmartCitizenData: [{\"temp\":\"29090.6\", \"hum\":\"6815.74\", \"light\":\"30000\", \"bat\":\"786\", \"panel\":\"0\", \"co\":\"112500\", \"no2\":\"200000\", \"noise\":\"2\", \"nets\":\"10\", \"timestamp\":\"2013-10-28 1:34:26\"}]' data.smartcitizen.me/add Data processing Values are send without the proper scaling and some sensors as temperature, humidity and noise are sent in raw and then calibrated in our platform. This are the conversion required for SCK 1.1 and above. Key Sensor Units Conversion formula Conversion Method temp Temperature \u00baC T = -53 + 175.72 / 65536.0 * Traw SCKSensorData::tempConversion($rawTemp) hum Humidity %Rel H = 7 + 125.0 / 65536.0 * Hraw SCKSensorData::humConversion($rawHum) light Light Lux L = Lraw / 10 SCKSensorData::lightConversion($rawLight) noise Noise dB Apply the conversion table from mV to dB: CSV SCKSensorData::noiseConversion($rawNoise) co CO kOhm CO = COraw / 10000 SCKSensorData::coConversion($rawCO) no2 NO2 kOhm NO2 = NO2raw / 10000 SCKSensorData::no2Conversion($rawNO2) bat Battery % B = Braw / 10 SCKSensorData::batConversion($rawBat) panel Panel mV P = Praw / 10000 SCKSensorData::panelConversion($rawPanel) nets Nets Wi-Fi Networks Not required Not required timestamp Timestamp YYYY-MM-DD hh ss Not required Not required You can use the SCKSensorData php class to re-scale and calibrate the received data. Check it on github . Here is an example how to use it to receive a request, converted and store it in a CSV file: <?php include ( '../sck_sensor_data.php' ); $headers = getallheaders (); $data = $headers [ 'X-SmartCitizenData' ]; $datapoints = json_decode ( $data , true ); foreach ( $datapoints as $datapoint ) { $datapoint = SCKSensorData :: SCK11Convert ( $datapoint ); $csv .= implode ( ', ' , $datapoint ); } $csv .= PHP_EOL ; file_put_contents ( './data.csv' , $csv , FILE_APPEND ); ?> You can find the complete example here . Each sensor is implemented as a separate function and some general methods are available for simplifying the work. Here is an example: <?php /** * noiseCalibration * * Noise calibration for SCK1.1 sound sensor. Converts mV in to dBs. * Based on a linear regression from a lookup table (db.json) * obtained after real measurements from our test facility. * * * @param float $rawSound * @return float noise as sound pressure in dB * */ public function noiseCalibration ( $rawSound ) { $dbTable = json_decode ( file_get_contents ( \"db.json\" ), true ); return round ( self :: tableCalibration ( $dbTable , $rawSound ), 2 ); } ?> How to proceed Here are the different paths you can take in order to built your own backend: Create a fork of the the Smart Smart Citizen Kit firmware in order to send the data as your custom backend expect it. Create your own custom backend. We can share all the different modules of our backend in order for you to receive data as on the curl example above, calibrate it and store it. Contact us at support@smartcitizen.me . Keep using our backend but request our API developer.smartcitizen.me and then fill database choosen with it. How to install the drivers on Windows? Link In Windows you will need to install the Arduino Drivers if you haven't done it before. Windows 8, 7, Vista, and XP Link Go to the Arduino download page and download the latest version of the Arduino software for Windows. When the download is finished, un-zip it and open up the Arduino folder to confirm that yes, there are indeed some files and sub-folders inside. The file structure is important so don\u2019t be moving any files around unless you really know what you\u2019re doing. Power up your Smart Smart Citizen Kit by connecting it to your computer with a USB cable. You should see the green LED near the on/off switch light up. If you\u2019re running Windows 8, you\u2019ll need to disable driver signing, so go see the Windows 8 section. If you\u2019re running Windows 7, Vista, or XP, you\u2019ll need to install some drivers, so head to the Windows 7, Vista, and XP section down below. Windows 8 Link Windows 8 comes with a nice little security \u2018feature\u2019 that \u2018protects\u2019 you from unsigned driver installation. The Smart Smart Citizen Kit driver is not signed so you\u2019ll have to tell Windows to disable driver signing. This issue has been addressed in newer releases of the Arduino IDE, but if you run into issues, you can try this fix first. For a nice, step-by-step tutorial with pictures click here , otherwise the steps are outlined below. To temporarily disable driver signing: From the Metro Start Screen, open Settings (move your mouse to the bottom-right-corner of the screen and wait for the pop-out bar to appear, then click the Gear icon) Click \u2018More PC Settings\u2019 Click \u2018General\u2019 Scroll down, and click \u2018Restart now\u2019 under \u2018Advanced startup\u2019. Wait a bit. Click \u2018Troubleshoot\u2019. Click \u2018Advanced Options\u2019 Click \u2018Windows Startup Settings\u2019 Click Restart. When your computer restarts, select \u2018Disable driver signature enforcement\u2018 from the list. To permanently disable driver signing (recommended, but has some minor security implications): Go to the metro start screen Type in \u201ccmd\u201d Right click \u201cCommand Prompt\u201d and select \u201cRun as Administrator\u201d from the buttons on the bottom of your screen Type/paste in the following commands: bcdedit -set loadoptions DISABLE_INTEGRITY_CHECKS bcdedit -set TESTSIGNING ON Reboot! Windows 7, Vista, and XP Link Installing the Drivers for the Arduino Uno (from Arduino.cc) Plug in your board and wait for Windows to begin it\u2019s driver installation process After a few moments, the process will fail, despite its best efforts Click on the Start Menu, and open up the Control Panel While in the Control Panel, navigate to System and Security. Next, click on System Once the System window is up, open the Device Manager Look under Ports (COM & LPT). You should see an open port named \u201cArduino UNO (COMxx)\u201d. If there is no COM & LPT section, look under \u2018Other Devices\u2019 for \u2018Unknown Device\u2019 Right click on the \u201cArduino UNO (COMxx)\u201d or \u201cUnknown Device\u201d port and choose the \u201cUpdate Driver Software\u201d option Next, choose the \u201cBrowse my computer for Driver software\u201d option Finally, navigate to and select the Uno\u2019s driver file, named \u201cArduinoUNO.inf\u201d, located in the \u201cDrivers\u201d folder of the Arduino Software download (not the \u201cFTDI USB Drivers\u201d sub-directory). If you cannot see the .inf file, it is probably just hidden. You can select the \u2018drivers\u2019 folder with the \u2018search sub-folders\u2019 option selected instead. Windows will finish up the driver installation from there This documentation is proudly based on Sparkfun Arduino on Windows tutorial - CC BY-NC-SA 3.0. Which LiPo batteries to use? Link The battery that we are providing is 3.7v and 2000mAh Which solar panels to use? Link The solar panel it should fulfill the specification of a voltage bigger than 8v and less than 15v, 12v is the recommended voltage, and a minimum of 500mA. How I can extend the Wi-Fi range? Link Is your SCK quite far away from Wi-Fi access point? You can use an external antenna with your SCK. The Wi-Fi modules has a U.FL antenna connector. We recommend you to use a U.FL to RP-SMA adaptor in order to use standard Wi-Fi antennas . You then will need to enable the External Antenna on the Wi-Fi setup process by selecting External Antenna . What is the spec (battery type) for the button-cell for the RTC? Link The RTC battery is a CR1220 Why is 50dB the microphone lowest value? Link Because the actual sensor is limited by the curve bounding from 50dB to 103dB Browsers compatibility Link The SmartCitizen platform is built using the latest Web technologies (such as HTML5, SVG and CSS3). These languages serve as a foundation for today\u2019s websites and web applications. To enjoy Smart Citizen, we recommend you to use: Google Chrome 25+ Firefox Mozilla 20+ For the kit setup process only Google Chrome is supported. What are the LEDs for, and what does the LED blinking mean? Link There are 5 LEDs, they are all on the base half of the SCK. They can be understood in three groups: LED2 and LED1 - These are the two yellow (or orange) LEDs in the lower center-left of the board. You will only see these lit when your USB cable is connected to the SCK and you are configuring or otherwise interacting with the SCK. LED2 is the \"RX USB\" and will be lit when the SCK is receiving information via the USB connection. LED1 is the \"TX USB\" and will be lit when the SCK is sending information via the USB connection. LED4 and LED3 - These are the two blue LEDs in the lower center of the board. You will see these blink often. LED3 is the \"WiFi Association\" and LED4 is the \"WiFi Connection.\" The blue LEDs will blink each time the SCK posts new data wirelessly. This is normal behavior and is expected, but it only happens in bursts (then there will be no blue LED lit for about 30-40 seconds). If your blue LEDs are blinking back and forth non-stop, this means your SCK has lost its WiFi connection. Check to make sure your router is still on, and that you're still in range of it. LED5 - This is the green LED in the upper left corner. It will be lit when the SCK is turned on and has power.","title":"Faq"},{"location":"Legacy Hardware/Faq/#faq","text":"","title":"FAQ"},{"location":"Legacy Hardware/Faq/#how-do-i-register-again-my-sck","text":"It is really important to understand a SCK can be just registered one time to one device in the platform. Imagine how confusing it will be a single physical device publishing as two separate kits on the platform in two different locations! That's why you will need to unlink your SCK before you can register it again as another kit or when you would like to give your device to someone else to use it. Go to your Kits profile page select the kit you will like to unlink and go to Setup . You don't need to connect your SCK, just scroll down, remove the Mad Address number from the field and click Save . This way your kit will keep all the data on the platform but you will be able to register your SCK again as another kit. You can alway register again your SCK on the same device by following the standard setup process.","title":"How do I register again my SCK?"},{"location":"Legacy Hardware/Faq/#is-my-home-wireless-internet-going-to-work-with-the-sck","text":"The Smart Smart Citizen Kit is designed to work with most home and office standard Wi-Fi routers and access points. However we do not support network names or passwords longer than 19 characters or with a $ character. We also do not support WPA Enterprise networks or Captive portal log in as the ones on some big companies and airports. We suggest you contact your IT support team, they can enable you special access in the network based on your device Mac Address .","title":"Is my home wireless internet going to work with the SCK?"},{"location":"Legacy Hardware/Faq/#how-to-use-the-sd-card","text":"microSD : We recommend formatting micro SD cards using the official SD tool you can download here . RTC : Place a CR1220 cell battery on your kit. Before uploading the SD firmware use the on-line configuration tool at smartcitizen.me to set your Wi-Fi credentials. Turn your kit off and on for a minute, the blue led's will blink and your kit will connect to the internet and sync its the internal clock with our remote servers. Once the time is set the cell battery will keep SCK time in sync for more than 4 years. You can now install the SD firmware using the Arduino IDE . Dependencies: In order to compile and upload the firmware you will need to install the SdFat library for Arduino. Download the library here and install the library following the instructions . Boards: For SmartSmart Citizen Kit version 1.0 select Tools / Boards / Arduino Leonardo on the Arduino IDE (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Tools / Boards / Lylipad Arduino USB on the Arduino IDE (ATmega 32U4 at 8Mhz) SD data format When using the SD firmware on the SCK, data is stored as CSV ( comma separated ) file on the SD card. This is an example of the output file once opened on a spreadsheet application: Temperature Humidity Light Battery Solar Panel CO NO2 Noise UTC 2821.20 4072.00 4413.10 96.40 0.00 94.67 0.65 5.23 2000-01-01 00:00:02 2784.40 4236.80 5936.70 96.10 0.00 278.27 1.05 2.39 2000-01-01 00:00:02 Data Conversions The data stored is automatically converted to the proper units in firmware. If you prefer to do the conversions manually set DataRaw false in the Constants . h file and apply the formulas on the following table: ID Sensor Units Conversion Formula 0 Temperature \u00baC T = -53 + 175.72 / 65536.0 * ( Traw * 10 ) 1 Humidity %Rel H = 7 + 125.0 / 65536.0 * ( Hraw * 10 ) 2 Light Lux L = Lraw / 10 3 Battery % Not required 4 Panel mV Not required 5 CO kOhm Not required 6 NO2 kOhm Not required 7 Noise dB Apply the conversion table from mV to dB: CSV 8 Date DD:MM:YY Not required 9 Time hh ss Not required","title":"How to use the SD Card?"},{"location":"Legacy Hardware/Faq/#how-to-import-the-sd-card-data","text":"Sorry, this is temporary disabled! We are working on a new release. You can import the recorded data in to smartcitizen.me In your device page you will find the Import SD along with the Edit and Configure options. Using a microSD card reader get the post.csv file from your card, select it and click import. Data will be imported in to your device, data existing on the file already imported will be skipped. Your kit should be running the latest SD firmware and the SCK time (RTC) should be set in order data can be imported.","title":"How to import the SD card data?"},{"location":"Legacy Hardware/Faq/#is-my-kit-publishing-data-properly","text":"Sorry, this is temporary disabled! We are working on a new release. You can easily check each time your kit is publishing data to our platform in real time by enabling the debug mode on your device. Go to your device edit page in smartcitizen.me , set Debug Enabled and save it. Visit data.smartcitizen.me/debug you will see the data from all the devices on debug mode every time they publish in real time. You can identify your device by the device id. **Note data comes uncalibrated.*","title":"Is my kit publishing data properly?"},{"location":"Legacy Hardware/Faq/#how-to-retrieve-other-kits-data","text":"Current API allows you full access to all the Smart Citizen Platform. Please, ask in the forum or contact support@smartcitizen.me for any questions regarding the API.","title":"How to retrieve other kit's data?"},{"location":"Legacy Hardware/Faq/#how-to-store-data-in-your-own-database","text":"Kit's request The Smart Smart Citizen Kit is publishing by default the data as a PUT Http request, the sensor data is encoded as JSON. Here you can see how a kit's request will look like (Note the request is not standard as it do not contains a payload) : PUT /add HTTP/1.1 Host: data.smartcitizen.me User-Agent: SmartCitizen X-SmartCitizenMacADDR: 00 :00:00:00:00:00 X-SmartCitizenVersion: 1 .1-0.8.5-A X-SmartCitizenData: [{ \"temp\" : \"29090.6\" , \"hum\" : \"6815.74\" , \"light\" : \"30000\" , \"bat\" : \"786\" , \"panel\" : \"0\" , \"co\" : \"112500\" , \"no2\" : \"200000\" , \"noise\" : \"2\" , \"nets\" : \"10\" , \"timestamp\" : \"2013-10-28 1:34:26\" }] Here you have a kit's request as a Curl for test purposes: $ curl -X PUT -H 'Host: data.smartcitizen.me' -H 'User-Agent: SmartCitizen' -H 'X-SmartCitizenMacADDR: 00:00:00:00:00:00' -H 'X-SmartCitizenVersion: 1.1-0.8.5-A' -H 'X-SmartCitizenData: [{\"temp\":\"29090.6\", \"hum\":\"6815.74\", \"light\":\"30000\", \"bat\":\"786\", \"panel\":\"0\", \"co\":\"112500\", \"no2\":\"200000\", \"noise\":\"2\", \"nets\":\"10\", \"timestamp\":\"2013-10-28 1:34:26\"}]' data.smartcitizen.me/add Data processing Values are send without the proper scaling and some sensors as temperature, humidity and noise are sent in raw and then calibrated in our platform. This are the conversion required for SCK 1.1 and above. Key Sensor Units Conversion formula Conversion Method temp Temperature \u00baC T = -53 + 175.72 / 65536.0 * Traw SCKSensorData::tempConversion($rawTemp) hum Humidity %Rel H = 7 + 125.0 / 65536.0 * Hraw SCKSensorData::humConversion($rawHum) light Light Lux L = Lraw / 10 SCKSensorData::lightConversion($rawLight) noise Noise dB Apply the conversion table from mV to dB: CSV SCKSensorData::noiseConversion($rawNoise) co CO kOhm CO = COraw / 10000 SCKSensorData::coConversion($rawCO) no2 NO2 kOhm NO2 = NO2raw / 10000 SCKSensorData::no2Conversion($rawNO2) bat Battery % B = Braw / 10 SCKSensorData::batConversion($rawBat) panel Panel mV P = Praw / 10000 SCKSensorData::panelConversion($rawPanel) nets Nets Wi-Fi Networks Not required Not required timestamp Timestamp YYYY-MM-DD hh ss Not required Not required You can use the SCKSensorData php class to re-scale and calibrate the received data. Check it on github . Here is an example how to use it to receive a request, converted and store it in a CSV file: <?php include ( '../sck_sensor_data.php' ); $headers = getallheaders (); $data = $headers [ 'X-SmartCitizenData' ]; $datapoints = json_decode ( $data , true ); foreach ( $datapoints as $datapoint ) { $datapoint = SCKSensorData :: SCK11Convert ( $datapoint ); $csv .= implode ( ', ' , $datapoint ); } $csv .= PHP_EOL ; file_put_contents ( './data.csv' , $csv , FILE_APPEND ); ?> You can find the complete example here . Each sensor is implemented as a separate function and some general methods are available for simplifying the work. Here is an example: <?php /** * noiseCalibration * * Noise calibration for SCK1.1 sound sensor. Converts mV in to dBs. * Based on a linear regression from a lookup table (db.json) * obtained after real measurements from our test facility. * * * @param float $rawSound * @return float noise as sound pressure in dB * */ public function noiseCalibration ( $rawSound ) { $dbTable = json_decode ( file_get_contents ( \"db.json\" ), true ); return round ( self :: tableCalibration ( $dbTable , $rawSound ), 2 ); } ?> How to proceed Here are the different paths you can take in order to built your own backend: Create a fork of the the Smart Smart Citizen Kit firmware in order to send the data as your custom backend expect it. Create your own custom backend. We can share all the different modules of our backend in order for you to receive data as on the curl example above, calibrate it and store it. Contact us at support@smartcitizen.me . Keep using our backend but request our API developer.smartcitizen.me and then fill database choosen with it.","title":"How to store data in your own database?"},{"location":"Legacy Hardware/Faq/#how-to-install-the-drivers-on-windows","text":"In Windows you will need to install the Arduino Drivers if you haven't done it before.","title":"How to install the drivers on Windows?"},{"location":"Legacy Hardware/Faq/#windows-8-7-vista-and-xp","text":"Go to the Arduino download page and download the latest version of the Arduino software for Windows. When the download is finished, un-zip it and open up the Arduino folder to confirm that yes, there are indeed some files and sub-folders inside. The file structure is important so don\u2019t be moving any files around unless you really know what you\u2019re doing. Power up your Smart Smart Citizen Kit by connecting it to your computer with a USB cable. You should see the green LED near the on/off switch light up. If you\u2019re running Windows 8, you\u2019ll need to disable driver signing, so go see the Windows 8 section. If you\u2019re running Windows 7, Vista, or XP, you\u2019ll need to install some drivers, so head to the Windows 7, Vista, and XP section down below.","title":"Windows 8, 7, Vista, and XP"},{"location":"Legacy Hardware/Faq/#windows-8","text":"Windows 8 comes with a nice little security \u2018feature\u2019 that \u2018protects\u2019 you from unsigned driver installation. The Smart Smart Citizen Kit driver is not signed so you\u2019ll have to tell Windows to disable driver signing. This issue has been addressed in newer releases of the Arduino IDE, but if you run into issues, you can try this fix first. For a nice, step-by-step tutorial with pictures click here , otherwise the steps are outlined below. To temporarily disable driver signing: From the Metro Start Screen, open Settings (move your mouse to the bottom-right-corner of the screen and wait for the pop-out bar to appear, then click the Gear icon) Click \u2018More PC Settings\u2019 Click \u2018General\u2019 Scroll down, and click \u2018Restart now\u2019 under \u2018Advanced startup\u2019. Wait a bit. Click \u2018Troubleshoot\u2019. Click \u2018Advanced Options\u2019 Click \u2018Windows Startup Settings\u2019 Click Restart. When your computer restarts, select \u2018Disable driver signature enforcement\u2018 from the list. To permanently disable driver signing (recommended, but has some minor security implications): Go to the metro start screen Type in \u201ccmd\u201d Right click \u201cCommand Prompt\u201d and select \u201cRun as Administrator\u201d from the buttons on the bottom of your screen Type/paste in the following commands: bcdedit -set loadoptions DISABLE_INTEGRITY_CHECKS bcdedit -set TESTSIGNING ON Reboot!","title":"Windows 8"},{"location":"Legacy Hardware/Faq/#windows-7-vista-and-xp","text":"Installing the Drivers for the Arduino Uno (from Arduino.cc) Plug in your board and wait for Windows to begin it\u2019s driver installation process After a few moments, the process will fail, despite its best efforts Click on the Start Menu, and open up the Control Panel While in the Control Panel, navigate to System and Security. Next, click on System Once the System window is up, open the Device Manager Look under Ports (COM & LPT). You should see an open port named \u201cArduino UNO (COMxx)\u201d. If there is no COM & LPT section, look under \u2018Other Devices\u2019 for \u2018Unknown Device\u2019 Right click on the \u201cArduino UNO (COMxx)\u201d or \u201cUnknown Device\u201d port and choose the \u201cUpdate Driver Software\u201d option Next, choose the \u201cBrowse my computer for Driver software\u201d option Finally, navigate to and select the Uno\u2019s driver file, named \u201cArduinoUNO.inf\u201d, located in the \u201cDrivers\u201d folder of the Arduino Software download (not the \u201cFTDI USB Drivers\u201d sub-directory). If you cannot see the .inf file, it is probably just hidden. You can select the \u2018drivers\u2019 folder with the \u2018search sub-folders\u2019 option selected instead. Windows will finish up the driver installation from there This documentation is proudly based on Sparkfun Arduino on Windows tutorial - CC BY-NC-SA 3.0.","title":"Windows 7, Vista, and XP"},{"location":"Legacy Hardware/Faq/#which-lipo-batteries-to-use","text":"The battery that we are providing is 3.7v and 2000mAh","title":"Which LiPo batteries to use?"},{"location":"Legacy Hardware/Faq/#which-solar-panels-to-use","text":"The solar panel it should fulfill the specification of a voltage bigger than 8v and less than 15v, 12v is the recommended voltage, and a minimum of 500mA.","title":"Which solar panels to use?"},{"location":"Legacy Hardware/Faq/#how-i-can-extend-the-wi-fi-range","text":"Is your SCK quite far away from Wi-Fi access point? You can use an external antenna with your SCK. The Wi-Fi modules has a U.FL antenna connector. We recommend you to use a U.FL to RP-SMA adaptor in order to use standard Wi-Fi antennas . You then will need to enable the External Antenna on the Wi-Fi setup process by selecting External Antenna .","title":"How I can extend the Wi-Fi range?"},{"location":"Legacy Hardware/Faq/#what-is-the-spec-battery-type-for-the-button-cell-for-the-rtc","text":"The RTC battery is a CR1220","title":"What is the spec (battery type) for the button-cell for the RTC?"},{"location":"Legacy Hardware/Faq/#why-is-50db-the-microphone-lowest-value","text":"Because the actual sensor is limited by the curve bounding from 50dB to 103dB","title":"Why is 50dB the microphone lowest value?"},{"location":"Legacy Hardware/Faq/#browsers-compatibility","text":"The SmartCitizen platform is built using the latest Web technologies (such as HTML5, SVG and CSS3). These languages serve as a foundation for today\u2019s websites and web applications. To enjoy Smart Citizen, we recommend you to use: Google Chrome 25+ Firefox Mozilla 20+ For the kit setup process only Google Chrome is supported.","title":"Browsers compatibility"},{"location":"Legacy Hardware/Faq/#what-are-the-leds-for-and-what-does-the-led-blinking-mean","text":"There are 5 LEDs, they are all on the base half of the SCK. They can be understood in three groups: LED2 and LED1 - These are the two yellow (or orange) LEDs in the lower center-left of the board. You will only see these lit when your USB cable is connected to the SCK and you are configuring or otherwise interacting with the SCK. LED2 is the \"RX USB\" and will be lit when the SCK is receiving information via the USB connection. LED1 is the \"TX USB\" and will be lit when the SCK is sending information via the USB connection. LED4 and LED3 - These are the two blue LEDs in the lower center of the board. You will see these blink often. LED3 is the \"WiFi Association\" and LED4 is the \"WiFi Connection.\" The blue LEDs will blink each time the SCK posts new data wirelessly. This is normal behavior and is expected, but it only happens in bursts (then there will be no blue LED lit for about 30-40 seconds). If your blue LEDs are blinking back and forth non-stop, this means your SCK has lost its WiFi connection. Check to make sure your router is still on, and that you're still in range of it. LED5 - This is the green LED in the upper left corner. It will be lit when the SCK is turned on and has power.","title":"What are the LEDs for, and what does the LED blinking mean?"},{"location":"Legacy Hardware/Hardware/","text":"Hardware Link Inside the SCK Link Main Board Link The main board contains the basic functionality like sensor I/O to read de sensor values, communication with the platform through the wifi module, manage the power and battery charging. PINOUT Link The SCK Main Board connects to the Sensor Board 16 pin connector. This is how the pins are laid out on the board. The numbers in brackets are the actual pin numbers of the micro controller. Pins IO are digital and S are analogue. GND GND IO3 (10) IO2 (9) IO1 (13) IO0 (5) SCL SDA S5 (A1) S4 (A0) S3 (A3) S2 (A2) S1 (A5) S0 (A4) VBAT VBAT CPU Link Both versions of the SCK (1.0 and 1.1) are using the same CPU, ATMEGA32U4 (Arduino Leonardo). With the difference that the 1.0 works at 5V and 16MHZ and the 1.1 works at 3.3V and 8MHZ. In the 1.1 version we\u2019ve improved the power consumption. This CPU has native USB and an UART TTL port allowing us to connect directly with the WIFI module. ATMEGA32U4 datasheet USB CONNECTOR Link The 1.0 version uses a Mini USB connector and 1.1 version uses a Micro USB. WIFI MODULE Link The RN-131 module is a standalone, embedded wireless 802.11 b/g networking module. With its small form factor and extremely low power consumption, the RN-131 fits perfectly for the SCK wireless communication requirements. Main features: Qualified 2.4-GHz IEEE 802.11b/g transceiver Ultra-low power: 4 uA sleep, 40 mA Rx, 210 mA Tx High throughput, 1 Mbps sustained data rate with TCP/IP and WPA2 Small, compact surface-mount module On-board ceramic chip antenna and U.FL connector for external antenna 8-Mbit flash memory and 128-KB RAM UART hardware interface 10 general-purpose digital I/O pins 8 analog sensor interfaces Real-time clock for wakeup and time stamping Accepts 3.3-V regulated or 2 to 3 V battery Supports ad hoc and infrastructure networking modes On board ECOS -OS, TCP/IP stacks Wi-Fi Alliance certified for WPA2-PSK FCC/CE/ICS certified and RoHS compliant. Industrial (RN-131G) and commercial (RN-131C) grade temperature options WIFLY module - RN-131 datasheet BATTERY POWERING Link For powering the SCK, in both versions, we are using a 3.7v 2000 mAh li-on battery. SCK version 1.0 uses two different voltages, 3.3V and 5V to power the IC\u2019s. To get 5V from 3.3v we are using a step-up based on NCP1400, thus having a stable voltage at 5v and 100mA. On the other hand, to regulate the voltage and to obtain 3.3v, the SCK uses the IC MAX604. NCP1400 datasheet MAX604 datasheet In 1.1 version, to make things simpler, the voltage of entire SCK was unified to 3.3V. The responsible to regulate the voltage from 3.7v to 3.3v is the MCP1725 IC. MCP1725 datasheet BATTERY CHARGING Link For charging the battery there are two ways, USB or solar panel. To carry out the charging we are using MCP73831 IC. For charging the battery in 1.0 version the solar panel have to be 12v and 500mA. In 1.1 version, the solar panel can be more versatile in terms of amperage. MCP73831 datasheet SOLAR PANEL CHARGING Link Depending on the sunlight conditions the solar panel produces up to 12v, we have to reduce the voltage to 5v to feed up the Vin of the MCP73831 charger IC. To carry out this task we are using the LM2674 IC, a very efficient IC, with a rate of 91% of performance. LM2674 datasheet RTC (REAL TIME CLOCK) Link The SCK has a real time clock for keeping track of time when the kit is offline. For this task we chose the DS1307 IC for the 1.0 version and the DS1339Y-3+ IC for the 1.1 version. Different IC due to the different voltages, 5V for the 1.0 version and 3.3V for the 1.1 version. DS1307 datasheet DS1339Y-3+ datasheet SD CARD READER Link The SD card is used to store the data captured by the sensors when the kit is offline. When the kit gets connected, the data will be reeded from the SD card and uploaded to the platform. To hold the SD card we are using the DM3CS holder. The SD card is powered at 3.3V and communicates with the CPU through SPI protocol. DM3CS datasheet EEPROM MEMORY Link For the users that don\u2019t have a SD card we\u2019ve added an EEPROM memory to store the data when the SCK is offline. We chose the 24LC256 IC that can store 32kBytes, it communicates with the CPU through I2C protocol. 24LC256 datasheet MAIN BOARD BASIC SENSORS Link The main board has some basic sensors: Measurement of the battery level Measurement of the solar panel level Measurement of the wireless networks detected SENSOR BOARD Link The sensor board contains the necessary sensors for measuring all the other parameters. This means NO2 and CO gases, sunlight, noise pollution, temperature, humidity. Also, the sensor board has an I2C bus, this allows to expand the SCK to other kind of sensors. NO2 AND CO SENSORS Link To measure these two gases we chose e2v sensors. In particular, metal oxide sensors MICS5525 and MICS2710, for version 1.0. And MICS4514, for version 1.1, that contains both sensors in one. Metal oxide sensors are based on oxide semiconductors. Their electrical conductivity is modulated due to the reaction between the semiconductor and the gases in the atmosphere. MICS5525 datasheet MICS2710 datasheet MICS4514 datasheet LIGHT SENSOR Link The light sensor is a basic element to know the light pollution. In version 1.0, was used a LDR (light-dependent resistor) whose voltage varies depending on the light conditions. For version 1.1, was used a photodiode BH1730FVC. This sensor contains an I2C bus that gives us directly the amount of lux of ambient and infrared light. BH1730FVC datasheet NOISE SENSOR Link The noise sensor is based on an electret microphone. For the version 1.0 WM-61A was used as the microphone, the captured audio signal is passed through an operational amplifier configured as band pass filter. For the version 1.1 POM-3044P-R was used. WM-61A datasheet POM-3044P-R datasheet TEMPERATURE AND HUMIDITY SENSOR Link To measure temperature and humidity a module that integrates both sensors was used. For version 1.0 the RHT22 was used, it has one wire digital interface. For version 1.1 the SHT21 was used, it has I2C protocol and faster response between measures than the RHT22. RHT22 datasheet SHT21 datasheet 3 AXIS ACCELEROMETER Link In version 1.0 we detected that some measures vary depending on the orientation of the SCK. That's why in version 1.1 we added the ADXL345 accelerometer to detect the position and to compensate the measures depending on the orientation of the SCK. This accelerometer communicates via I2C protocol with the kit. ADXL345 datasheet I2C EXPANSION BUS Link Due to the ease of the I2C protocol. We\u2019ve included and I2C bus to provide to the community the opportunity of expanding the SCK. Detailed specifications Link Smart Smart Citizen Kit SCK 1.0 (Goteo Board) SCK 1.1 (Kickstarter Board) SCK 1.5 (Upcoming!) Data Board MCU ATMEGA32U4 ATMEGA32U4 SAMD21 Clock 16Mhz 8Mhz 32Mhz WiFi Microchip RN-131 802.11 b/g Microchip RN-131 802.11 b/g Espressif ESP8266-12E Firmware Repository Repository Repository Design files v1.01 v1.1 v1.5 Ambient Board Light PVD-P8001 BH1730FVC BH1730FVC Type LDR Analog Light Sensor Digital Ambient Light Sensor Digital Ambient Light Sensor Units % Lux Lux Datasheet PDV-P8001.pdf BH-1730FCV.pdf BH-1730FCV.pdf Performance 0.008 - 65535 lx (\u00b1 15%) ** 0.008 - 65535 lx (\u00b1 15%) ** Firmware SCKAmbient :: getLight (); SCKAmbient :: getLight (): Under development Temp DHT22 HPP828E031 (SHT21) SHT21 Type Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Units \u00baC \u00baC \u00baC Datasheet DHT22.pdf HTU-21D.pdf SHT-21.pdf Firmware SCKAmbient :: getDHT22 (); SCKAmbient :: getHumidity (); SCKAmbient :: getSHT21 (); SCKAmbient :: getTemperature (); Under development Performance Linearity R\u00b2>0.94 * Under tests Humidity DHT22 HPP828E031 (SHT21) SHT21 Type Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Units % Rel % Rel % Rel Datasheet DHT22.pdf HTU-21D.pdf SHT21.pdf Firmware SCKAmbient :: getDHT22 (); SCKAmbient :: getHumidity (); SCKAmbient :: getSHT21 (); SCKAmbient :: getHumidity (); Under development Performance Linearity R\u00b2>0.97 * Under tests NO\u00b2ise POM-3044P-R POM-3044P-R SPU0414HR5H Type Electret microphone with envelop follower sound pressure sensor Electret microphone with envelop follower sound pressure sensor New MEMS microphone with envelop follower sound pressure sensor Units dB dB dB Datasheet POM-3044P-R.pdf POM-3044P-R.pdf SPU0414HR5H.pdf Firmware SCKAmbient :: getNO\u00b2ise (); SCKAmbient :: getNO\u00b2ise (); Under development *Performance Range 50dB - 110dB (\u00b1 15%) ** Under tests CO MICS-5525 MiCS-4514 MiCS-4514 Type MOS CO gas sensor MOS CO and NO\u00b2 gas sensor MOS CO and NO\u00b2 gas sensor Units kOhm (ppm) kOhm (ppm) kOhm (ppm) Datasheet MICS-5525_CO.pdf MiCS-4514_CO_NO2.pdf MiCS-4514_CO_NO2.pdf Firmware SCKAmbient :: getMICS (); SCKAmbient :: getMICS (); Under development Performance Linearity 0.45 < R\u00b2 < 0.82 * Under tests NO\u00b22 MICS-2710 MiCS-4514 MiCS-4514 Type MOS NO\u00b2 gas sensor MOS CO and NO\u00b2 gas sensor MOS CO and NO\u00b2 gas sensor Units kOhm (ppm) kOhm (ppm) kOhm (ppm) Datasheet MICS-2710_NO2.pdf MiCS-4514_CO_NO2.pdf MiCS-4514_CO_NO2.pdf Firmware SCKAmbient :: getMICS (); SCKAmbient :: getMICS (); Under development Performance Linearity R\u00b2<0.0 * Under tests * South Coast AQMD The correlation coefficient (R\u00b2) is a statistical parameter indicating how well the performance of each sensor compares to that of a Federal Reference or Federal Equivalent Method (FRM and FEM, respectively) instrument. An R\u00b2 approaching the value of 1 reflects a near perfect agreement, whereas a value of 0 indicates a complete lack of correlation * Internal Smart Citizen Team WIP Evaluation Tests Enclosures Link We have designed a laser cut cover for an acrylic material and a 3D-Printed enclosure to better safeguard the hardware, particularly for outdoor applications. You can download the files through this links. Smart Citizen Enclosure 1.0 Smart Citizen Enclosure 1.1 Also, we are working in new cases that will be available soon. Smart Citizen Enclosure Assembly Instructions Acrylic cases Link This case has been designed to protect the electronics on the circuit boards and allows for mount the SCK's hardware on walls and other surfaces without much trouble. Particularly for indoor applications. Acrylic cases","title":"Hardware"},{"location":"Legacy Hardware/Hardware/#hardware","text":"","title":"Hardware"},{"location":"Legacy Hardware/Hardware/#inside-the-sck","text":"","title":"Inside the SCK"},{"location":"Legacy Hardware/Hardware/#main-board","text":"The main board contains the basic functionality like sensor I/O to read de sensor values, communication with the platform through the wifi module, manage the power and battery charging.","title":"Main Board"},{"location":"Legacy Hardware/Hardware/#pinout","text":"The SCK Main Board connects to the Sensor Board 16 pin connector. This is how the pins are laid out on the board. The numbers in brackets are the actual pin numbers of the micro controller. Pins IO are digital and S are analogue. GND GND IO3 (10) IO2 (9) IO1 (13) IO0 (5) SCL SDA S5 (A1) S4 (A0) S3 (A3) S2 (A2) S1 (A5) S0 (A4) VBAT VBAT","title":"PINOUT"},{"location":"Legacy Hardware/Hardware/#cpu","text":"Both versions of the SCK (1.0 and 1.1) are using the same CPU, ATMEGA32U4 (Arduino Leonardo). With the difference that the 1.0 works at 5V and 16MHZ and the 1.1 works at 3.3V and 8MHZ. In the 1.1 version we\u2019ve improved the power consumption. This CPU has native USB and an UART TTL port allowing us to connect directly with the WIFI module. ATMEGA32U4 datasheet","title":"CPU"},{"location":"Legacy Hardware/Hardware/#usb-connector","text":"The 1.0 version uses a Mini USB connector and 1.1 version uses a Micro USB.","title":"USB CONNECTOR"},{"location":"Legacy Hardware/Hardware/#wifi-module","text":"The RN-131 module is a standalone, embedded wireless 802.11 b/g networking module. With its small form factor and extremely low power consumption, the RN-131 fits perfectly for the SCK wireless communication requirements. Main features: Qualified 2.4-GHz IEEE 802.11b/g transceiver Ultra-low power: 4 uA sleep, 40 mA Rx, 210 mA Tx High throughput, 1 Mbps sustained data rate with TCP/IP and WPA2 Small, compact surface-mount module On-board ceramic chip antenna and U.FL connector for external antenna 8-Mbit flash memory and 128-KB RAM UART hardware interface 10 general-purpose digital I/O pins 8 analog sensor interfaces Real-time clock for wakeup and time stamping Accepts 3.3-V regulated or 2 to 3 V battery Supports ad hoc and infrastructure networking modes On board ECOS -OS, TCP/IP stacks Wi-Fi Alliance certified for WPA2-PSK FCC/CE/ICS certified and RoHS compliant. Industrial (RN-131G) and commercial (RN-131C) grade temperature options WIFLY module - RN-131 datasheet","title":"WIFI MODULE"},{"location":"Legacy Hardware/Hardware/#battery-powering","text":"For powering the SCK, in both versions, we are using a 3.7v 2000 mAh li-on battery. SCK version 1.0 uses two different voltages, 3.3V and 5V to power the IC\u2019s. To get 5V from 3.3v we are using a step-up based on NCP1400, thus having a stable voltage at 5v and 100mA. On the other hand, to regulate the voltage and to obtain 3.3v, the SCK uses the IC MAX604. NCP1400 datasheet MAX604 datasheet In 1.1 version, to make things simpler, the voltage of entire SCK was unified to 3.3V. The responsible to regulate the voltage from 3.7v to 3.3v is the MCP1725 IC. MCP1725 datasheet","title":"BATTERY POWERING"},{"location":"Legacy Hardware/Hardware/#battery-charging","text":"For charging the battery there are two ways, USB or solar panel. To carry out the charging we are using MCP73831 IC. For charging the battery in 1.0 version the solar panel have to be 12v and 500mA. In 1.1 version, the solar panel can be more versatile in terms of amperage. MCP73831 datasheet","title":"BATTERY CHARGING"},{"location":"Legacy Hardware/Hardware/#solar-panel-charging","text":"Depending on the sunlight conditions the solar panel produces up to 12v, we have to reduce the voltage to 5v to feed up the Vin of the MCP73831 charger IC. To carry out this task we are using the LM2674 IC, a very efficient IC, with a rate of 91% of performance. LM2674 datasheet","title":"SOLAR PANEL CHARGING"},{"location":"Legacy Hardware/Hardware/#rtc-real-time-clock","text":"The SCK has a real time clock for keeping track of time when the kit is offline. For this task we chose the DS1307 IC for the 1.0 version and the DS1339Y-3+ IC for the 1.1 version. Different IC due to the different voltages, 5V for the 1.0 version and 3.3V for the 1.1 version. DS1307 datasheet DS1339Y-3+ datasheet","title":"RTC (REAL TIME CLOCK)"},{"location":"Legacy Hardware/Hardware/#sd-card-reader","text":"The SD card is used to store the data captured by the sensors when the kit is offline. When the kit gets connected, the data will be reeded from the SD card and uploaded to the platform. To hold the SD card we are using the DM3CS holder. The SD card is powered at 3.3V and communicates with the CPU through SPI protocol. DM3CS datasheet","title":"SD CARD READER"},{"location":"Legacy Hardware/Hardware/#eeprom-memory","text":"For the users that don\u2019t have a SD card we\u2019ve added an EEPROM memory to store the data when the SCK is offline. We chose the 24LC256 IC that can store 32kBytes, it communicates with the CPU through I2C protocol. 24LC256 datasheet","title":"EEPROM MEMORY"},{"location":"Legacy Hardware/Hardware/#main-board-basic-sensors","text":"The main board has some basic sensors: Measurement of the battery level Measurement of the solar panel level Measurement of the wireless networks detected","title":"MAIN BOARD BASIC SENSORS"},{"location":"Legacy Hardware/Hardware/#sensor-board","text":"The sensor board contains the necessary sensors for measuring all the other parameters. This means NO2 and CO gases, sunlight, noise pollution, temperature, humidity. Also, the sensor board has an I2C bus, this allows to expand the SCK to other kind of sensors.","title":"SENSOR BOARD"},{"location":"Legacy Hardware/Hardware/#no2-and-co-sensors","text":"To measure these two gases we chose e2v sensors. In particular, metal oxide sensors MICS5525 and MICS2710, for version 1.0. And MICS4514, for version 1.1, that contains both sensors in one. Metal oxide sensors are based on oxide semiconductors. Their electrical conductivity is modulated due to the reaction between the semiconductor and the gases in the atmosphere. MICS5525 datasheet MICS2710 datasheet MICS4514 datasheet","title":"NO2 AND CO SENSORS"},{"location":"Legacy Hardware/Hardware/#light-sensor","text":"The light sensor is a basic element to know the light pollution. In version 1.0, was used a LDR (light-dependent resistor) whose voltage varies depending on the light conditions. For version 1.1, was used a photodiode BH1730FVC. This sensor contains an I2C bus that gives us directly the amount of lux of ambient and infrared light. BH1730FVC datasheet","title":"LIGHT SENSOR"},{"location":"Legacy Hardware/Hardware/#noise-sensor","text":"The noise sensor is based on an electret microphone. For the version 1.0 WM-61A was used as the microphone, the captured audio signal is passed through an operational amplifier configured as band pass filter. For the version 1.1 POM-3044P-R was used. WM-61A datasheet POM-3044P-R datasheet","title":"NOISE SENSOR"},{"location":"Legacy Hardware/Hardware/#temperature-and-humidity-sensor","text":"To measure temperature and humidity a module that integrates both sensors was used. For version 1.0 the RHT22 was used, it has one wire digital interface. For version 1.1 the SHT21 was used, it has I2C protocol and faster response between measures than the RHT22. RHT22 datasheet SHT21 datasheet","title":"TEMPERATURE AND HUMIDITY SENSOR"},{"location":"Legacy Hardware/Hardware/#3-axis-accelerometer","text":"In version 1.0 we detected that some measures vary depending on the orientation of the SCK. That's why in version 1.1 we added the ADXL345 accelerometer to detect the position and to compensate the measures depending on the orientation of the SCK. This accelerometer communicates via I2C protocol with the kit. ADXL345 datasheet","title":"3 AXIS ACCELEROMETER"},{"location":"Legacy Hardware/Hardware/#i2c-expansion-bus","text":"Due to the ease of the I2C protocol. We\u2019ve included and I2C bus to provide to the community the opportunity of expanding the SCK.","title":"I2C EXPANSION BUS"},{"location":"Legacy Hardware/Hardware/#detailed-specifications","text":"Smart Smart Citizen Kit SCK 1.0 (Goteo Board) SCK 1.1 (Kickstarter Board) SCK 1.5 (Upcoming!) Data Board MCU ATMEGA32U4 ATMEGA32U4 SAMD21 Clock 16Mhz 8Mhz 32Mhz WiFi Microchip RN-131 802.11 b/g Microchip RN-131 802.11 b/g Espressif ESP8266-12E Firmware Repository Repository Repository Design files v1.01 v1.1 v1.5 Ambient Board Light PVD-P8001 BH1730FVC BH1730FVC Type LDR Analog Light Sensor Digital Ambient Light Sensor Digital Ambient Light Sensor Units % Lux Lux Datasheet PDV-P8001.pdf BH-1730FCV.pdf BH-1730FCV.pdf Performance 0.008 - 65535 lx (\u00b1 15%) ** 0.008 - 65535 lx (\u00b1 15%) ** Firmware SCKAmbient :: getLight (); SCKAmbient :: getLight (): Under development Temp DHT22 HPP828E031 (SHT21) SHT21 Type Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Units \u00baC \u00baC \u00baC Datasheet DHT22.pdf HTU-21D.pdf SHT-21.pdf Firmware SCKAmbient :: getDHT22 (); SCKAmbient :: getHumidity (); SCKAmbient :: getSHT21 (); SCKAmbient :: getTemperature (); Under development Performance Linearity R\u00b2>0.94 * Under tests Humidity DHT22 HPP828E031 (SHT21) SHT21 Type Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Digital Temperature and Relative Humidity Sensor Units % Rel % Rel % Rel Datasheet DHT22.pdf HTU-21D.pdf SHT21.pdf Firmware SCKAmbient :: getDHT22 (); SCKAmbient :: getHumidity (); SCKAmbient :: getSHT21 (); SCKAmbient :: getHumidity (); Under development Performance Linearity R\u00b2>0.97 * Under tests NO\u00b2ise POM-3044P-R POM-3044P-R SPU0414HR5H Type Electret microphone with envelop follower sound pressure sensor Electret microphone with envelop follower sound pressure sensor New MEMS microphone with envelop follower sound pressure sensor Units dB dB dB Datasheet POM-3044P-R.pdf POM-3044P-R.pdf SPU0414HR5H.pdf Firmware SCKAmbient :: getNO\u00b2ise (); SCKAmbient :: getNO\u00b2ise (); Under development *Performance Range 50dB - 110dB (\u00b1 15%) ** Under tests CO MICS-5525 MiCS-4514 MiCS-4514 Type MOS CO gas sensor MOS CO and NO\u00b2 gas sensor MOS CO and NO\u00b2 gas sensor Units kOhm (ppm) kOhm (ppm) kOhm (ppm) Datasheet MICS-5525_CO.pdf MiCS-4514_CO_NO2.pdf MiCS-4514_CO_NO2.pdf Firmware SCKAmbient :: getMICS (); SCKAmbient :: getMICS (); Under development Performance Linearity 0.45 < R\u00b2 < 0.82 * Under tests NO\u00b22 MICS-2710 MiCS-4514 MiCS-4514 Type MOS NO\u00b2 gas sensor MOS CO and NO\u00b2 gas sensor MOS CO and NO\u00b2 gas sensor Units kOhm (ppm) kOhm (ppm) kOhm (ppm) Datasheet MICS-2710_NO2.pdf MiCS-4514_CO_NO2.pdf MiCS-4514_CO_NO2.pdf Firmware SCKAmbient :: getMICS (); SCKAmbient :: getMICS (); Under development Performance Linearity R\u00b2<0.0 * Under tests * South Coast AQMD The correlation coefficient (R\u00b2) is a statistical parameter indicating how well the performance of each sensor compares to that of a Federal Reference or Federal Equivalent Method (FRM and FEM, respectively) instrument. An R\u00b2 approaching the value of 1 reflects a near perfect agreement, whereas a value of 0 indicates a complete lack of correlation * Internal Smart Citizen Team WIP Evaluation Tests","title":"Detailed specifications"},{"location":"Legacy Hardware/Hardware/#enclosures","text":"We have designed a laser cut cover for an acrylic material and a 3D-Printed enclosure to better safeguard the hardware, particularly for outdoor applications. You can download the files through this links. Smart Citizen Enclosure 1.0 Smart Citizen Enclosure 1.1 Also, we are working in new cases that will be available soon. Smart Citizen Enclosure Assembly Instructions","title":"Enclosures"},{"location":"Legacy Hardware/Hardware/#acrylic-cases","text":"This case has been designed to protect the electronics on the circuit boards and allows for mount the SCK's hardware on walls and other surfaces without much trouble. Particularly for indoor applications. Acrylic cases","title":"Acrylic cases"},{"location":"Legacy Hardware/Troubleshooting/","text":"Troubleshooting Link Add an SSID with two words Link If your SSID has more than one word you have to fill any spaces with the dollar ($) character. Serial port already in use Link This happens when one application is already using the serial port. For example, if you have the Arduino IDE serial monitor opened and you're trying to configure your SCK through the web browser. You have yo close the serial monitor first. No port available Link This message will appear when you have uploaded the wrong firmware version to your SCK. Unable to connect to the Board Link This happens when one application is already using the serial port. For example, if you have the Arduino IDE serial monitor opened and you're trying to configure your SCK through the web browser. You have yo close the serial monitor first. Unable to connect to the Internet Link If you're getting the message \"Error in connection\" when you run the SCK firmware this may be due: Your router works with a protocol different than 802.11AG You have set wrong SSID name and/or password Your network has an encryption different than OPEN, WEP, WPA1, WPA2 OR WEP64 Your firewall is blocking the mac address of your SCK Your internet connection is not stable No data received yet Link This message appears the first time you register your kit, is due to cache issues. This issue normally is fixed after a few hours, in any case we are working to improve this issue. Port is not appearing on the drop down Link This may be due: The SCK is turned off. The USB cable you're using has wired only power cable and not the data cables. The bootloader is corrupted. Firmware update problem Link If you're having problems updating the firmware you can try one of these two options: Update the latest firmware through the web browser configurator. Update the latest firmware through Arduino IDE. If you're still having problems it's may be due to a hardware or software issue, contact us at support@smartcitizen.me . No MAC address registered Link If you're getting this message, the may be due: Configuration process is not finished correctly. The WIFI module of your SCK is corrupted, so MAC address is not accessible. To repair your wifi module refer to this tutorial . Collapsed USB port Link First batches of SCK version 1.1 came with this issue. We have a tutorial you can follow to repair it or contact us at support@smartcitizen.me . Broken LiPo battery wire Link Depending on the conditions, the battery wires can suffer until its break. We encourage you to read this Battery Common Care Techniques in order to preserve your battery. Non-Stop Blue LED Blinking Link If your blue LEDs are blinking back and forth non-stop, this means your SCK has lost its WiFi connection. Check to make sure your router is still on, and that you're still in range. Reinstall the bootloader using another Arduino Link In this tutorial we are going to show you how turn an Arduino into AVR ISP to burn the bootloader to your SCK. The bootloader is a small piece of code running inside your Smart Smart Citizen Kit allowing it to be programmed and configured over USB. If suddenly you do not see anymore the USB / Serial port when connecting your Kit to a Computer maybe your bootloader crashed and it is time to reinstall it. Parts: Link Arduino Board 6 Patch Cables Male Female Software: Link Arduino IDE Instructions: Link Open the ArduinoISP sketch example in menu File > Examples > ArduinoISP . Select the correct board and ports in the menu Tools > Board > Port and Tools > Board > Port that correspond to the board you are using as the programmer (e.g., Arduino UNO). Upload the ArduinoISP sketch. Wire your Arduino board to the SCK as shown in the diagram below using the Patch cables. Take care the ISCP VCC goes to the 3.3V Pin on the Arduino UNO since the Smart Smart Citizen Kit works at 3.3V Select the board in the Tools > Board menu For SmartSmart Citizen Kit version 1.0 select Arduino Leonardo (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Arduino LilyPad USB (ATmega 32U4 at 8Mhz) Select in Tools > Programmer > Arduino as ISP . Select in Tools > Burn Bootloader . This step can take some minutes. Done! Please, go back to the on-line setup page in order to install the firmware again. We know this is not an easy task! For any question contact support@smartcitizen.me or ask for help in the forum . Reinstall the bootloader using the AVRISP MKII Link In this tutorial we are going to show you how to program the SCK with the Atmel AVRISP MKII In-System Programmer. This is not a common tool you might have but we suggest you ask your closest Fab Lab . The bootloader is a small piece of code running inside your Smart Smart Citizen Kit allowing it to be programmed and configured over USB. If suddenly you do not see anymore the USB / Serial port when connecting your Kit to a Computer maybe your bootloader crashed and it is time to reinstall it. Parts: Link AVRISP mkII Software: Link Arduino IDE Instructions: Link Connect the AVRISP mkII with the USB cable to the computer. Connect your Smart Smart Citizen Kit to the computer with the micro-USB cable. Connect the six pins bus cable of the AVRISP mkII to the ISP connector of the SCK Board as shown the picture. Switch on your Smart Smart Citizen Kit, you'll find out a tiny switch in one side. Select the board in the Tools > Board menu For SmartSmart Citizen Kit version 1.0 select Arduino Leonardo (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Arduino LilyPad USB (ATmega 32U4 at 8Mhz) Select in Tools > Programmer > AVRISP MKII . Select in Tools > Burn Bootloader . This step can take some minutes, the led AVRISP mkII will blink and after go green. Done! Please, go back to the on-line setup page in order to install the firmware again. We know this is not an easy task! For any question contact support@smartcitizen.me or ask for help in the forum .","title":"Troubleshooting"},{"location":"Legacy Hardware/Troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"Legacy Hardware/Troubleshooting/#add-an-ssid-with-two-words","text":"If your SSID has more than one word you have to fill any spaces with the dollar ($) character.","title":"Add an SSID with two words"},{"location":"Legacy Hardware/Troubleshooting/#serial-port-already-in-use","text":"This happens when one application is already using the serial port. For example, if you have the Arduino IDE serial monitor opened and you're trying to configure your SCK through the web browser. You have yo close the serial monitor first.","title":"Serial port already in use"},{"location":"Legacy Hardware/Troubleshooting/#no-port-available","text":"This message will appear when you have uploaded the wrong firmware version to your SCK.","title":"No port available"},{"location":"Legacy Hardware/Troubleshooting/#unable-to-connect-to-the-board","text":"This happens when one application is already using the serial port. For example, if you have the Arduino IDE serial monitor opened and you're trying to configure your SCK through the web browser. You have yo close the serial monitor first.","title":"Unable to connect to the Board"},{"location":"Legacy Hardware/Troubleshooting/#unable-to-connect-to-the-internet","text":"If you're getting the message \"Error in connection\" when you run the SCK firmware this may be due: Your router works with a protocol different than 802.11AG You have set wrong SSID name and/or password Your network has an encryption different than OPEN, WEP, WPA1, WPA2 OR WEP64 Your firewall is blocking the mac address of your SCK Your internet connection is not stable","title":"Unable to connect to the Internet"},{"location":"Legacy Hardware/Troubleshooting/#no-data-received-yet","text":"This message appears the first time you register your kit, is due to cache issues. This issue normally is fixed after a few hours, in any case we are working to improve this issue.","title":"No data received yet"},{"location":"Legacy Hardware/Troubleshooting/#port-is-not-appearing-on-the-drop-down","text":"This may be due: The SCK is turned off. The USB cable you're using has wired only power cable and not the data cables. The bootloader is corrupted.","title":"Port is not appearing on the drop down"},{"location":"Legacy Hardware/Troubleshooting/#firmware-update-problem","text":"If you're having problems updating the firmware you can try one of these two options: Update the latest firmware through the web browser configurator. Update the latest firmware through Arduino IDE. If you're still having problems it's may be due to a hardware or software issue, contact us at support@smartcitizen.me .","title":"Firmware update problem"},{"location":"Legacy Hardware/Troubleshooting/#no-mac-address-registered","text":"If you're getting this message, the may be due: Configuration process is not finished correctly. The WIFI module of your SCK is corrupted, so MAC address is not accessible. To repair your wifi module refer to this tutorial .","title":"No MAC address registered"},{"location":"Legacy Hardware/Troubleshooting/#collapsed-usb-port","text":"First batches of SCK version 1.1 came with this issue. We have a tutorial you can follow to repair it or contact us at support@smartcitizen.me .","title":"Collapsed USB port"},{"location":"Legacy Hardware/Troubleshooting/#broken-lipo-battery-wire","text":"Depending on the conditions, the battery wires can suffer until its break. We encourage you to read this Battery Common Care Techniques in order to preserve your battery.","title":"Broken LiPo battery wire"},{"location":"Legacy Hardware/Troubleshooting/#non-stop-blue-led-blinking","text":"If your blue LEDs are blinking back and forth non-stop, this means your SCK has lost its WiFi connection. Check to make sure your router is still on, and that you're still in range.","title":"Non-Stop Blue LED Blinking"},{"location":"Legacy Hardware/Troubleshooting/#reinstall-the-bootloader-using-another-arduino","text":"In this tutorial we are going to show you how turn an Arduino into AVR ISP to burn the bootloader to your SCK. The bootloader is a small piece of code running inside your Smart Smart Citizen Kit allowing it to be programmed and configured over USB. If suddenly you do not see anymore the USB / Serial port when connecting your Kit to a Computer maybe your bootloader crashed and it is time to reinstall it.","title":"Reinstall the bootloader using another Arduino"},{"location":"Legacy Hardware/Troubleshooting/#parts","text":"Arduino Board 6 Patch Cables Male Female","title":"Parts:"},{"location":"Legacy Hardware/Troubleshooting/#software","text":"Arduino IDE","title":"Software:"},{"location":"Legacy Hardware/Troubleshooting/#instructions","text":"Open the ArduinoISP sketch example in menu File > Examples > ArduinoISP . Select the correct board and ports in the menu Tools > Board > Port and Tools > Board > Port that correspond to the board you are using as the programmer (e.g., Arduino UNO). Upload the ArduinoISP sketch. Wire your Arduino board to the SCK as shown in the diagram below using the Patch cables. Take care the ISCP VCC goes to the 3.3V Pin on the Arduino UNO since the Smart Smart Citizen Kit works at 3.3V Select the board in the Tools > Board menu For SmartSmart Citizen Kit version 1.0 select Arduino Leonardo (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Arduino LilyPad USB (ATmega 32U4 at 8Mhz) Select in Tools > Programmer > Arduino as ISP . Select in Tools > Burn Bootloader . This step can take some minutes. Done! Please, go back to the on-line setup page in order to install the firmware again. We know this is not an easy task! For any question contact support@smartcitizen.me or ask for help in the forum .","title":"Instructions:"},{"location":"Legacy Hardware/Troubleshooting/#reinstall-the-bootloader-using-the-avrisp-mkii","text":"In this tutorial we are going to show you how to program the SCK with the Atmel AVRISP MKII In-System Programmer. This is not a common tool you might have but we suggest you ask your closest Fab Lab . The bootloader is a small piece of code running inside your Smart Smart Citizen Kit allowing it to be programmed and configured over USB. If suddenly you do not see anymore the USB / Serial port when connecting your Kit to a Computer maybe your bootloader crashed and it is time to reinstall it.","title":"Reinstall the bootloader using the AVRISP MKII"},{"location":"Legacy Hardware/Troubleshooting/#parts_1","text":"AVRISP mkII","title":"Parts:"},{"location":"Legacy Hardware/Troubleshooting/#software_1","text":"Arduino IDE","title":"Software:"},{"location":"Legacy Hardware/Troubleshooting/#instructions_1","text":"Connect the AVRISP mkII with the USB cable to the computer. Connect your Smart Smart Citizen Kit to the computer with the micro-USB cable. Connect the six pins bus cable of the AVRISP mkII to the ISP connector of the SCK Board as shown the picture. Switch on your Smart Smart Citizen Kit, you'll find out a tiny switch in one side. Select the board in the Tools > Board menu For SmartSmart Citizen Kit version 1.0 select Arduino Leonardo (ATmega 32U4 at 16Mhz) For SmartSmart Citizen Kit version 1.1 select Arduino LilyPad USB (ATmega 32U4 at 8Mhz) Select in Tools > Programmer > AVRISP MKII . Select in Tools > Burn Bootloader . This step can take some minutes, the led AVRISP mkII will blink and after go green. Done! Please, go back to the on-line setup page in order to install the firmware again. We know this is not an easy task! For any question contact support@smartcitizen.me or ask for help in the forum .","title":"Instructions:"},{"location":"Sensor Analysis Framework/","text":"Sensor Analysis Framework Link The following section details the framework used for post processing the data coming from time-series based sensors, as the Smart Citizen Kit and Station. Based on Jupyter Notebooks and running Python and R , it is intended to provide an state-of-the-art data handling and analysis framework, which can be easily expanded for other use cases. The Sensor Analysis Framework is mainly used to handle sensor data acquisition and apply sensor models for actual pollutant concentration calculations. In the following sections, we detail the principles of low cost sensor calibration that we follow, as well as the usage within the framework. All the files and notebooks related to this document can be found online in our Github repository. Check the source code How we use it Link Generally, the sensor data is ingested in the Sensor Analysis Framework directly from the API, or by inserting it via csv. As detailed in the Low Cost Sensor Calibration Section , each of the sensors is treated differently, and some of them require more analysis than others, e.g.: the Metal Oxyde sensors vs the electrochemical sensors. The framework can be used to process the Living Labs Station's data, loading the data and applying tailor made algorithms for the sensors within: Additionally, the Framework can be used to load in data from the Smart Citizen Kit's sensors and used to generate models and analysis based on other references, following the diagram below: Similarly, this approach can be used to improve the Living Labs Station's data, where known effects from temperature or humidity can be input as corrections for the models generated. Finally, all the models generated are stored and can be easily loaded from the Github Repository. Check the source code Framework structure Link The structure of this framework can be split between two main areas: one dedicated to sensor data analysis and model generation; and an automated sensor correction script that recovers sensor data from the API, processes it, and posts it back to the API with the use of the results obtained in the data analysis. This structure is decribed in the following diagram: Furthermore, within the sensor data analysis, a notebook and several scripts are included, intended for modeling and data visualisation , including exploratory data analysis and a testing environment for sensor model calibration. This includes interfacing with the SmartCitizen API in order to download available sensors from the platform, as well as local csv analysis. Further functionalities are explained in the following sections. A deeper look Link The main component of the Framework is a Jupyter Notebook with the following features: An interface to either retrieve data from the Smart Citizen's API in a simple way or to load them from local sources (in csv format, compatible with the SCK SD card data) A data handling framework based on the well known Pandas package An exploratory data analysis interface to study sensor behaviour and correlations A flexible sensor calibration model interface with classical statistical methods such as linear regression, ARIMA, SARIMA-X among others, as well as more modern Machine Learning techniques with the use of LSTM (Long short term memory) networks and MLP (Multi Layer Perceptron) models for sequential data prediction and forecasting An interface to statistically validate and study the performance of these models, export and store them As a bonus, an interface to convert the python objects into the statistical analysis language R The framework also provides several functionalities within signal analysis field using numpy and scipy frameworks. An example of the workflow can be seen below: Step by step guides Install the framework Use Machine Learning to Create Models for Sensors Calibration Post process the stations data Loading in the data Link As mentioned, data can be downloaded from the SmartCitizen API with the KIT IDs or using local csv. In order to tidy up the data, the recordings are organised around the concept of test , an entity containing all the kits' references, sensors and general information regarding the conditions at which the measurements were carried out: Test Location, date and author Kit type and reference Sensor calibration data or reference Availability of reference equipment measurement and type A brief schema of the test structure is specified below: All this structure is filled up at the test creation with a dedicated script, saving future time to understand mismatching reading units, timestamps formats and so on. Finally, the devices' data is stored as Time Series data, with DateTime index in ISO8601 format. This is an important consideration for data visualisation and posterious modelling. Exploratory data analysis Link The device's data can be quickly analysed using a simple interface in order to quickly select the desired channels and timeframes. Some of the functionalities already included are: Time Series visualisation Correlation plot and pairs plot Correlogram Heatmaps for geospatial data This section uses interactive plotting frameworks as Plotly and well know matplotlib to serve differente exploratory analysis tools: Data models Link The data models section includes an easy to use and full interface to select data from different devices within a test in order to calibrate different models. Since the data is mainly based on Time Series analysis, it interfaces with common statistics and machine learning frameworks such as sci-kit learn , tensorflow , keras , and stats models . These frameworks provide tools to perform: Pre-processing stage: Outliers detection with Holt-Winters methods (triple exponential smoothing) Data study and analysis for multicollinearity and autocorrelation in order to determine significant variables and avoid model overfit with non-significant exogenous variables Trend decomposition and seasonality analysis Data split between training and test dataset, with the possibility of rolling prediction Model stage: Baseline model estimations in order to assess minimum targets for model quality (using naive regression models) Ordinary Linear Regression techniques for univariate and multivariate linear and non-linear independent variables ARIMA-X (Autorregresive, Integrated, Moving Average) models with exogenous variables using Box-Jenkis parameter selection methods More advanced machine learning techiques with RNN (Recurrent Neural Networks) for sequence predictions: MLP (MultiLayer Perceptron) model with basic RNN cells Single and multiple layers LSTM (Long-Thort Term Memory) networks with the possibility of including several shifted variables in the model training and prediction An example of the model is shown below for the estimation of the SGX4514 CO with the use of the rest of the Kit's available sensor, using a single layer LSTM network only two weeks of training: Depending on the model selected, different validation techniques are implemented, in order to verify models' assumptions and avoid data misinterpretation (i.e. Durbin Watson or Jacque Bera test for linear regression). Finally, it is important to follow carefully the instructions as stated in the notebook, in order to avoid low model quality. Model import/export and storage Link Once the model is analysed and validated, it can be saved and exported. This allows using the model in the future with the same variables in other sensor studies. The model objects are serialised with joblib and can be uploaded to the Models Github Repository for later use. Source files Link Download Check the source code","title":"Index"},{"location":"Sensor Analysis Framework/#sensor-analysis-framework","text":"The following section details the framework used for post processing the data coming from time-series based sensors, as the Smart Citizen Kit and Station. Based on Jupyter Notebooks and running Python and R , it is intended to provide an state-of-the-art data handling and analysis framework, which can be easily expanded for other use cases. The Sensor Analysis Framework is mainly used to handle sensor data acquisition and apply sensor models for actual pollutant concentration calculations. In the following sections, we detail the principles of low cost sensor calibration that we follow, as well as the usage within the framework. All the files and notebooks related to this document can be found online in our Github repository. Check the source code","title":"Sensor Analysis Framework"},{"location":"Sensor Analysis Framework/#how-we-use-it","text":"Generally, the sensor data is ingested in the Sensor Analysis Framework directly from the API, or by inserting it via csv. As detailed in the Low Cost Sensor Calibration Section , each of the sensors is treated differently, and some of them require more analysis than others, e.g.: the Metal Oxyde sensors vs the electrochemical sensors. The framework can be used to process the Living Labs Station's data, loading the data and applying tailor made algorithms for the sensors within: Additionally, the Framework can be used to load in data from the Smart Citizen Kit's sensors and used to generate models and analysis based on other references, following the diagram below: Similarly, this approach can be used to improve the Living Labs Station's data, where known effects from temperature or humidity can be input as corrections for the models generated. Finally, all the models generated are stored and can be easily loaded from the Github Repository. Check the source code","title":"How we use it"},{"location":"Sensor Analysis Framework/#framework-structure","text":"The structure of this framework can be split between two main areas: one dedicated to sensor data analysis and model generation; and an automated sensor correction script that recovers sensor data from the API, processes it, and posts it back to the API with the use of the results obtained in the data analysis. This structure is decribed in the following diagram: Furthermore, within the sensor data analysis, a notebook and several scripts are included, intended for modeling and data visualisation , including exploratory data analysis and a testing environment for sensor model calibration. This includes interfacing with the SmartCitizen API in order to download available sensors from the platform, as well as local csv analysis. Further functionalities are explained in the following sections.","title":"Framework structure"},{"location":"Sensor Analysis Framework/#a-deeper-look","text":"The main component of the Framework is a Jupyter Notebook with the following features: An interface to either retrieve data from the Smart Citizen's API in a simple way or to load them from local sources (in csv format, compatible with the SCK SD card data) A data handling framework based on the well known Pandas package An exploratory data analysis interface to study sensor behaviour and correlations A flexible sensor calibration model interface with classical statistical methods such as linear regression, ARIMA, SARIMA-X among others, as well as more modern Machine Learning techniques with the use of LSTM (Long short term memory) networks and MLP (Multi Layer Perceptron) models for sequential data prediction and forecasting An interface to statistically validate and study the performance of these models, export and store them As a bonus, an interface to convert the python objects into the statistical analysis language R The framework also provides several functionalities within signal analysis field using numpy and scipy frameworks. An example of the workflow can be seen below: Step by step guides Install the framework Use Machine Learning to Create Models for Sensors Calibration Post process the stations data","title":"A deeper look"},{"location":"Sensor Analysis Framework/#loading-in-the-data","text":"As mentioned, data can be downloaded from the SmartCitizen API with the KIT IDs or using local csv. In order to tidy up the data, the recordings are organised around the concept of test , an entity containing all the kits' references, sensors and general information regarding the conditions at which the measurements were carried out: Test Location, date and author Kit type and reference Sensor calibration data or reference Availability of reference equipment measurement and type A brief schema of the test structure is specified below: All this structure is filled up at the test creation with a dedicated script, saving future time to understand mismatching reading units, timestamps formats and so on. Finally, the devices' data is stored as Time Series data, with DateTime index in ISO8601 format. This is an important consideration for data visualisation and posterious modelling.","title":"Loading in the data"},{"location":"Sensor Analysis Framework/#exploratory-data-analysis","text":"The device's data can be quickly analysed using a simple interface in order to quickly select the desired channels and timeframes. Some of the functionalities already included are: Time Series visualisation Correlation plot and pairs plot Correlogram Heatmaps for geospatial data This section uses interactive plotting frameworks as Plotly and well know matplotlib to serve differente exploratory analysis tools:","title":"Exploratory data analysis"},{"location":"Sensor Analysis Framework/#data-models","text":"The data models section includes an easy to use and full interface to select data from different devices within a test in order to calibrate different models. Since the data is mainly based on Time Series analysis, it interfaces with common statistics and machine learning frameworks such as sci-kit learn , tensorflow , keras , and stats models . These frameworks provide tools to perform: Pre-processing stage: Outliers detection with Holt-Winters methods (triple exponential smoothing) Data study and analysis for multicollinearity and autocorrelation in order to determine significant variables and avoid model overfit with non-significant exogenous variables Trend decomposition and seasonality analysis Data split between training and test dataset, with the possibility of rolling prediction Model stage: Baseline model estimations in order to assess minimum targets for model quality (using naive regression models) Ordinary Linear Regression techniques for univariate and multivariate linear and non-linear independent variables ARIMA-X (Autorregresive, Integrated, Moving Average) models with exogenous variables using Box-Jenkis parameter selection methods More advanced machine learning techiques with RNN (Recurrent Neural Networks) for sequence predictions: MLP (MultiLayer Perceptron) model with basic RNN cells Single and multiple layers LSTM (Long-Thort Term Memory) networks with the possibility of including several shifted variables in the model training and prediction An example of the model is shown below for the estimation of the SGX4514 CO with the use of the rest of the Kit's available sensor, using a single layer LSTM network only two weeks of training: Depending on the model selected, different validation techniques are implemented, in order to verify models' assumptions and avoid data misinterpretation (i.e. Durbin Watson or Jacque Bera test for linear regression). Finally, it is important to follow carefully the instructions as stated in the notebook, in order to avoid low model quality.","title":"Data models"},{"location":"Sensor Analysis Framework/#model-importexport-and-storage","text":"Once the model is analysed and validated, it can be saved and exported. This allows using the model in the future with the same variables in other sensor studies. The model objects are serialised with joblib and can be uploaded to the Models Github Repository for later use.","title":"Model import/export and storage"},{"location":"Sensor Analysis Framework/#source-files","text":"Download Check the source code","title":"Source files"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/","text":"Low Cost Sensors Calibration Link Low cost sensor calibration and assessment pose a great challenge for data quality objectives. We follow this sensor calibration procedure , which can be split into three stages: Behaviour assesment : in laboratory conditions, serving as base testing for assessing general sensor behaviour. Characterisation : also in laboratory conditions, assess generic sensor parameters as sensitivity, zero and span. Modelisation with real world deployment : including other variables such as environmental factors and sensor cross-sensitivity. Each of these stages apply differently depending on the type of sensor. For instance the electrochemical sensors present in the Station are already characterised by the manufacturer, while the old SGX MICS4514 Metal Oxyde Sensors in the Urban Board of the Smart Citizen Kit are not. The different characteristics of these sensors make different calibration approaches to be carried out. Base calibration parameters need to be determined in controlled conditions. In this stage, the aim would be to find parameters such as: Sensor sensitivity : the sensor response per each ppm of target pollutant in nominal conditions Zero : the sensor reading in zero air (pure air at 25degC). Sensor response (t 90 ) Sensor range : maximum and minimum readings for the sensor Finally, after this initial calibration assessment, it is critical to gather as much data as possible from long term sensor deployments . These deployments should aim to cover the widest range of sensor exposure conditions, in order to generate robust models. While dealing with low cost sensors this stage is very important, as it is detailed in the sections below. These sensor deployments serve for two main purposes: to generate quantitative classification methods that can classify the air quality in predefined ranges (i.e. 'poor', 'fair', good'); and to generate predictive qualitative models for more accurate values. Either of them need large amounts of data if the models are aimed to be representative. Additionally, by the mere nature of the data and the sensors themselves, these models would need to be: Robusts to noise Capable of learning non-linear relationships Handle multivariate inputs Capable of learning temporal dependence These needs make machine learning methods great canditates for modeling the data. These methods are implemented in the Sensor Analysis Framework, as well as other more traditional linear methods. The combination of these algorithms with large amounts of data gathered during, for instance, the iScape project, offers a great opportunity to demonstrate the use of low cost sensors for air quality monitoring. Smart Citizen Kits Link Due to their construction, low-cost metal oxyde sensors suffer from high levels of spread in their baseline resistance and sensitivity. As well, these sensors are generally reactive to other pollutants in the atmosphere, with a low selectivity of the actual target pollutant and drifts in their behaviour can be seen after some weeks of exposure. As well, metal oxyde sensors show short and long term drifts in their calibrations. Ideally, a sensor characterisation in laboratory conditions is needed to assess sensitiviy, baseline resistances sensor-to-sensor spread, aiming to obtain normalising factors for each sensor or group of sensors. Even if possible, the variability of the sensor behaviour during the deployment stage, makes the individual characterisation and calibration of the Metal Oxyde sensors unrealistic. For this reason, indicative measurements are to be expected from this type of low cost sensors. More information about the sensors present in the urban board of the SCK can be found in this section . Smart Citizen Stations Link Electrochemical sensors These sensors can achieve significant accuracy, but they require a particular data post-processing that combines the measurement at the sensor electrodes with the sensor characterisation on the factory as well as other environmental parameters as air temperature and relative humidity (i.e. absolute humidity). Luckily the manufacturer of these sensors, Alphasense, provides us with that reference data. However, the complexity of the operations performed can not be done inside the sensing device as it uses advanced operations as well as historical data from the same device. For that reason, the data needs to be post processed using the Sensors Analysis Framework. The algorithm is in a beta stage and later it will be applied automatically on the data once it arrives at the platform. More details can be found in the Electrochemical sensor baseline methodology Section . This process doesn't require any on-site reference data but requires the data to be processed using the manufacturer calibration reference per sensor as well as other environmental values as temperature and humidity. PM sensor The selected PM sensor is internally characterised by the manufacturer and, it's readings are currently being evaluated. Preliminarily, the measurements can be as well improved when reference data is available, as some have noted that the PM sensors can be affected by relative humidity. Plantower PMS 5003 Read more on the Plantower PMS 5003 implementation on the PM Sensor Board .","title":"Low Cost Sensors Calibration"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#low-cost-sensors-calibration","text":"Low cost sensor calibration and assessment pose a great challenge for data quality objectives. We follow this sensor calibration procedure , which can be split into three stages: Behaviour assesment : in laboratory conditions, serving as base testing for assessing general sensor behaviour. Characterisation : also in laboratory conditions, assess generic sensor parameters as sensitivity, zero and span. Modelisation with real world deployment : including other variables such as environmental factors and sensor cross-sensitivity. Each of these stages apply differently depending on the type of sensor. For instance the electrochemical sensors present in the Station are already characterised by the manufacturer, while the old SGX MICS4514 Metal Oxyde Sensors in the Urban Board of the Smart Citizen Kit are not. The different characteristics of these sensors make different calibration approaches to be carried out. Base calibration parameters need to be determined in controlled conditions. In this stage, the aim would be to find parameters such as: Sensor sensitivity : the sensor response per each ppm of target pollutant in nominal conditions Zero : the sensor reading in zero air (pure air at 25degC). Sensor response (t 90 ) Sensor range : maximum and minimum readings for the sensor Finally, after this initial calibration assessment, it is critical to gather as much data as possible from long term sensor deployments . These deployments should aim to cover the widest range of sensor exposure conditions, in order to generate robust models. While dealing with low cost sensors this stage is very important, as it is detailed in the sections below. These sensor deployments serve for two main purposes: to generate quantitative classification methods that can classify the air quality in predefined ranges (i.e. 'poor', 'fair', good'); and to generate predictive qualitative models for more accurate values. Either of them need large amounts of data if the models are aimed to be representative. Additionally, by the mere nature of the data and the sensors themselves, these models would need to be: Robusts to noise Capable of learning non-linear relationships Handle multivariate inputs Capable of learning temporal dependence These needs make machine learning methods great canditates for modeling the data. These methods are implemented in the Sensor Analysis Framework, as well as other more traditional linear methods. The combination of these algorithms with large amounts of data gathered during, for instance, the iScape project, offers a great opportunity to demonstrate the use of low cost sensors for air quality monitoring.","title":"Low Cost Sensors Calibration"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#smart-citizen-kits","text":"Due to their construction, low-cost metal oxyde sensors suffer from high levels of spread in their baseline resistance and sensitivity. As well, these sensors are generally reactive to other pollutants in the atmosphere, with a low selectivity of the actual target pollutant and drifts in their behaviour can be seen after some weeks of exposure. As well, metal oxyde sensors show short and long term drifts in their calibrations. Ideally, a sensor characterisation in laboratory conditions is needed to assess sensitiviy, baseline resistances sensor-to-sensor spread, aiming to obtain normalising factors for each sensor or group of sensors. Even if possible, the variability of the sensor behaviour during the deployment stage, makes the individual characterisation and calibration of the Metal Oxyde sensors unrealistic. For this reason, indicative measurements are to be expected from this type of low cost sensors. More information about the sensors present in the urban board of the SCK can be found in this section .","title":"Smart Citizen Kits"},{"location":"Sensor Analysis Framework/Low Cost Sensors Calibration/#smart-citizen-stations","text":"Electrochemical sensors These sensors can achieve significant accuracy, but they require a particular data post-processing that combines the measurement at the sensor electrodes with the sensor characterisation on the factory as well as other environmental parameters as air temperature and relative humidity (i.e. absolute humidity). Luckily the manufacturer of these sensors, Alphasense, provides us with that reference data. However, the complexity of the operations performed can not be done inside the sensing device as it uses advanced operations as well as historical data from the same device. For that reason, the data needs to be post processed using the Sensors Analysis Framework. The algorithm is in a beta stage and later it will be applied automatically on the data once it arrives at the platform. More details can be found in the Electrochemical sensor baseline methodology Section . This process doesn't require any on-site reference data but requires the data to be processed using the manufacturer calibration reference per sensor as well as other environmental values as temperature and humidity. PM sensor The selected PM sensor is internally characterised by the manufacturer and, it's readings are currently being evaluated. Preliminarily, the measurements can be as well improved when reference data is available, as some have noted that the PM sensors can be affected by relative humidity. Plantower PMS 5003 Read more on the Plantower PMS 5003 implementation on the PM Sensor Board .","title":"Smart Citizen Stations"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/","text":"Creating models for the low cost sensors calibration Link In this section, we will work on the development of two models for the MOS sensors in the Smart Smart Citizen Kit. In the Sensor Analysis Framework, we have implemented two different approaches for model calibration: Ordinary Least Squares (OLS) : based on the statsmodels package , the model is able to input whichever expression referring to the kit's available data and perform OLS regression over the defined training and test data Machine Learning (MLP or LSTM) : based on the keras package using tensorflow in the backend. This framework can be used to train larger collections of data, where we want to be, among others: Robust to noise Learn non-linear relationships Aware of temporal dependence Ordinary Least Squares example Link Let's delve first into an OLS example. The framework comes with a very simple interface to develop and interact with the models. By running these two cells we will generate the preliminary tweaks for the dataframes: from test_utils import combine_data name_combined_data = 'COMBINED_DEVICES' for reading in readings : ## Since we don't know if there are more or less channels than last time ## (and tbh, I don't feel like checking), remove the key readings [ reading ][ 'devices' ] . pop ( 'COMBINED_DEVICES' , None ) ## And then add it again dataframe = combine_data ( readings [ reading ][ 'devices' ], True ) readings [ reading ][ 'devices' ][ name_combined_data ] = dict () readings [ reading ][ 'devices' ][ name_combined_data ][ 'data' ] = dict () readings [ reading ][ 'devices' ][ name_combined_data ][ 'data' ] = dataframe Output: Dataframe has been combined for model preparation Here we can list all the available channels for our test: test_linear_regression = '2018-08_INT_STATION_TEST_SUMMER_HOLIDAYS' for channel in readings [ test_linear_regression ][ 'devices' ][ name_combined_data ][ 'data' ] . columns : print channel Output: BATT_4748 CO_AD_BASE_4748 CO_AD_BASE_filter_4748 CO_MICS_RAW_4748 EXT_HUM_4748 EXT_TEMP_4748 GB_1A_4748 GB_1W_4748 ( ... ) PM_1_4748 PM_10_4748 PM_25_4748 PM_DALLAS_TEMP_4748 PRESS_4748 TEMP_4748 O3_AD_BASE_filter_4748 And now, it's time to set up our model. In the cell below we can define the channel and features for the regression. from linear_regression_utils import prepData , fit_model ## Select data # Always have an item called 'REF', the rest can be anything tuple_features = ([ 'REF' , 'CO_AD_BASE_4748' ], [ 'A' , 'CO_MICS_RAW_4748' ], [ 'B' , 'TEMP_4748' ], [ 'C' , 'HUM_4748' ], [ 'D' , 'PM_25_4748' ]) formula_expression = 'REF ~ A + np.power(A,2) + B + np.power(B,2) + C + D' min_date = '2018-08-31 00:00:00' max_date = '2018-09-06 00:00:00' ratio_train = 2. / 3 # Important that this is a float, don't forget the . filter_data = True alpha_filter = 0.1 dataframeModel = readings [ test_linear_regression ][ 'devices' ][ name_combined_data ][ 'data' ] dataTrain , dataTest = prepData ( dataframeModel , tuple_features , min_date , max_date , ratio_train , filter_data , alpha_filter ) model , train_rmse , test_rmse = fit_model ( formula_expression , dataTrain , dataTest We have to keep at least the key 'REF ' within the tuple_features , but the rest can be renamed at will. We can also input whichever formula_expression for the model regression in the following format: formula_expression = 'REF ~ A + np.power(A,2) + B + np.power(B,2) + C + D' Which converts to: REF = A + A^2 + B + B^2 + C + D + Intercept REF = A + A^2 + B + B^2 + C + D + Intercept We can also define the ratio between the train and test dataset and the minimum dates to use within the datasets (globally): min_date = '2018-08-31 00:00:00' max_date = '2018-09-06 00:00:00' ratio_train = 2. / 3 # Important that this is a float, don't forget the . Finally, if our data is too noisy, we can apply an exponential smoothing function, by setting filter_data = True and the alpha coefficient (0.1, 0.2 is already very filtered: filter_data = True alpha_filter = 0.1 If we run this cell, we will perform model calibration, with the following output: OLS Regression Results ============================================================================== Dep . Variable : REF R - squared : 0.676 Model : OLS Adj . R - squared : 0.673 Method : Least Squares F - statistic : 197.5 Date : Thu , 06 Sep 2018 Prob ( F - statistic ): 1.87e-135 Time : 12 : 25 : 17 Log - Likelihood : 1142.9 No . Observations : 575 AIC : - 2272. Df Residuals : 568 BIC : - 2241. Df Model : 6 Covariance Type : nonrobust ================================================================================== coef std err t P >| t | [ 0.025 0.975 ] ---------------------------------------------------------------------------------- Intercept - 3.7042 0.406 - 9.133 0.000 - 4.501 - 2.908 A 0.0011 0.000 2.953 0.003 0.000 0.002 np . power ( A , 2 ) - 3.863e-05 7.03e-06 - 5.496 0.000 - 5.24e-05 - 2.48e-05 B 0.2336 0.024 9.863 0.000 0.187 0.280 np . power ( B , 2 ) - 0.0032 0.000 - 9.267 0.000 - 0.004 - 0.003 C - 0.0014 0.001 - 2.755 0.006 - 0.002 - 0.000 D 0.0127 0.001 24.378 0.000 0.012 0.014 ============================================================================== Omnibus : 7.316 Durbin - Watson : 0.026 Prob ( Omnibus ): 0.026 Jarque - Bera ( JB ): 10.245 Skew : - 0.076 Prob ( JB ): 0.00596 Kurtosis : 3.636 Cond . No . 4.29e+05 ============================================================================== Warnings : [ 1 ] Standard Errors assume that the covariance matrix of the errors is correctly specified . [ 2 ] The condition number is large , 4.29e+05 . This might indicate that there are strong multicollinearity or other numerical problems . This output brings a lot of information. First, we find what the dependent variable is, in our case always 'REF' . The type of model used and some general information is shown below that. More statistically important information is found in the rest of the output. Some key data: R-squared and adjusted R-squared : this is our classic correlation coefficient or R 2 . The adjusted one aims to correct the model overfitting by the inclusion of too many variables, and for that introduces a penalty on the number of variables included Below, we can find a summary of the model coefficients applied to all the variables and the P>|t| term, which indicates the significance of the term introduced in the model Model quality diagnostics are also indicated. Kurtosis and skewness are metrics for determining the distribution of the residuals. They indicate how the residuals of the model resemble a normal distribution. Below, we will review more on diagnosis plots. The Jarque Bera test indicates if the residuals are normally distributed (the null hypothesis is a joint hypothesis of the skewness being zero and the excess kurtosis being zero), and a value of zero indicates that the data is normally distributed. If the Jarque Bera test is valid (in the case above it isn't), the Durbin Watson is applicable in order to check for autocorrelation of the residuals (meaning that the residuals of our model are related among themselves and that we haven't captured some characteristics of our data with the tested model). Finally, there is a warning at the bottom indicating that the condition number is large. It suggests we might have multicollinearity problems in our model, which means that some of the independent variables might be correlated among themselves and that they are probably not necessary. Our function also depicts the results in a graphical way for us to see the model itself. It will show the training and test datasets (as Reference Train and Reference Test respectively), and the prediction results. The mean and absolute confidence intervals for 95% confidence are also shown: Now we can look at some other model quality plots. If we run the cell below, we will obtain an adaptation of the summary plots from R : from linear_regression_utils import modelRplots % matplotlib inline modelRplots ( model , dataTrain , dataTest ) Let's review the output step by step: Residual vs Fitted and Scale Location plot : these plots represents the model heteroscedasticity , which is a representation of the residuals versus the fitted values. This polot is helpful to check if the errors are distributed homogeneously and that we are not penalising high, low, or other values. There is also a red line which represents the average trend of this distribution which, we want it to be horizontal. For more information visit here and here . Clearly, in this model we are missing something: Normal QQ : the qq-plot is a representation of the kurtosis and skewness of the residuals distribution. If the data were well described by a normal distribution, the values should be about the same, i.e.: on the diagonal (red line). For example, in our case the model presents a deviation on both tails, indicating skewness. In general, a simple rubric to interpret a qq-plot is that if a given tail twists off counterclockwise from the reference line, there is more data in that tail of your distribution than in a theoretical normal, and if a tail twists off clockwise there is less data in that tail of your distribution than in a theoretical normal. In other words: if both tails twist counterclockwise we have heavy tails (leptokurtosis), if both tails twist clockwise, we have light tails (platykurtosis), if the right tail twists counterclockwise and the left tail twists clockwise, we have right skew if the left tail twists counterclockwise and the right tail twists clockwise, we have left skew Residuals vs Leverage : this plot is probably the most complex of them all. It shows how much leverage one single point has on the whole regression. It can be interpreted as how the average line that passes through all the data (that we are calculating with the OLS) can be modified by 'far' points in the distribution, for example, outliers. This leverage can be seen as how much a single point is able to pull down or up the average line. One way to think about whether or not the results are driven by a given data point is to calculate how far the predicted values for your data would move if your model were fit without the data point in question. This calculated total distance is called Cook's distance. We can have four cases (more information from source, here ) everything is fine (the best) high-leverage, but low-standardized residual point low-leverage, but high-standardized residual point high-leverage, high-standardized residual point (the worst) In this case, we see that our model has some points with higher leverage but low residuals (probably not too bad) and that the higher residuals are found with low leverage, which means that our model is safe to outliers. If we run this function without the filtering, some outliers will be present and the plot turns into: Machine learning example Link As we have seen in the the calibration section , machine learning algorithms promise a better representation of the sensor's data, being able to learn robust non-linear models and sequential dependencies. For that reason, we have implemented an easy to use interface based on keras with Tensorflow backend, in order to train sequential models 3 . The workflow for a supervised learning algorithm reads as follows: Reframe the data as a supervised learning algorithm and split into training and test dataframe. More information can be found here Define Model and fit for training dataset Evaluate test dataframe and extract metrics Let's go step by step. In order to reframe the data as a supervised learning algorithm, we have created a function called prep_dataframe_ML which is the only one function we'll have to interact with: # Combine all data in one dataframe from ml_utils import prep_dataframe_ML # Always have an item called 'REF', the rest can be anything tuple_features = ([ 'REF' , 'CO_AD_BASE_STATION_CASE' ], [ 'A' , 'CO_MICS_RAW_STATION_CASE' ], [ 'B' , 'TEMP_STATION_CASE' ], [ 'C' , 'HUM_STATION_CASE' ], [ 'D' , 'PM_25_STATION_CASE' ]) model_name = 'LSTM NO2' ratio_train = 3. / 4 # Important that this is a float, don't forget the . alpha_filter = 0.9 # 1 means no filtering # Number of lags for the model n_lags = 1 dataframeModel = readings [ test_model ][ 'devices' ][ name_combined_data ][ 'data' ] index , train_X , train_y , test_X , test_y , scaler , n_train_periods = prep_dataframe_ML ( dataframeModel , min_date , max_date , tuple_features , n_lags , ratio_train , alpha_filter ) Output: DataFrame has been reframed and prepared for supervised learning Reference is : CO_AD_BASE_STATION_CASE Features are : [ 'CO_MICS_RAW_STATION_CASE' , 'TEMP_STATION_CASE' , 'HUM_STATION_CASE' , 'PM_25_STATION_CASE' ] Traning X Shape ( 1508 , 1 , 4 ), Training Y Shape ( 1508 ,), Test X Shape ( 501 , 1 , 4 ), Test Y Shape ( 501 ,) Now, we can fit our model. The main function is fit_model_ML and currently implements a simple LSTM network. This network can be redefined easily by modifying the underlying function. model = fit_model_ML ( train_X , train_y , test_X , test_y , epochs = 50 , batch_size = 72 , verbose = 2 ) def fit_model_ML ( train_X , train_y , test_X , test_y , epochs = 50 , batch_size = 72 , verbose = 2 ): model = Sequential () layers = [ 50 , 100 , 1 ] model . add ( LSTM ( layers [ 0 ], return_sequences = True , input_shape = ( train_X . shape [ 1 ], train_X . shape [ 2 ]))) model . add ( Dropout ( 0.2 )) model . add ( LSTM ( layers [ 1 ], return_sequences = False )) model . add ( Dropout ( 0.2 )) model . add ( Dense ( output_dim = layers [ 2 ])) model . add ( Activation ( \"linear\" )) model . compile ( loss = 'mse' , optimizer = 'rmsprop' ) # fit network history = model . fit ( train_X , train_y , epochs = epochs , batch_size = batch_size , validation_data = ( test_X , test_y ), verbose = verbose , shuffle = False ) # plot history fig = plot . figure ( figsize = ( 10 , 8 )) plot . plot ( history . history [ 'loss' ], label = 'train' ) plot . plot ( history . history [ 'val_loss' ], label = 'test' ) plot . xlabel ( 'Epochs (-)' ) plot . ylabel ( 'Loss (-)' ) plot . title ( 'Model Convergence' ) plot . legend ( loc = 'best' ) plot . show () return model This function will return the model and it's learning outcomes: Train on 1508 samples , validate on 501 samples Epoch 1 / 50 - 1 s - loss : 0.0500 - val_loss : 0.0051 Epoch 2 / 50 - 0 s - loss : 0.0200 - val_loss : 0.0058 Epoch 3 / 50 - 0 s - loss : 0.0158 - val_loss : 0.0052 ... Then, we can evaluate the model and plot it's results: from ml_utils import predict_ML from signal_utils import metrics import matplotlib.pyplot as plot % matplotlib inline inv_y_train , inv_yhat_train = predict_ML ( model , train_X , train_y , n_lags , scaler ) inv_y_test , inv_yhat_test = predict_ML ( model , test_X , test_y , n_lags , scaler ) Model comparison Link Here is a visual comparison of both models: fig = plot . figure ( figsize = ( 15 , 10 )) # Actual data plot . plot ( index [: n_train_periods ], inv_y_train , 'r' , label = 'Reference Train' , alpha = 0.3 ) plot . plot ( index [ n_train_periods + n_lags :], inv_y_test , 'b' , label = 'Reference Test' , alpha = 0.3 ) # Fitted Values for Training plot . plot ( index [: n_train_periods ], inv_yhat_train , 'r' , label = 'ML Prediction Train' ) plot . plot ( index [ n_train_periods + n_lags :], inv_yhat_test , 'b' , label = 'ML Prediction Test' ) # OLS plot . plot ( dataTrain [ 'index' ], predictionTrain , 'g' , label = 'OLS Prediction Train' ) plot . plot ( dataTest [ 'index' ], predictionTest , 'k' , label = 'OLS Prediction Test' ) plot . legend ( loc = 'best' ) plot . ylabel ( 'CO (ppm)' ) plot . xlabel ( 'Date (-)' ) Output: It is very difficult though, to know which one is performing better. Let's then evaluate and compare our models. In order to evaluate it's metrics, we will be using the following principles 1 2 : Info In all of the expressions below, the letter m indicates the model field, r indicates the reference field. Overbar is average and \\sigma \\sigma is the standard deviation. Linear correlation Coefficient A measure of the agreement between two signals: R = {{1 \\over N} \\sum_{i=0}^n (m_n-\\overline m)( r_n-\\overline r ) \\over \\sigma_m\\sigma_r} R = {{1 \\over N} \\sum_{i=0}^n (m_n-\\overline m)( r_n-\\overline r ) \\over \\sigma_m\\sigma_r} The correlation coefficient is bounded by the range -1 \\le R \\le 1 -1 \\le R \\le 1 . However, it is difficult to discern information about the differences in amplitude between two signals from R alone. Normalized standard deviation A measure of the differences in amplitude between two signals: $$ \\sigma * = {\\sigma_m \\over \\sigma_r} $$ unbiased Root-Mean-Square Difference A measure of how close the modelled points fall to teach other: RMSD' = \\Bigl( {1 \\over N} \\sum_{n=1}^N [(m_n - \\overline m)-(r_n - \\overline r)]^2 \\Bigr)^{0.5} RMSD' = \\Bigl( {1 \\over N} \\sum_{n=1}^N [(m_n - \\overline m)-(r_n - \\overline r)]^2 \\Bigr)^{0.5} Potential Bias Difference between the means of two fields: $$ B = \\overline m - \\overline r $$ Total RMSD A measure of the average magnitude of difference: $$ RMSD = \\Bigl( {1 \\over N} \\sum_{n=1}^N (m_n - r_n)^2 \\Bigr)^{0.5} $$ In other words, the unbiased RMSD (RMSD') is equal to the total RMSD if there is no bias between the model and the reference fields (i.e. B = 0). The relationship between both reads: RMSD^2 = B^2 + RMSD'^2 RMSD^2 = B^2 + RMSD'^2 In contrast, the unbiased RMSD may be conceptualized as an overall measure of the agreement between the aplitude ( \\sigma \\sigma ) and phase ( \\phi \\phi ) of two temporal patterns. For this reason, the correlation coefficient ( R R ), normalised standard deviation ( \\sigma* \\sigma* ), and unbiased RMSD are all referred to as patern statistics , related to one another by: RMSD'^2 = \\sigma_r^2 + \\sigma_m^2 - 2\\sigma_r\\sigma_mR RMSD'^2 = \\sigma_r^2 + \\sigma_m^2 - 2\\sigma_r\\sigma_mR Normalized and unbiased RMSD If we recast in standard deviation normalized units (indicated by the asterisk) it becomes: RMSD'^* = \\sqrt { 1 + \\sigma*^2 - 2\\sigma*R} RMSD'^* = \\sqrt { 1 + \\sigma*^2 - 2\\sigma*R} NB : the minimum of this function occurrs when \\sigma* = R \\sigma* = R . Normalized bias Gives information about the mean difference but normalized by the \\sigma* \\sigma* $$ B* = {\\overline m - \\overline r \\over \\sigma_r} $$ Target diagrams The target diagram is a plot that provides summary information about the pattern statistics as well as the bias thus yielding an overview of their respective contributions to the total RMSD. In a simple Cartesian coordinate system, the unbiased RMSD may serve as the X-axis and the bias may serve as the Y-axis. The distance between the origin and the model versus observation statistics (any point, s, within the X,Y Cartesian space) is then equal to the total RMSD. If all is normalized by the \\sigma_r \\sigma_r , the distance from the origin is again the standard deviation normalized total RMSD : 1 RMSD^{*2} = B^{*2}+RMSD^{*'2} RMSD^{*2} = B^{*2}+RMSD^{*'2} The resulting target diagram then provides information about: whether the \\sigma_m \\sigma_m is larger or smaller thann the \\sigma_r \\sigma_r whether there is a positive or negative bias Image Source: Jolliff et al. 1 Any point greater than RMSD*=1 is to be considered a poor performer since it doesn't offer improvement over the time series average. Interestingly, the target diagram has no information about the correlation coefficient R, but some can be inferred, knowing that all the points within the RMSD* <1 are positively correlated (R>0), although, in 1 it is shown that a circle marker with radius M_{R1} M_{R1} , means that all the points between that marker and the origin have a R coefficient larger than R1, where: M_{R1} = min(RMSD*') = \\sqrt {1+R1^2-2R1^2} M_{R1} = min(RMSD*') = \\sqrt {1+R1^2-2R1^2} Results Link Let's now compare both models. If we execute this line, we will retrieve all model metrics: metrics_model_train = metrics ( inv_y_train , inv_yhat_train ) metrics_model_test = metrics ( inv_y_test , inv_yhat_test ) ## Metrics Train print ( ' \\t\\t Train \\t\\t Test' ) for item in metrics_model_train . keys (): print ( ' % s : \\t %.5f \\t %.5f ' % ( item , metrics_model_train [ item ], metrics_model_test [ item ])) Output: Train Test avg_ref : 0.65426 0.53583 sig_est : 0.08412 0.03160 RMSD : 0.08439 0.05511 avg_est : 0.61639 0.53135 sigma_norm : 0.67749 0.50032 sign_sigma : - 1.00000 - 1.00000 sig_ref : 0.12416 0.06317 bias : - 0.03787 - 0.00448 RMSD_norm_unb : 0.68200 0.87258 rsquared : 0.53801 0.23874 normalised_bias : - 0.30502 - 0.07093 And finally, we can compare both models, training and test dataframe with the function: targetDiagram ( _dataframe , _plot_train ) Output: Here, every point that falls inside the yellow circle, will have an R 2 over 0.7, and so will be the red and green for R 2 over 0.5 and 0.9 respectively. We see that only one of our models performs well in that sense, which is the training dataset of the OLS. However, this dataset performs pretty badly in the test dataset, being the LSTM options much better. This target diagram offers information about how the hyperparameters affect our networks. For instance, increasing the training epochs from 100 to 200 does not affect greatly on model performance, but the effect of filtering the data beforehand to reduce the noise shows a much better model performance in both, training and test dataframe. Export the models Link Let's now assume that we are happy with our models. Depending on the model we have developed (OLS or ML ), we follow different approaches for the export: Machine Learning Model We will use joblib to save the model metrics and parameters. The keras model will be saved with the to_json property of the model and the weights in an h5 format with the save_weights ght: from os.path import join from sklearn.externals import joblib modelDirML = '/path/to/modelDir' filenameML = join ( modelDirML , model_name_ML ) # Save everything joblib . dump ( dictModel [ model_name_ML ][ 'metrics' ], filenameML + '_metrics.sav' ) joblib . dump ( dictModel [ model_name_ML ][ 'parameters' ], filenameML + '_parameters.sav' ) model_json = model . to_json () with open ( filenameML + \"_model.json\" , \"w\" ) as json_file : json_file . write ( model_json ) model . save_weights ( filenameML + \"_model.h5\" ) print ( \"Model \" + model_name_ML + \" saved in: \" + modelDir ) Output: Model LSTM CO 200 epochs Filter 0.9 saved in : / path / to / modelDir And in our directory: \u279c models ls -l -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_metrics.sav -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_model.h5 -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_model.json -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_parameters.sav OLS model We will use joblib for all the objects serialisation in this case: from os.path import join from sklearn.externals import joblib modelDir_OLS = '/path/to/model' filename_OLS = join ( modelDir_OLS , model_name_OLS ) # Save everything joblib . dump ( dictModel [ model_name_OLS ][ 'metrics' ], filename_OLS + '_metrics.sav' ) joblib . dump ( dictModel [ model_name_OLS ][ 'parameters' ], filename_OLS + '_parameters.sav' ) joblib . dump ( dictModel [ model_name_OLS ][ 'model' ], filename_OLS + '_model.sav' ) print ( \"Model saved in: \" + modelDir_OLS ) Output: Model saved in : / path / to / model And in the terminal: \u279c models ls -l total 1928 -rw-r--r-- Sep 11 12 :53 CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25_metrics.sav -rw-r--r-- Sep 11 12 :53 CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25_model.sav -rw-r--r-- Sep 11 12 :53 CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25_parameters.sav Load Models from Disk Link Now, sometime after having exported our model, let's assume we need to get it back: Machine Learning Model We will use the symmetric functions from joblib and keras : from os.path import join from sklearn.externals import joblib from keras.models import model_from_json modelDirML = '/path/to/model' filenameML = join ( modelDirML , model_name_ML ) # Load Model and weights json_file = open ( filenameML + \"_model.json\" , \"r\" ) loaded_model_json = json_file . read () json_file . close () loaded_model = model_from_json ( loaded_model_json ) loaded_model . load_weights ( filenameML + \"_model.h5\" ) print ( \"Loaded \" + model_name_ML + \" from disk\" ) # Load params and metrics loaded_params = joblib . load ( filenameML + '_parameters.sav' ) loaded_metrics = joblib . load ( filenameML + '_metrics.sav' ) display ( loaded_params ) display ( loaded_metrics ) Output: Loaded LSTM CO 200 epochs Filter 0.9 from disk { 'features' : ([ 'REF' , 'CO_AD_BASE_STATION_CASE' ], [ 'A' , 'CO_MICS_RAW_STATION_CASE' ], [ 'B' , 'TEMP_STATION_CASE' ], [ 'C' , 'HUM_STATION_CASE' ], [ 'D' , 'PM_25_STATION_CASE' ])} { 'test' : { 'RMSD' : 0.055340715974325445 , 'RMSD_norm_unb' : 0.8761932784857427 , 'avg_est' : 0.5344016428091338 , 'avg_ref' : 0.5358268506805136 , 'bias' : - 0.0014252078713797856 , 'normalised_bias' : - 0.022562028100955915 , 'rsquared' : 0.23248054249786632 , 'sig_est' : 0.03133999875370688 , 'sig_ref' : 0.06316842905267908 , 'sigma_norm' : 0.4961338951071746 , 'sign_sigma' : - 1.0 }, 'train' : { 'RMSD' : 0.08111001248781997 , 'RMSD_norm_unb' : 0.6549199203336652 , 'avg_est' : 0.6204429297293235 , 'avg_ref' : 0.6542569775479774 , 'bias' : - 0.033814047818653936 , 'normalised_bias' : - 0.27234526337748927 , 'rsquared' : 0.573229625070228 , 'sig_est' : 0.08824634698454116 , 'sig_ref' : 0.12415875128250474 , 'sigma_norm' : 0.7107541439729025 , 'sign_sigma' : - 1.0 }} OLS Model Similarly, we will use the joblib . load function: from os.path import join from sklearn.externals import joblib modelDir_OLS = '/path/to/model' filename_OLS = join ( modelDir_OLS , model_name_OLS ) # Load everything loaded_metrics = joblib . load ( filename_OLS + '_metrics.sav' ) loaded_params = joblib . load ( filename_OLS + '_parameters.sav' ) loaded_model = joblib . load ( filename_OLS + '_model.sav' ) print ( \"Loaded \" + model_name_OLS + \" from disk\" ) display ( loaded_params ) display ( loaded_metrics ) Output: Loaded CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25 from disk { 'features' : ([ 'REF' , 'CO_AD_BASE_STATION_CASE' ], [ 'A' , 'CO_MICS_RAW_STATION_CASE' ], [ 'B' , 'TEMP_STATION_CASE' ], [ 'C' , 'HUM_STATION_CASE' ], [ 'D' , 'PM_25_STATION_CASE' ]), 'formula' : 'REF ~ np.log10(A) + A + B + np.power(B,2) + D' } { 'test' : { 'RMSD' : 0.0440714230263565 , 'RMSD_norm_unb' : 0.8723428704290845 , 'avg_est' : 0.550690169722107 , 'avg_ref' : 0.5351888829750784 , 'bias' : 0.015501286747028664 , 'normalised_bias' : 0.30432821283315176 , 'rsquared' : 0.2513771504173782 , 'sig_est' : 0.031200761981503004 , 'sig_ref' : 0.05093608181350988 , 'sigma_norm' : 0.6125473509277183 , 'sign_sigma' : - 1.0 }, 'train' : { 'RMSD' : 0.062207196964372664 , 'RMSD_norm_unb' : 0.5279216759963998 , 'avg_est' : 0.6559505800446772 , 'avg_ref' : 0.6559505800448995 , 'bias' : - 2.2226664952995634e-13 , 'normalised_bias' : - 1.8862669894154184e-12 , 'rsquared' : 0.721298704013152 , 'sig_est' : 0.10007571794915669 , 'sig_ref' : 0.11783414054170561 , 'sigma_norm' : 0.849293061324077 , 'sign_sigma' : - 1.0 }} And that's it! Now it is time to iterate and compare our models. References Link Engineering statistics handbook \u21a9 \u21a9 \u21a9 \u21a9 Summary diagrams for coupled hydrodynamic-ecosystem model skill assessment (Jolliff et al.) \u21a9 Machine learning mastery \u21a9","title":"Creating Models for Sensors Calibration"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#creating-models-for-the-low-cost-sensors-calibration","text":"In this section, we will work on the development of two models for the MOS sensors in the Smart Smart Citizen Kit. In the Sensor Analysis Framework, we have implemented two different approaches for model calibration: Ordinary Least Squares (OLS) : based on the statsmodels package , the model is able to input whichever expression referring to the kit's available data and perform OLS regression over the defined training and test data Machine Learning (MLP or LSTM) : based on the keras package using tensorflow in the backend. This framework can be used to train larger collections of data, where we want to be, among others: Robust to noise Learn non-linear relationships Aware of temporal dependence","title":"Creating models for the low cost sensors calibration"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#ordinary-least-squares-example","text":"Let's delve first into an OLS example. The framework comes with a very simple interface to develop and interact with the models. By running these two cells we will generate the preliminary tweaks for the dataframes: from test_utils import combine_data name_combined_data = 'COMBINED_DEVICES' for reading in readings : ## Since we don't know if there are more or less channels than last time ## (and tbh, I don't feel like checking), remove the key readings [ reading ][ 'devices' ] . pop ( 'COMBINED_DEVICES' , None ) ## And then add it again dataframe = combine_data ( readings [ reading ][ 'devices' ], True ) readings [ reading ][ 'devices' ][ name_combined_data ] = dict () readings [ reading ][ 'devices' ][ name_combined_data ][ 'data' ] = dict () readings [ reading ][ 'devices' ][ name_combined_data ][ 'data' ] = dataframe Output: Dataframe has been combined for model preparation Here we can list all the available channels for our test: test_linear_regression = '2018-08_INT_STATION_TEST_SUMMER_HOLIDAYS' for channel in readings [ test_linear_regression ][ 'devices' ][ name_combined_data ][ 'data' ] . columns : print channel Output: BATT_4748 CO_AD_BASE_4748 CO_AD_BASE_filter_4748 CO_MICS_RAW_4748 EXT_HUM_4748 EXT_TEMP_4748 GB_1A_4748 GB_1W_4748 ( ... ) PM_1_4748 PM_10_4748 PM_25_4748 PM_DALLAS_TEMP_4748 PRESS_4748 TEMP_4748 O3_AD_BASE_filter_4748 And now, it's time to set up our model. In the cell below we can define the channel and features for the regression. from linear_regression_utils import prepData , fit_model ## Select data # Always have an item called 'REF', the rest can be anything tuple_features = ([ 'REF' , 'CO_AD_BASE_4748' ], [ 'A' , 'CO_MICS_RAW_4748' ], [ 'B' , 'TEMP_4748' ], [ 'C' , 'HUM_4748' ], [ 'D' , 'PM_25_4748' ]) formula_expression = 'REF ~ A + np.power(A,2) + B + np.power(B,2) + C + D' min_date = '2018-08-31 00:00:00' max_date = '2018-09-06 00:00:00' ratio_train = 2. / 3 # Important that this is a float, don't forget the . filter_data = True alpha_filter = 0.1 dataframeModel = readings [ test_linear_regression ][ 'devices' ][ name_combined_data ][ 'data' ] dataTrain , dataTest = prepData ( dataframeModel , tuple_features , min_date , max_date , ratio_train , filter_data , alpha_filter ) model , train_rmse , test_rmse = fit_model ( formula_expression , dataTrain , dataTest We have to keep at least the key 'REF ' within the tuple_features , but the rest can be renamed at will. We can also input whichever formula_expression for the model regression in the following format: formula_expression = 'REF ~ A + np.power(A,2) + B + np.power(B,2) + C + D' Which converts to: REF = A + A^2 + B + B^2 + C + D + Intercept REF = A + A^2 + B + B^2 + C + D + Intercept We can also define the ratio between the train and test dataset and the minimum dates to use within the datasets (globally): min_date = '2018-08-31 00:00:00' max_date = '2018-09-06 00:00:00' ratio_train = 2. / 3 # Important that this is a float, don't forget the . Finally, if our data is too noisy, we can apply an exponential smoothing function, by setting filter_data = True and the alpha coefficient (0.1, 0.2 is already very filtered: filter_data = True alpha_filter = 0.1 If we run this cell, we will perform model calibration, with the following output: OLS Regression Results ============================================================================== Dep . Variable : REF R - squared : 0.676 Model : OLS Adj . R - squared : 0.673 Method : Least Squares F - statistic : 197.5 Date : Thu , 06 Sep 2018 Prob ( F - statistic ): 1.87e-135 Time : 12 : 25 : 17 Log - Likelihood : 1142.9 No . Observations : 575 AIC : - 2272. Df Residuals : 568 BIC : - 2241. Df Model : 6 Covariance Type : nonrobust ================================================================================== coef std err t P >| t | [ 0.025 0.975 ] ---------------------------------------------------------------------------------- Intercept - 3.7042 0.406 - 9.133 0.000 - 4.501 - 2.908 A 0.0011 0.000 2.953 0.003 0.000 0.002 np . power ( A , 2 ) - 3.863e-05 7.03e-06 - 5.496 0.000 - 5.24e-05 - 2.48e-05 B 0.2336 0.024 9.863 0.000 0.187 0.280 np . power ( B , 2 ) - 0.0032 0.000 - 9.267 0.000 - 0.004 - 0.003 C - 0.0014 0.001 - 2.755 0.006 - 0.002 - 0.000 D 0.0127 0.001 24.378 0.000 0.012 0.014 ============================================================================== Omnibus : 7.316 Durbin - Watson : 0.026 Prob ( Omnibus ): 0.026 Jarque - Bera ( JB ): 10.245 Skew : - 0.076 Prob ( JB ): 0.00596 Kurtosis : 3.636 Cond . No . 4.29e+05 ============================================================================== Warnings : [ 1 ] Standard Errors assume that the covariance matrix of the errors is correctly specified . [ 2 ] The condition number is large , 4.29e+05 . This might indicate that there are strong multicollinearity or other numerical problems . This output brings a lot of information. First, we find what the dependent variable is, in our case always 'REF' . The type of model used and some general information is shown below that. More statistically important information is found in the rest of the output. Some key data: R-squared and adjusted R-squared : this is our classic correlation coefficient or R 2 . The adjusted one aims to correct the model overfitting by the inclusion of too many variables, and for that introduces a penalty on the number of variables included Below, we can find a summary of the model coefficients applied to all the variables and the P>|t| term, which indicates the significance of the term introduced in the model Model quality diagnostics are also indicated. Kurtosis and skewness are metrics for determining the distribution of the residuals. They indicate how the residuals of the model resemble a normal distribution. Below, we will review more on diagnosis plots. The Jarque Bera test indicates if the residuals are normally distributed (the null hypothesis is a joint hypothesis of the skewness being zero and the excess kurtosis being zero), and a value of zero indicates that the data is normally distributed. If the Jarque Bera test is valid (in the case above it isn't), the Durbin Watson is applicable in order to check for autocorrelation of the residuals (meaning that the residuals of our model are related among themselves and that we haven't captured some characteristics of our data with the tested model). Finally, there is a warning at the bottom indicating that the condition number is large. It suggests we might have multicollinearity problems in our model, which means that some of the independent variables might be correlated among themselves and that they are probably not necessary. Our function also depicts the results in a graphical way for us to see the model itself. It will show the training and test datasets (as Reference Train and Reference Test respectively), and the prediction results. The mean and absolute confidence intervals for 95% confidence are also shown: Now we can look at some other model quality plots. If we run the cell below, we will obtain an adaptation of the summary plots from R : from linear_regression_utils import modelRplots % matplotlib inline modelRplots ( model , dataTrain , dataTest ) Let's review the output step by step: Residual vs Fitted and Scale Location plot : these plots represents the model heteroscedasticity , which is a representation of the residuals versus the fitted values. This polot is helpful to check if the errors are distributed homogeneously and that we are not penalising high, low, or other values. There is also a red line which represents the average trend of this distribution which, we want it to be horizontal. For more information visit here and here . Clearly, in this model we are missing something: Normal QQ : the qq-plot is a representation of the kurtosis and skewness of the residuals distribution. If the data were well described by a normal distribution, the values should be about the same, i.e.: on the diagonal (red line). For example, in our case the model presents a deviation on both tails, indicating skewness. In general, a simple rubric to interpret a qq-plot is that if a given tail twists off counterclockwise from the reference line, there is more data in that tail of your distribution than in a theoretical normal, and if a tail twists off clockwise there is less data in that tail of your distribution than in a theoretical normal. In other words: if both tails twist counterclockwise we have heavy tails (leptokurtosis), if both tails twist clockwise, we have light tails (platykurtosis), if the right tail twists counterclockwise and the left tail twists clockwise, we have right skew if the left tail twists counterclockwise and the right tail twists clockwise, we have left skew Residuals vs Leverage : this plot is probably the most complex of them all. It shows how much leverage one single point has on the whole regression. It can be interpreted as how the average line that passes through all the data (that we are calculating with the OLS) can be modified by 'far' points in the distribution, for example, outliers. This leverage can be seen as how much a single point is able to pull down or up the average line. One way to think about whether or not the results are driven by a given data point is to calculate how far the predicted values for your data would move if your model were fit without the data point in question. This calculated total distance is called Cook's distance. We can have four cases (more information from source, here ) everything is fine (the best) high-leverage, but low-standardized residual point low-leverage, but high-standardized residual point high-leverage, high-standardized residual point (the worst) In this case, we see that our model has some points with higher leverage but low residuals (probably not too bad) and that the higher residuals are found with low leverage, which means that our model is safe to outliers. If we run this function without the filtering, some outliers will be present and the plot turns into:","title":"Ordinary Least Squares example"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#machine-learning-example","text":"As we have seen in the the calibration section , machine learning algorithms promise a better representation of the sensor's data, being able to learn robust non-linear models and sequential dependencies. For that reason, we have implemented an easy to use interface based on keras with Tensorflow backend, in order to train sequential models 3 . The workflow for a supervised learning algorithm reads as follows: Reframe the data as a supervised learning algorithm and split into training and test dataframe. More information can be found here Define Model and fit for training dataset Evaluate test dataframe and extract metrics Let's go step by step. In order to reframe the data as a supervised learning algorithm, we have created a function called prep_dataframe_ML which is the only one function we'll have to interact with: # Combine all data in one dataframe from ml_utils import prep_dataframe_ML # Always have an item called 'REF', the rest can be anything tuple_features = ([ 'REF' , 'CO_AD_BASE_STATION_CASE' ], [ 'A' , 'CO_MICS_RAW_STATION_CASE' ], [ 'B' , 'TEMP_STATION_CASE' ], [ 'C' , 'HUM_STATION_CASE' ], [ 'D' , 'PM_25_STATION_CASE' ]) model_name = 'LSTM NO2' ratio_train = 3. / 4 # Important that this is a float, don't forget the . alpha_filter = 0.9 # 1 means no filtering # Number of lags for the model n_lags = 1 dataframeModel = readings [ test_model ][ 'devices' ][ name_combined_data ][ 'data' ] index , train_X , train_y , test_X , test_y , scaler , n_train_periods = prep_dataframe_ML ( dataframeModel , min_date , max_date , tuple_features , n_lags , ratio_train , alpha_filter ) Output: DataFrame has been reframed and prepared for supervised learning Reference is : CO_AD_BASE_STATION_CASE Features are : [ 'CO_MICS_RAW_STATION_CASE' , 'TEMP_STATION_CASE' , 'HUM_STATION_CASE' , 'PM_25_STATION_CASE' ] Traning X Shape ( 1508 , 1 , 4 ), Training Y Shape ( 1508 ,), Test X Shape ( 501 , 1 , 4 ), Test Y Shape ( 501 ,) Now, we can fit our model. The main function is fit_model_ML and currently implements a simple LSTM network. This network can be redefined easily by modifying the underlying function. model = fit_model_ML ( train_X , train_y , test_X , test_y , epochs = 50 , batch_size = 72 , verbose = 2 ) def fit_model_ML ( train_X , train_y , test_X , test_y , epochs = 50 , batch_size = 72 , verbose = 2 ): model = Sequential () layers = [ 50 , 100 , 1 ] model . add ( LSTM ( layers [ 0 ], return_sequences = True , input_shape = ( train_X . shape [ 1 ], train_X . shape [ 2 ]))) model . add ( Dropout ( 0.2 )) model . add ( LSTM ( layers [ 1 ], return_sequences = False )) model . add ( Dropout ( 0.2 )) model . add ( Dense ( output_dim = layers [ 2 ])) model . add ( Activation ( \"linear\" )) model . compile ( loss = 'mse' , optimizer = 'rmsprop' ) # fit network history = model . fit ( train_X , train_y , epochs = epochs , batch_size = batch_size , validation_data = ( test_X , test_y ), verbose = verbose , shuffle = False ) # plot history fig = plot . figure ( figsize = ( 10 , 8 )) plot . plot ( history . history [ 'loss' ], label = 'train' ) plot . plot ( history . history [ 'val_loss' ], label = 'test' ) plot . xlabel ( 'Epochs (-)' ) plot . ylabel ( 'Loss (-)' ) plot . title ( 'Model Convergence' ) plot . legend ( loc = 'best' ) plot . show () return model This function will return the model and it's learning outcomes: Train on 1508 samples , validate on 501 samples Epoch 1 / 50 - 1 s - loss : 0.0500 - val_loss : 0.0051 Epoch 2 / 50 - 0 s - loss : 0.0200 - val_loss : 0.0058 Epoch 3 / 50 - 0 s - loss : 0.0158 - val_loss : 0.0052 ... Then, we can evaluate the model and plot it's results: from ml_utils import predict_ML from signal_utils import metrics import matplotlib.pyplot as plot % matplotlib inline inv_y_train , inv_yhat_train = predict_ML ( model , train_X , train_y , n_lags , scaler ) inv_y_test , inv_yhat_test = predict_ML ( model , test_X , test_y , n_lags , scaler )","title":"Machine learning example"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#model-comparison","text":"Here is a visual comparison of both models: fig = plot . figure ( figsize = ( 15 , 10 )) # Actual data plot . plot ( index [: n_train_periods ], inv_y_train , 'r' , label = 'Reference Train' , alpha = 0.3 ) plot . plot ( index [ n_train_periods + n_lags :], inv_y_test , 'b' , label = 'Reference Test' , alpha = 0.3 ) # Fitted Values for Training plot . plot ( index [: n_train_periods ], inv_yhat_train , 'r' , label = 'ML Prediction Train' ) plot . plot ( index [ n_train_periods + n_lags :], inv_yhat_test , 'b' , label = 'ML Prediction Test' ) # OLS plot . plot ( dataTrain [ 'index' ], predictionTrain , 'g' , label = 'OLS Prediction Train' ) plot . plot ( dataTest [ 'index' ], predictionTest , 'k' , label = 'OLS Prediction Test' ) plot . legend ( loc = 'best' ) plot . ylabel ( 'CO (ppm)' ) plot . xlabel ( 'Date (-)' ) Output: It is very difficult though, to know which one is performing better. Let's then evaluate and compare our models. In order to evaluate it's metrics, we will be using the following principles 1 2 : Info In all of the expressions below, the letter m indicates the model field, r indicates the reference field. Overbar is average and \\sigma \\sigma is the standard deviation. Linear correlation Coefficient A measure of the agreement between two signals: R = {{1 \\over N} \\sum_{i=0}^n (m_n-\\overline m)( r_n-\\overline r ) \\over \\sigma_m\\sigma_r} R = {{1 \\over N} \\sum_{i=0}^n (m_n-\\overline m)( r_n-\\overline r ) \\over \\sigma_m\\sigma_r} The correlation coefficient is bounded by the range -1 \\le R \\le 1 -1 \\le R \\le 1 . However, it is difficult to discern information about the differences in amplitude between two signals from R alone. Normalized standard deviation A measure of the differences in amplitude between two signals: $$ \\sigma * = {\\sigma_m \\over \\sigma_r} $$ unbiased Root-Mean-Square Difference A measure of how close the modelled points fall to teach other: RMSD' = \\Bigl( {1 \\over N} \\sum_{n=1}^N [(m_n - \\overline m)-(r_n - \\overline r)]^2 \\Bigr)^{0.5} RMSD' = \\Bigl( {1 \\over N} \\sum_{n=1}^N [(m_n - \\overline m)-(r_n - \\overline r)]^2 \\Bigr)^{0.5} Potential Bias Difference between the means of two fields: $$ B = \\overline m - \\overline r $$ Total RMSD A measure of the average magnitude of difference: $$ RMSD = \\Bigl( {1 \\over N} \\sum_{n=1}^N (m_n - r_n)^2 \\Bigr)^{0.5} $$ In other words, the unbiased RMSD (RMSD') is equal to the total RMSD if there is no bias between the model and the reference fields (i.e. B = 0). The relationship between both reads: RMSD^2 = B^2 + RMSD'^2 RMSD^2 = B^2 + RMSD'^2 In contrast, the unbiased RMSD may be conceptualized as an overall measure of the agreement between the aplitude ( \\sigma \\sigma ) and phase ( \\phi \\phi ) of two temporal patterns. For this reason, the correlation coefficient ( R R ), normalised standard deviation ( \\sigma* \\sigma* ), and unbiased RMSD are all referred to as patern statistics , related to one another by: RMSD'^2 = \\sigma_r^2 + \\sigma_m^2 - 2\\sigma_r\\sigma_mR RMSD'^2 = \\sigma_r^2 + \\sigma_m^2 - 2\\sigma_r\\sigma_mR Normalized and unbiased RMSD If we recast in standard deviation normalized units (indicated by the asterisk) it becomes: RMSD'^* = \\sqrt { 1 + \\sigma*^2 - 2\\sigma*R} RMSD'^* = \\sqrt { 1 + \\sigma*^2 - 2\\sigma*R} NB : the minimum of this function occurrs when \\sigma* = R \\sigma* = R . Normalized bias Gives information about the mean difference but normalized by the \\sigma* \\sigma* $$ B* = {\\overline m - \\overline r \\over \\sigma_r} $$ Target diagrams The target diagram is a plot that provides summary information about the pattern statistics as well as the bias thus yielding an overview of their respective contributions to the total RMSD. In a simple Cartesian coordinate system, the unbiased RMSD may serve as the X-axis and the bias may serve as the Y-axis. The distance between the origin and the model versus observation statistics (any point, s, within the X,Y Cartesian space) is then equal to the total RMSD. If all is normalized by the \\sigma_r \\sigma_r , the distance from the origin is again the standard deviation normalized total RMSD : 1 RMSD^{*2} = B^{*2}+RMSD^{*'2} RMSD^{*2} = B^{*2}+RMSD^{*'2} The resulting target diagram then provides information about: whether the \\sigma_m \\sigma_m is larger or smaller thann the \\sigma_r \\sigma_r whether there is a positive or negative bias Image Source: Jolliff et al. 1 Any point greater than RMSD*=1 is to be considered a poor performer since it doesn't offer improvement over the time series average. Interestingly, the target diagram has no information about the correlation coefficient R, but some can be inferred, knowing that all the points within the RMSD* <1 are positively correlated (R>0), although, in 1 it is shown that a circle marker with radius M_{R1} M_{R1} , means that all the points between that marker and the origin have a R coefficient larger than R1, where: M_{R1} = min(RMSD*') = \\sqrt {1+R1^2-2R1^2} M_{R1} = min(RMSD*') = \\sqrt {1+R1^2-2R1^2}","title":"Model comparison"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#results","text":"Let's now compare both models. If we execute this line, we will retrieve all model metrics: metrics_model_train = metrics ( inv_y_train , inv_yhat_train ) metrics_model_test = metrics ( inv_y_test , inv_yhat_test ) ## Metrics Train print ( ' \\t\\t Train \\t\\t Test' ) for item in metrics_model_train . keys (): print ( ' % s : \\t %.5f \\t %.5f ' % ( item , metrics_model_train [ item ], metrics_model_test [ item ])) Output: Train Test avg_ref : 0.65426 0.53583 sig_est : 0.08412 0.03160 RMSD : 0.08439 0.05511 avg_est : 0.61639 0.53135 sigma_norm : 0.67749 0.50032 sign_sigma : - 1.00000 - 1.00000 sig_ref : 0.12416 0.06317 bias : - 0.03787 - 0.00448 RMSD_norm_unb : 0.68200 0.87258 rsquared : 0.53801 0.23874 normalised_bias : - 0.30502 - 0.07093 And finally, we can compare both models, training and test dataframe with the function: targetDiagram ( _dataframe , _plot_train ) Output: Here, every point that falls inside the yellow circle, will have an R 2 over 0.7, and so will be the red and green for R 2 over 0.5 and 0.9 respectively. We see that only one of our models performs well in that sense, which is the training dataset of the OLS. However, this dataset performs pretty badly in the test dataset, being the LSTM options much better. This target diagram offers information about how the hyperparameters affect our networks. For instance, increasing the training epochs from 100 to 200 does not affect greatly on model performance, but the effect of filtering the data beforehand to reduce the noise shows a much better model performance in both, training and test dataframe.","title":"Results"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#export-the-models","text":"Let's now assume that we are happy with our models. Depending on the model we have developed (OLS or ML ), we follow different approaches for the export: Machine Learning Model We will use joblib to save the model metrics and parameters. The keras model will be saved with the to_json property of the model and the weights in an h5 format with the save_weights ght: from os.path import join from sklearn.externals import joblib modelDirML = '/path/to/modelDir' filenameML = join ( modelDirML , model_name_ML ) # Save everything joblib . dump ( dictModel [ model_name_ML ][ 'metrics' ], filenameML + '_metrics.sav' ) joblib . dump ( dictModel [ model_name_ML ][ 'parameters' ], filenameML + '_parameters.sav' ) model_json = model . to_json () with open ( filenameML + \"_model.json\" , \"w\" ) as json_file : json_file . write ( model_json ) model . save_weights ( filenameML + \"_model.h5\" ) print ( \"Model \" + model_name_ML + \" saved in: \" + modelDir ) Output: Model LSTM CO 200 epochs Filter 0.9 saved in : / path / to / modelDir And in our directory: \u279c models ls -l -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_metrics.sav -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_model.h5 -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_model.json -rw-r--r-- Sep 11 12 :54 LSTM CO 200 epochs Filter 0 .9_parameters.sav OLS model We will use joblib for all the objects serialisation in this case: from os.path import join from sklearn.externals import joblib modelDir_OLS = '/path/to/model' filename_OLS = join ( modelDir_OLS , model_name_OLS ) # Save everything joblib . dump ( dictModel [ model_name_OLS ][ 'metrics' ], filename_OLS + '_metrics.sav' ) joblib . dump ( dictModel [ model_name_OLS ][ 'parameters' ], filename_OLS + '_parameters.sav' ) joblib . dump ( dictModel [ model_name_OLS ][ 'model' ], filename_OLS + '_model.sav' ) print ( \"Model saved in: \" + modelDir_OLS ) Output: Model saved in : / path / to / model And in the terminal: \u279c models ls -l total 1928 -rw-r--r-- Sep 11 12 :53 CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25_metrics.sav -rw-r--r-- Sep 11 12 :53 CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25_model.sav -rw-r--r-- Sep 11 12 :53 CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25_parameters.sav","title":"Export the models"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#load-models-from-disk","text":"Now, sometime after having exported our model, let's assume we need to get it back: Machine Learning Model We will use the symmetric functions from joblib and keras : from os.path import join from sklearn.externals import joblib from keras.models import model_from_json modelDirML = '/path/to/model' filenameML = join ( modelDirML , model_name_ML ) # Load Model and weights json_file = open ( filenameML + \"_model.json\" , \"r\" ) loaded_model_json = json_file . read () json_file . close () loaded_model = model_from_json ( loaded_model_json ) loaded_model . load_weights ( filenameML + \"_model.h5\" ) print ( \"Loaded \" + model_name_ML + \" from disk\" ) # Load params and metrics loaded_params = joblib . load ( filenameML + '_parameters.sav' ) loaded_metrics = joblib . load ( filenameML + '_metrics.sav' ) display ( loaded_params ) display ( loaded_metrics ) Output: Loaded LSTM CO 200 epochs Filter 0.9 from disk { 'features' : ([ 'REF' , 'CO_AD_BASE_STATION_CASE' ], [ 'A' , 'CO_MICS_RAW_STATION_CASE' ], [ 'B' , 'TEMP_STATION_CASE' ], [ 'C' , 'HUM_STATION_CASE' ], [ 'D' , 'PM_25_STATION_CASE' ])} { 'test' : { 'RMSD' : 0.055340715974325445 , 'RMSD_norm_unb' : 0.8761932784857427 , 'avg_est' : 0.5344016428091338 , 'avg_ref' : 0.5358268506805136 , 'bias' : - 0.0014252078713797856 , 'normalised_bias' : - 0.022562028100955915 , 'rsquared' : 0.23248054249786632 , 'sig_est' : 0.03133999875370688 , 'sig_ref' : 0.06316842905267908 , 'sigma_norm' : 0.4961338951071746 , 'sign_sigma' : - 1.0 }, 'train' : { 'RMSD' : 0.08111001248781997 , 'RMSD_norm_unb' : 0.6549199203336652 , 'avg_est' : 0.6204429297293235 , 'avg_ref' : 0.6542569775479774 , 'bias' : - 0.033814047818653936 , 'normalised_bias' : - 0.27234526337748927 , 'rsquared' : 0.573229625070228 , 'sig_est' : 0.08824634698454116 , 'sig_ref' : 0.12415875128250474 , 'sigma_norm' : 0.7107541439729025 , 'sign_sigma' : - 1.0 }} OLS Model Similarly, we will use the joblib . load function: from os.path import join from sklearn.externals import joblib modelDir_OLS = '/path/to/model' filename_OLS = join ( modelDir_OLS , model_name_OLS ) # Load everything loaded_metrics = joblib . load ( filename_OLS + '_metrics.sav' ) loaded_params = joblib . load ( filename_OLS + '_parameters.sav' ) loaded_model = joblib . load ( filename_OLS + '_model.sav' ) print ( \"Loaded \" + model_name_OLS + \" from disk\" ) display ( loaded_params ) display ( loaded_metrics ) Output: Loaded CO_MICS + Log ( CO_MICS ) + Poly ( T ) + PM25 from disk { 'features' : ([ 'REF' , 'CO_AD_BASE_STATION_CASE' ], [ 'A' , 'CO_MICS_RAW_STATION_CASE' ], [ 'B' , 'TEMP_STATION_CASE' ], [ 'C' , 'HUM_STATION_CASE' ], [ 'D' , 'PM_25_STATION_CASE' ]), 'formula' : 'REF ~ np.log10(A) + A + B + np.power(B,2) + D' } { 'test' : { 'RMSD' : 0.0440714230263565 , 'RMSD_norm_unb' : 0.8723428704290845 , 'avg_est' : 0.550690169722107 , 'avg_ref' : 0.5351888829750784 , 'bias' : 0.015501286747028664 , 'normalised_bias' : 0.30432821283315176 , 'rsquared' : 0.2513771504173782 , 'sig_est' : 0.031200761981503004 , 'sig_ref' : 0.05093608181350988 , 'sigma_norm' : 0.6125473509277183 , 'sign_sigma' : - 1.0 }, 'train' : { 'RMSD' : 0.062207196964372664 , 'RMSD_norm_unb' : 0.5279216759963998 , 'avg_est' : 0.6559505800446772 , 'avg_ref' : 0.6559505800448995 , 'bias' : - 2.2226664952995634e-13 , 'normalised_bias' : - 1.8862669894154184e-12 , 'rsquared' : 0.721298704013152 , 'sig_est' : 0.10007571794915669 , 'sig_ref' : 0.11783414054170561 , 'sigma_norm' : 0.849293061324077 , 'sign_sigma' : - 1.0 }} And that's it! Now it is time to iterate and compare our models.","title":"Load Models from Disk"},{"location":"Sensor Analysis Framework/guides/Creating Models for Sensors Calibration/#references","text":"Engineering statistics handbook \u21a9 \u21a9 \u21a9 \u21a9 Summary diagrams for coupled hydrodynamic-ecosystem model skill assessment (Jolliff et al.) \u21a9 Machine learning mastery \u21a9","title":"References"},{"location":"Sensor Analysis Framework/guides/Install the framework/","text":"How to install the framework Link The following data analysis framework is built on Python 2.7 and Jupyter Notebooks. Here we will show you how to install it: Dowload and Install Anaconda for Python 2.7 https://www.continuum.io/downloads Visit Github to download the project folder or simply use git . Open the Anaconda Navigator app and launch the Jupyter Notebook . Using the Jupyter Notebook website browse your computer to find the project folder. Ready Go and check How to use the notebook Learn More Still wondering what this is? Read this introduction to Jupyter Advanced Installation If you are already familiar with Python and you like to avoid installing Anaconda and follow the Advanced users installation Worried about your existing Python? Do you have already a Python environment you use for other work and you are worried about updating some packages? Learn how to load a dedicated environment Advanced installation features Link How to run the project isolated from your Python environment Link Do you have already a Python environment you use for other work and you are worried about updating some packages? Conda can load a dedicated environment for you to run Python and Jupyter based on the environment . yml configuration file we provide. Open your favourite shell on the directory you have your project. ( cmd . exe on windows) Run the following commands: This will install and load the Python environment we prepared for iSCAPE conda env create - f environment . yml Now activate the environment source activate iscape Ready, run to run Jupyter jupyter notebook Advanced users installation Link If you do not want to install Anaconda you can install all the dependencies manually. Just follow the steps above: Install Python Link Python is the main programming language we will use for Data Analysis. On Windows download and run the installer for Python 2.7 Mac cames directly with python built in. However you can install the latest version using Hombrew and then run $ brew install python On Linux simply use your distribution package manager like $ apt in Debian or Ubuntu. Install Pip Link Pip is the packet manager Python uses and it comes installed by default. If you have any issues you can download pip here . Installl Jupyter Link Jupyter Notebooks allows us to quickly learn, develop and improve our tools by providing a common convenient framework and UI. Simply run pip install jupyter on your terminal to install it. Download the source Link Download from Github or simply use git git clone https : // github . com / fablabbcn / smartcitizen - iscape - data . git Run the notebook Link On your terminal go to the folder where tou downloaded your files and then run jupyter notebook this will open a new webpage and you will be available to run your code there.","title":"Install the framework"},{"location":"Sensor Analysis Framework/guides/Install the framework/#how-to-install-the-framework","text":"The following data analysis framework is built on Python 2.7 and Jupyter Notebooks. Here we will show you how to install it: Dowload and Install Anaconda for Python 2.7 https://www.continuum.io/downloads Visit Github to download the project folder or simply use git . Open the Anaconda Navigator app and launch the Jupyter Notebook . Using the Jupyter Notebook website browse your computer to find the project folder. Ready Go and check How to use the notebook Learn More Still wondering what this is? Read this introduction to Jupyter Advanced Installation If you are already familiar with Python and you like to avoid installing Anaconda and follow the Advanced users installation Worried about your existing Python? Do you have already a Python environment you use for other work and you are worried about updating some packages? Learn how to load a dedicated environment","title":"How to install the framework"},{"location":"Sensor Analysis Framework/guides/Install the framework/#advanced-installation-features","text":"","title":"Advanced installation features"},{"location":"Sensor Analysis Framework/guides/Install the framework/#how-to-run-the-project-isolated-from-your-python-environment","text":"Do you have already a Python environment you use for other work and you are worried about updating some packages? Conda can load a dedicated environment for you to run Python and Jupyter based on the environment . yml configuration file we provide. Open your favourite shell on the directory you have your project. ( cmd . exe on windows) Run the following commands: This will install and load the Python environment we prepared for iSCAPE conda env create - f environment . yml Now activate the environment source activate iscape Ready, run to run Jupyter jupyter notebook","title":"How to run the project isolated from your Python environment"},{"location":"Sensor Analysis Framework/guides/Install the framework/#advanced-users-installation","text":"If you do not want to install Anaconda you can install all the dependencies manually. Just follow the steps above:","title":"Advanced users installation"},{"location":"Sensor Analysis Framework/guides/Install the framework/#install-python","text":"Python is the main programming language we will use for Data Analysis. On Windows download and run the installer for Python 2.7 Mac cames directly with python built in. However you can install the latest version using Hombrew and then run $ brew install python On Linux simply use your distribution package manager like $ apt in Debian or Ubuntu.","title":"Install Python"},{"location":"Sensor Analysis Framework/guides/Install the framework/#install-pip","text":"Pip is the packet manager Python uses and it comes installed by default. If you have any issues you can download pip here .","title":"Install Pip"},{"location":"Sensor Analysis Framework/guides/Install the framework/#installl-jupyter","text":"Jupyter Notebooks allows us to quickly learn, develop and improve our tools by providing a common convenient framework and UI. Simply run pip install jupyter on your terminal to install it.","title":"Installl Jupyter"},{"location":"Sensor Analysis Framework/guides/Install the framework/#download-the-source","text":"Download from Github or simply use git git clone https : // github . com / fablabbcn / smartcitizen - iscape - data . git","title":"Download the source"},{"location":"Sensor Analysis Framework/guides/Install the framework/#run-the-notebook","text":"On your terminal go to the folder where tou downloaded your files and then run jupyter notebook this will open a new webpage and you will be available to run your code there.","title":"Run the notebook"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/","text":"Post processing the Stations Data Link The stations data can be fully processed within the sensor analysis framework provided. In this guide, we will go through a working live example that will use available data from a permanent Smart Citizen Station in Fablab BCN . The available sensors are listed here . Load in the data Link So first, we will load in the data from this station. The device number is the 4748 , and is available in here . We will use the available interface in our framework to load the station data. In this case, we will load all the available data into our notebook, but if we wanted, we could use the interface to set up time limits, should the timeframe desired be different: Info In the field Kit list we can also input a comma separated list of devices such as: 4748 , 4565 , 4587 and we will load all the data for you. We can now explore the available readings in our test with something like: ## This will output the devices we have in the selected test print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ] . keys () Output : [ u '4748' ] If we want to have access to the actual data, we can go under: ## This will output the dataframe's first 4 lines print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'data' ] . head ( 4 ) Output : BATT CO_MICS_RAW EXT_HUM EXT_TEMP GB_1A \\ 2018 - 08 - 24 17 : 00 : 00 + 02 : 00 0 . 0 73 . 441111 47 . 652222 30 . 663333 4 . 517778 2018 - 08 - 24 17 : 10 : 00 + 02 : 00 0 . 0 129 . 049000 46 . 632000 31 . 209000 3 . 905000 2018 - 08 - 24 17 : 20 : 00 + 02 : 00 0 . 0 53 . 738333 45 . 901667 31 . 616667 3 . 808333 2018 - 08 - 24 17 : 30 : 00 + 02 : 00 74 . 5 122 . 405000 45 . 655000 31 . 810000 3 . 925000 ... Or if we want to see the available recordings: ## This will output the dataframe columns print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'data' ] . columns Output : Index ([ u 'BATT' , u 'CO_MICS_RAW' , u 'EXT_HUM' , u 'EXT_TEMP' , u 'GB_1A' , u 'GB_1W' , u 'GB_2A' , u 'GB_2W' , u 'GB_3A' , u 'GB_3W' , u 'HUM' , u 'LIGHT' , u 'NO2_MICS_RAW' , u 'PM_1' , u 'PM_10' , u 'PM_25' , u 'PM_DALLAS_TEMP' , u 'PRESS' , u 'TEMP' ], dtype = 'object' ) For more information about the test structure , all the fields are detailed in here . If the device is an station, we will have to input the sensor references for the alphasense devices. We have prepared the framework to input this easily: ## This will output the structure for inputing the alphasense sensor refs print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ] Output : { 'O3' : 'TEMPORARY_O3' , 'SLOTS' : 'TEMPORARY_SLOTS' , 'CO' : 'TEMPORARY_CO' , 'NO2' : 'TEMPORARY_NO2' } As you can see, we have no data in this struct, but we can easily fill it put by: readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'O3' ] = 204560316 readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'NO2' ] = 202160413 readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'CO' ] = 162031257 readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'SLOTS' ] = ( 'NO2' , 'CO' , 'O3' ) print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ] Output : { 'O3' : 204560316 , 'SLOTS' : ( 'NO2' , 'CO' , 'O3' ), 'CO' : 162031257 , 'NO2' : 202160413 } Note that each of these fields is necessary for our posterior calculations. Each of the O3 , NO ~ 2 ~ , CO fields relate to the manufacturer's reference of each of the sensors, whilst the SLOTS field relates to the order at which the sensors are placed. Normally , the stations are delivered with the SLOTS field as: ( 'CO' , 'NO~2~' , 'O3' ) , meaning that the CO sensor is in the slot #1, the NO 2 sensor in the slot #2 and the O3 sensor in the slot #3. Info Normally we refer to the OX-B431 sensor as O3, although it measures both, O3+NO 2 mixing ratios, and therefore we use O3 or OX indistinctively. Warning You might have noticed that the slots we have input are not matching to our own description... Our bad! Explore the data Link We can now have a look at the station's data. We can go to the Section Exploratory Data Analysis and use the range of available interfaces for the data analysis. We would like to serve this as a flexible tool, in which the priority is to generate proper analysis. For this, we have some interesting interactive plots as: Time Series Plot Back2Back correlation plots Correlogram Heat maps Let's run a simple example. We will plot all the concerned alphasense signals using the interface. We could also do this by code, but we find it less time consuming and more data analysis dedicated: We can select within the channels available in the dataframe, for each of the devices within a test. All the devices are supossed to have overlapping timestamps, so they can be compared easily. Hence, here is where the concept of test is interesting, since all the devices within a test can be easily grouped and compared: In this example we have selected all three alphasense sensors available data and plotted them with the working and auxiliary electrodes. We can here explore with the plotly integrated commands to review the data. Here, it is important to see how the sensors adapt to the environment once they have their power restored after a power cut, or after the first use. For example, in the case of the CO measurement, after the power restorage on 31 st of August, the sensor is clearly experiencing an stabilisation that has to be discarded in our calculations: We can also see how some metrics correlate among themselves and analyse potential sources for multicollinearity in our model. For this, we will study how every two measurments correlate among themselves in the following interface: We will use a very straightforward example: let's see how temperature and relative humidity correlate and see if there might be variations in the absolute humidity that might affect the variations in the relative humidity that are not explained by the temperature. If we select our channels and Check on Crop Data in X axis and input our dates we will have the following: Here, we can see that both are anticorrelated (Pearson = -0.61) and although they have a clear inverse trend, their R2 is low: This might indicate that the variations in the humidity are not fully explained by the temperature variations and, that there might be variations in the absolute humidity that we could account for in our models. Adding calculated channels Link Let's then add the partial vapour pressure in our dataset. Based on the definition of the relative humidity (RH): RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} Where P_{H_2O} P_{H_2O} is the partial vapour pressure and P^*_{H_2O} P^*_{H_2O} is the equilibrium vapour pressure at a certain pressure and temperature. This equilibrium vapour pressure can be determined by the Arden Buck Equation and goes like: P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} Where P P is the absolute pressure in mbar and T T is the temperature in degC. Having the partial vapour pressure, we can then calculate both values in the implemented calculator in our notebook: Here, the formula is: ## Calculate equilibrium vapour pressure P_H2O_EQ = ( 1.0007 + 3.46 * 1e-6 * PRESS * 10 ) * 6.1121 * np . exp ( 17.502 * TEMP / ( 240.97 + TEMP )) Note that we can input any type of expression in the Formula Field that can be subject to evaluation as in a Python formula. Note as well that numpy operations are allowed and that they can be written in line. Info If you want to calculate this formula for several devices within a test, select all of them and the calculator will make the available in the dropdowns the common metrics. Now, we can calculate de partial vapour pressure as, since it's available within our channels: ## Calculate partial vapour pressure P_H2O_VAP = HUM * P_H2O_EQ / 100 We can now verify that the partial pressure is not constant and plotting it with the other channels: If we analyse the data in periods where the partial vapour pressure is fairly constant (i.e. 31 st of Aug, we see that variations of the temperature are directly correlated with the relative humidity, whilst days as the 2 nd of September show greater variations in both, temperature and partial vapour pressure that provoke a lower correlation in the temperature and humidity: Calculating the actual pollutant concentrations Link Now that we know how to get around in the notebook, explore data and add channels in a simple way, lets calculate actual pollutant concentrations. For this, we will use the section AlphaSense Baseline Calibration . In this block, we will apply the methodology exlained in this section in order to calculate actual pollutant concentrations. For this, in the above mentioned section, if we run the cell, we will see an output like the following: This will list all the available devices that contain alphasense data. Remember to include the calibration data mentioned before in the dict so that we can calculate the final concentrations. For reference, all the alphasense data is under this repository , which looks like: { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162031254\" , \"Sensitivity 1\" : \"568.3\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-34\" , \"Aux Zero Current\" : \"-20.8\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162031257\" , \"Sensitivity 1\" : \"493.1\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-69.4\" , \"Aux Zero Current\" : \"-18.6\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162031256\" , \"Sensitivity 1\" : \"601.9\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-68.1\" , \"Aux Zero Current\" : \"-13.9\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162581706\" , \"Sensitivity 1\" : \"581.4\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-72.8\" , \"Aux Zero Current\" : \"-35.3\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162581707\" , \"Sensitivity 1\" : \"605\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-56.7\" , \"Aux Zero Current\" : \"-46.3\" } In the cell output, we can select the tests that contain alphasense devices and that are subject to be calculated. A brief explanation of all the checkboxes is detailed below: Decomp : attemps to decompose the trends found in the day-to-day data. This is a common technique used in time series analysis in order to avoid regression including trend. It is normally not needed since the periods that are used for the data calculacions are short enough to have no significant trend (one day + overlap*) Plots Inter : checking this plots intermediary plots of all the calculations performed within the method. Use with caution Verbose : checking this includes extra information during the calculation process. Use with caution Plots Results : plots the final calculation per pollutant and all relevant intermediary calculation. Default is to be Checked Print Stats : prints interesting statistics about the dataset for later use Now, let's calculate the pollutants. We don't need to worry about the manufacturer data, since it will automatically retrieved during the process. CO results The methodology used here is not the baseline model, but the application of this formula, as explained in here : Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} As we can see, the initial data is not to be considered due to the sensor stabilisation time. If we focus on the usable data, we can already get some insights about what hours are more polluted and the difference between working days and weekends: NO 2 results For this metric, we will be using the above mentioned baseline methodology If we have a look at the data, we see that the sensor still requires stabilisation, as the CO electrode: Zooming in, we can see the most polluted hours are those in the morning: Warning OX sensor in this station is not giving good results (probably it's ageing has provoked a sensitivity loss), and therefore, the data will not be shown here.","title":"Post processing the Stations Data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#post-processing-the-stations-data","text":"The stations data can be fully processed within the sensor analysis framework provided. In this guide, we will go through a working live example that will use available data from a permanent Smart Citizen Station in Fablab BCN . The available sensors are listed here .","title":"Post processing the Stations Data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#load-in-the-data","text":"So first, we will load in the data from this station. The device number is the 4748 , and is available in here . We will use the available interface in our framework to load the station data. In this case, we will load all the available data into our notebook, but if we wanted, we could use the interface to set up time limits, should the timeframe desired be different: Info In the field Kit list we can also input a comma separated list of devices such as: 4748 , 4565 , 4587 and we will load all the data for you. We can now explore the available readings in our test with something like: ## This will output the devices we have in the selected test print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ] . keys () Output : [ u '4748' ] If we want to have access to the actual data, we can go under: ## This will output the dataframe's first 4 lines print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'data' ] . head ( 4 ) Output : BATT CO_MICS_RAW EXT_HUM EXT_TEMP GB_1A \\ 2018 - 08 - 24 17 : 00 : 00 + 02 : 00 0 . 0 73 . 441111 47 . 652222 30 . 663333 4 . 517778 2018 - 08 - 24 17 : 10 : 00 + 02 : 00 0 . 0 129 . 049000 46 . 632000 31 . 209000 3 . 905000 2018 - 08 - 24 17 : 20 : 00 + 02 : 00 0 . 0 53 . 738333 45 . 901667 31 . 616667 3 . 808333 2018 - 08 - 24 17 : 30 : 00 + 02 : 00 74 . 5 122 . 405000 45 . 655000 31 . 810000 3 . 925000 ... Or if we want to see the available recordings: ## This will output the dataframe columns print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'data' ] . columns Output : Index ([ u 'BATT' , u 'CO_MICS_RAW' , u 'EXT_HUM' , u 'EXT_TEMP' , u 'GB_1A' , u 'GB_1W' , u 'GB_2A' , u 'GB_2W' , u 'GB_3A' , u 'GB_3W' , u 'HUM' , u 'LIGHT' , u 'NO2_MICS_RAW' , u 'PM_1' , u 'PM_10' , u 'PM_25' , u 'PM_DALLAS_TEMP' , u 'PRESS' , u 'TEMP' ], dtype = 'object' ) For more information about the test structure , all the fields are detailed in here . If the device is an station, we will have to input the sensor references for the alphasense devices. We have prepared the framework to input this easily: ## This will output the structure for inputing the alphasense sensor refs print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ] Output : { 'O3' : 'TEMPORARY_O3' , 'SLOTS' : 'TEMPORARY_SLOTS' , 'CO' : 'TEMPORARY_CO' , 'NO2' : 'TEMPORARY_NO2' } As you can see, we have no data in this struct, but we can easily fill it put by: readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'O3' ] = 204560316 readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'NO2' ] = 202160413 readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'CO' ] = 162031257 readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ][ 'SLOTS' ] = ( 'NO2' , 'CO' , 'O3' ) print readings [ 'STATION_FABLAB_BCN' ][ 'devices' ][ '4748' ][ 'alphasense' ] Output : { 'O3' : 204560316 , 'SLOTS' : ( 'NO2' , 'CO' , 'O3' ), 'CO' : 162031257 , 'NO2' : 202160413 } Note that each of these fields is necessary for our posterior calculations. Each of the O3 , NO ~ 2 ~ , CO fields relate to the manufacturer's reference of each of the sensors, whilst the SLOTS field relates to the order at which the sensors are placed. Normally , the stations are delivered with the SLOTS field as: ( 'CO' , 'NO~2~' , 'O3' ) , meaning that the CO sensor is in the slot #1, the NO 2 sensor in the slot #2 and the O3 sensor in the slot #3. Info Normally we refer to the OX-B431 sensor as O3, although it measures both, O3+NO 2 mixing ratios, and therefore we use O3 or OX indistinctively. Warning You might have noticed that the slots we have input are not matching to our own description... Our bad!","title":"Load in the data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#explore-the-data","text":"We can now have a look at the station's data. We can go to the Section Exploratory Data Analysis and use the range of available interfaces for the data analysis. We would like to serve this as a flexible tool, in which the priority is to generate proper analysis. For this, we have some interesting interactive plots as: Time Series Plot Back2Back correlation plots Correlogram Heat maps Let's run a simple example. We will plot all the concerned alphasense signals using the interface. We could also do this by code, but we find it less time consuming and more data analysis dedicated: We can select within the channels available in the dataframe, for each of the devices within a test. All the devices are supossed to have overlapping timestamps, so they can be compared easily. Hence, here is where the concept of test is interesting, since all the devices within a test can be easily grouped and compared: In this example we have selected all three alphasense sensors available data and plotted them with the working and auxiliary electrodes. We can here explore with the plotly integrated commands to review the data. Here, it is important to see how the sensors adapt to the environment once they have their power restored after a power cut, or after the first use. For example, in the case of the CO measurement, after the power restorage on 31 st of August, the sensor is clearly experiencing an stabilisation that has to be discarded in our calculations: We can also see how some metrics correlate among themselves and analyse potential sources for multicollinearity in our model. For this, we will study how every two measurments correlate among themselves in the following interface: We will use a very straightforward example: let's see how temperature and relative humidity correlate and see if there might be variations in the absolute humidity that might affect the variations in the relative humidity that are not explained by the temperature. If we select our channels and Check on Crop Data in X axis and input our dates we will have the following: Here, we can see that both are anticorrelated (Pearson = -0.61) and although they have a clear inverse trend, their R2 is low: This might indicate that the variations in the humidity are not fully explained by the temperature variations and, that there might be variations in the absolute humidity that we could account for in our models.","title":"Explore the data"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#adding-calculated-channels","text":"Let's then add the partial vapour pressure in our dataset. Based on the definition of the relative humidity (RH): RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} RH ( \\% )= 100 {P_{H2O} \\over P^*_{H2O}} Where P_{H_2O} P_{H_2O} is the partial vapour pressure and P^*_{H_2O} P^*_{H_2O} is the equilibrium vapour pressure at a certain pressure and temperature. This equilibrium vapour pressure can be determined by the Arden Buck Equation and goes like: P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} P^*_{H2O} (mbar) = (1,0007+3,46x10^{-6}xP)x6.1121e^{17,520T/(240,97+T)} Where P P is the absolute pressure in mbar and T T is the temperature in degC. Having the partial vapour pressure, we can then calculate both values in the implemented calculator in our notebook: Here, the formula is: ## Calculate equilibrium vapour pressure P_H2O_EQ = ( 1.0007 + 3.46 * 1e-6 * PRESS * 10 ) * 6.1121 * np . exp ( 17.502 * TEMP / ( 240.97 + TEMP )) Note that we can input any type of expression in the Formula Field that can be subject to evaluation as in a Python formula. Note as well that numpy operations are allowed and that they can be written in line. Info If you want to calculate this formula for several devices within a test, select all of them and the calculator will make the available in the dropdowns the common metrics. Now, we can calculate de partial vapour pressure as, since it's available within our channels: ## Calculate partial vapour pressure P_H2O_VAP = HUM * P_H2O_EQ / 100 We can now verify that the partial pressure is not constant and plotting it with the other channels: If we analyse the data in periods where the partial vapour pressure is fairly constant (i.e. 31 st of Aug, we see that variations of the temperature are directly correlated with the relative humidity, whilst days as the 2 nd of September show greater variations in both, temperature and partial vapour pressure that provoke a lower correlation in the temperature and humidity:","title":"Adding calculated channels"},{"location":"Sensor Analysis Framework/guides/Post processing the Stations Data/#calculating-the-actual-pollutant-concentrations","text":"Now that we know how to get around in the notebook, explore data and add channels in a simple way, lets calculate actual pollutant concentrations. For this, we will use the section AlphaSense Baseline Calibration . In this block, we will apply the methodology exlained in this section in order to calculate actual pollutant concentrations. For this, in the above mentioned section, if we run the cell, we will see an output like the following: This will list all the available devices that contain alphasense data. Remember to include the calibration data mentioned before in the dict so that we can calculate the final concentrations. For reference, all the alphasense data is under this repository , which looks like: { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162031254\" , \"Sensitivity 1\" : \"568.3\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-34\" , \"Aux Zero Current\" : \"-20.8\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162031257\" , \"Sensitivity 1\" : \"493.1\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-69.4\" , \"Aux Zero Current\" : \"-18.6\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162031256\" , \"Sensitivity 1\" : \"601.9\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-68.1\" , \"Aux Zero Current\" : \"-13.9\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162581706\" , \"Sensitivity 1\" : \"581.4\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-72.8\" , \"Aux Zero Current\" : \"-35.3\" } { \"Target 2\" : \"na\" , \"Target 1\" : \"CO\" , \"Serial No\" : \"162581707\" , \"Sensitivity 1\" : \"605\" , \"Sensitivity 2\" : \"0\" , \"Zero Current\" : \"-56.7\" , \"Aux Zero Current\" : \"-46.3\" } In the cell output, we can select the tests that contain alphasense devices and that are subject to be calculated. A brief explanation of all the checkboxes is detailed below: Decomp : attemps to decompose the trends found in the day-to-day data. This is a common technique used in time series analysis in order to avoid regression including trend. It is normally not needed since the periods that are used for the data calculacions are short enough to have no significant trend (one day + overlap*) Plots Inter : checking this plots intermediary plots of all the calculations performed within the method. Use with caution Verbose : checking this includes extra information during the calculation process. Use with caution Plots Results : plots the final calculation per pollutant and all relevant intermediary calculation. Default is to be Checked Print Stats : prints interesting statistics about the dataset for later use Now, let's calculate the pollutants. We don't need to worry about the manufacturer data, since it will automatically retrieved during the process. CO results The methodology used here is not the baseline model, but the application of this formula, as explained in here : Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} Concentration \\ [ppm] = {I_{WE}-n(I_{AE}) \\ [nA] \\over Sensitivity \\ [nA/ ppm]} As we can see, the initial data is not to be considered due to the sensor stabilisation time. If we focus on the usable data, we can already get some insights about what hours are more polluted and the difference between working days and weekends: NO 2 results For this metric, we will be using the above mentioned baseline methodology If we have a look at the data, we see that the sensor still requires stabilisation, as the CO electrode: Zooming in, we can see the most polluted hours are those in the morning: Warning OX sensor in this station is not giving good results (probably it's ageing has provoked a sensitivity loss), and therefore, the data will not be shown here.","title":"Calculating the actual pollutant concentrations"},{"location":"Sensor Platform/","text":"Sensor Platform Link The Smart Citizen platform supports the core features of the platform. That means this report documents new components, developed specifically for the project, but also existing components that already existed and made possible the platform. We believe building modular and reusable software and using existing platforms is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. The previous requirements led to the decision of building the core platform on top of the existing Smart Citizen Platform. The platform is a front and backend solution for ingesting, storing and interacting with public data with a particular focus on crowd sensing applications. Check the guides We prepared a series of guides to help you on the most common features you will use Onboarding Sensors Uploading SD Card Data Downloading data Want to learn more? Check the developers ready API Documentation Software components Link Smart Citizen Website: The platform provides a visual website where the project environmental sensors can be accessed in near real time to facilitate the exploration of data with other contextual data (maps, keywords) and processed reports. This is especially important towards citizens engaging at each local site having a sense of ownership over a technology intervention has been associated with sustained community engagement (Balestrini et al. 2014) . Smart Citizen API: The platform provides a REST interface for all the functionalities available on the Website. That allows applications to be developed on easily on top having access to all the features to create complex and rich tools. Some examples of this tools are: Smart Citizen Android App, ISCAPE Data Analysis Framework and the ISCAPE Virtual Living Lab. Virtual Living Lab: It is currently being built as part of T8.1 and will provide an online web platform where each Living Lab can share their advances and contact with their local communities. The tools will feature different modules allowing the data from the sensors deployed by a Living Lab to be visualized on the site. It retrieves the data using the Smart Citizen API. Onboarding app: It aim to facilitate the process of sensor setup to ensure that users, irrespective of technical expertise, can install the sensors. It guides the user through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. It exchange data with the core platform using the Smart Citizen API. Archiving for long term preservation: All the sensor data collected during the project will be later on submitted to the Zenodo platform for long term archiving and digital reference. As a European Commission supported initiative and technically supported by CERN, we believe this is the best way to ensure access to the generated data remains long after the project ends. Source files Link Check the source code","title":"Index"},{"location":"Sensor Platform/#sensor-platform","text":"The Smart Citizen platform supports the core features of the platform. That means this report documents new components, developed specifically for the project, but also existing components that already existed and made possible the platform. We believe building modular and reusable software and using existing platforms is critical towards optimizing the research and development effort. By increasing the technology readiness levels of existing technologies, we can drastically improve the project exploitation strategy. The previous requirements led to the decision of building the core platform on top of the existing Smart Citizen Platform. The platform is a front and backend solution for ingesting, storing and interacting with public data with a particular focus on crowd sensing applications. Check the guides We prepared a series of guides to help you on the most common features you will use Onboarding Sensors Uploading SD Card Data Downloading data Want to learn more? Check the developers ready API Documentation","title":"Sensor Platform"},{"location":"Sensor Platform/#software-components","text":"Smart Citizen Website: The platform provides a visual website where the project environmental sensors can be accessed in near real time to facilitate the exploration of data with other contextual data (maps, keywords) and processed reports. This is especially important towards citizens engaging at each local site having a sense of ownership over a technology intervention has been associated with sustained community engagement (Balestrini et al. 2014) . Smart Citizen API: The platform provides a REST interface for all the functionalities available on the Website. That allows applications to be developed on easily on top having access to all the features to create complex and rich tools. Some examples of this tools are: Smart Citizen Android App, ISCAPE Data Analysis Framework and the ISCAPE Virtual Living Lab. Virtual Living Lab: It is currently being built as part of T8.1 and will provide an online web platform where each Living Lab can share their advances and contact with their local communities. The tools will feature different modules allowing the data from the sensors deployed by a Living Lab to be visualized on the site. It retrieves the data using the Smart Citizen API. Onboarding app: It aim to facilitate the process of sensor setup to ensure that users, irrespective of technical expertise, can install the sensors. It guides the user through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. It exchange data with the core platform using the Smart Citizen API. Archiving for long term preservation: All the sensor data collected during the project will be later on submitted to the Zenodo platform for long term archiving and digital reference. As a European Commission supported initiative and technically supported by CERN, we believe this is the best way to ensure access to the generated data remains long after the project ends.","title":"Software components"},{"location":"Sensor Platform/#source-files","text":"Check the source code","title":"Source files"},{"location":"Sensor Platform/guides/Downloading the Data/","text":"Downloading the Data Link Once you've added your SCK to the platform and it's capturing and sending data correctly, you can interact with the platform in several ways. Visualizing the data, downloading the data and interacting with the data through the API. Download Data Link If you are interested in use the data captured by your sensors, you can download all the data for later use. To do this, go to your device page, at the bottom there is a button called DOWNLOAD DATA . You will receive an email with a link to download your data on CSV format in less than a minute, API Link The Smart Citizen API allows you to request back information from your devices and do incredible things with it. It is a REST API and it returns the information in JSON format. This means you can easily access the information from any language like Javascript, PHP, Processing.org, Python, and start doing things with it quickly. Code examples We are working to provide enhanced tutorials on how to interface the API. At the moment you can find some examples on smartcitizen-toolkit respository","title":"Downloading the Data"},{"location":"Sensor Platform/guides/Downloading the Data/#downloading-the-data","text":"Once you've added your SCK to the platform and it's capturing and sending data correctly, you can interact with the platform in several ways. Visualizing the data, downloading the data and interacting with the data through the API.","title":"Downloading the Data"},{"location":"Sensor Platform/guides/Downloading the Data/#download-data","text":"If you are interested in use the data captured by your sensors, you can download all the data for later use. To do this, go to your device page, at the bottom there is a button called DOWNLOAD DATA . You will receive an email with a link to download your data on CSV format in less than a minute,","title":"Download Data"},{"location":"Sensor Platform/guides/Downloading the Data/#api","text":"The Smart Citizen API allows you to request back information from your devices and do incredible things with it. It is a REST API and it returns the information in JSON format. This means you can easily access the information from any language like Javascript, PHP, Processing.org, Python, and start doing things with it quickly. Code examples We are working to provide enhanced tutorials on how to interface the API. At the moment you can find some examples on smartcitizen-toolkit respository","title":"API"},{"location":"Sensor Platform/guides/Onboarding Sensors/","text":"Onboarding Sensors Link The oboarding appp guides you through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. Onboarding app Visit the onboarding app at start.smartcitizen.me Step by step Welcome page Select all the parts you received to ensure you are not missing any part Turn on your Kit Close the cover of your device Choose the Wi-Fi network you want to connect to You will reiceive a message when the Kit it is connected Add a name to your sensor Select the location for your sensor Add your email to register the Kit under your name Add a user name for people to see you on the platform Add a password to protect your account You are done! Visit the Kit on the platform. Wait one minute till it publishes data Look at the data!","title":"Onboarding Sensors"},{"location":"Sensor Platform/guides/Onboarding Sensors/#onboarding-sensors","text":"The oboarding appp guides you through the process of the setup using simple language and a friendly graphic language. It is built as a separate tool from the core Smart Citizen Webpage in order it can be customized for each deployment. Onboarding app Visit the onboarding app at start.smartcitizen.me Step by step Welcome page Select all the parts you received to ensure you are not missing any part Turn on your Kit Close the cover of your device Choose the Wi-Fi network you want to connect to You will reiceive a message when the Kit it is connected Add a name to your sensor Select the location for your sensor Add your email to register the Kit under your name Add a user name for people to see you on the platform Add a password to protect your account You are done! Visit the Kit on the platform. Wait one minute till it publishes data Look at the data!","title":"Onboarding Sensors"},{"location":"Sensor Platform/guides/Uploading SD Card Data/","text":"Uploading SD Card Data Link Here some instructions on how to upload CSV files to Smartcitizen platform. First be sure to be logged and go to your profile . Step by step On your kits' list, click on the wheel and then on \"Upload CSV\". Once on the upload page, you can add some files by clicking on the \"Load CSV files\" button. Select some files as much as you like, to be them ready to upload. Then on the drop-down menu select the \"Upload\" option Click on the \"Apply\" button to upload them Congrats! You just uploaded your files CSV files on the Smartcitizen platform.","title":"Uploading SD Card Data"},{"location":"Sensor Platform/guides/Uploading SD Card Data/#uploading-sd-card-data","text":"Here some instructions on how to upload CSV files to Smartcitizen platform. First be sure to be logged and go to your profile . Step by step On your kits' list, click on the wheel and then on \"Upload CSV\". Once on the upload page, you can add some files by clicking on the \"Load CSV files\" button. Select some files as much as you like, to be them ready to upload. Then on the drop-down menu select the \"Upload\" option Click on the \"Apply\" button to upload them Congrats! You just uploaded your files CSV files on the Smartcitizen platform.","title":"Uploading SD Card Data"}]}